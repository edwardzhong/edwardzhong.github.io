[{"title":"使用typescript改造koa开发框架","date":"2020-02-04T03:37:48.000Z","path":"2020/02/04/koatypescript/","text":"原文地址：使用typescript改造koa开发框架 强类型的 TypeScript 开发体验和维护项目上相比 JavaScript 有着明显的优势，那么对常用的脚手架进行改造也就势在必行了。 接下来开始对基于 koa 框架的 node 后端脚手架进行改造： 项目开发环境 和 typescript 编译环境的搭建； 对 node、koa、koa中间件和使用到的库 添加类型化支持； 基于 typesript 的特性改造项目。 项目开发环境搭建基于 gulp 搭建开发编译环境，gulp-typescript 插件用于编译 typescript 文件， gulp-nodemon 则可以监控文件内容的变更，自动编译和重启node服务，提升开发效率。 npm install -D gulp gulp-nodemon gulp-typescript ts-node typescript gulp 的配置gulpfile.js 的设置 const &#123; src, dest, watch, series, task &#125; = require('gulp');const del = require('del');const ts = require('gulp-typescript');const nodemon = require('gulp-nodemon');const tsProject = ts.createProject('tsconfig.json');function clean(cb) &#123; return del(['dist'], cb);&#125;// 输出 js 到 dist目录function toJs() &#123; return src('src/**/*.ts') .pipe(tsProject()) .pipe(dest('dist'));&#125;// nodemon 监控 ts 文件function runNodemon() &#123; nodemon(&#123; inspect: true, script: 'src/app.ts', watch: ['src'], ext: 'ts', env: &#123; NODE_ENV: 'development' &#125;, // tasks: ['build'], &#125;).on('crash', () =&gt; &#123; console.error('Application has crashed!\\n'); &#125;);&#125;const build = series(clean, toJs);task('build', build);exports.build = build;exports.default = runNodemon; typescript 的配置tsconfig.json 的设置 &#123; \"compilerOptions\": &#123; \"baseUrl\": \".\", // import的相对起始路径 \"outDir\": \"./dist\", // 构建输出目录 \"module\": \"commonjs\", \"target\": \"esnext\",// node 环境支持 esnext \"allowSyntheticDefaultImports\": true, \"importHelpers\": true, \"strict\": false, \"moduleResolution\": \"node\", \"esModuleInterop\": true, \"forceConsistentCasingInFileNames\": true, \"noImplicitAny\": true, \"suppressImplicitAnyIndexErrors\": true, \"noUnusedParameters\": true, \"noUnusedLocals\": true, \"noImplicitReturns\": true, \"experimentalDecorators\": true, // 开启装饰器的使用 \"emitDecoratorMetadata\": true, \"allowJs\": true, \"sourceMap\": true, \"paths\": &#123; \"@/*\": [ \"src/*\" ] &#125; &#125;, \"include\": [ \"src/**/*\" ], \"exclude\": [ \"node_modules\", \"dist\" ]&#125; eslint 的配置当然 eslint 也要添加对 typescript 对支持 npm install -D @typescript-eslint/eslint-plugin @typescript-eslint/parser .eslintrc.json 的设置 &#123; \"env\": &#123; \"es6\": true, \"node\": true &#125;, \"extends\": [ \"eslint:recommended\", \"plugin:@typescript-eslint/eslint-recommended\" ], \"globals\": &#123; \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" &#125;, \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": &#123; \"ecmaVersion\": 2018, \"sourceType\": \"module\" &#125;, \"plugins\": [ \"@typescript-eslint\" ], \"rules\": &#123; \"indent\": [ \"warn\", 2 ], \"no-unused-vars\": 0 &#125;&#125; package.json 运行配置最后就是设置 package.json 的 scripts \"scripts\": &#123; \"start\": \"gulp\",// dev \"build\": \"gulp build\", // output \"eslint\": \"eslint --fix --ext .js,.ts src/\", \"server\": \"export NODE_ENV=production &amp;&amp; node dist/app\" // production server&#125;, 添加类型化支持项目主要使用到了以下的组件 jsonwebtoken koa koa-body koa-compress koa-favicon koa-logger koa-router koa-static koa2-cors log4js 那么就要安装对应的 type 文件，当然别忘了 @types/node npm install -D @types/jsonwebtoken @types/koa @types/koa-compress @types/koa-favicon @types/koa-logger @types/koa-router @types/koa-static @types/koa2-cors @types/log4js @types/node 使用 typescript 装饰器 改造项目.net mvc 框架有个很便利的地方就是 使用装饰器对控制器进行配置，现在通过 typescript 的装饰器也可以实现相同的功能。这里需要使用到反射相关的库 reflect-metadata，用过 Java 或 C# 的小伙伴，对反射的原理一定不陌生。 定义http请求的装饰器我们再也不需要在路由配置和控制器方法之前来回查找和匹配了 import 'reflect-metadata'import &#123; ROUTER_MAP &#125; from '../constant'/** * @desc 生成 http method 装饰器 * @param &#123;string&#125; method - http method，如 get、post、head * @return Decorator - 装饰器 */function createMethodDecorator(method: string) &#123; // 装饰器接收路由 path 作为参数 return function httpMethodDecorator(path: string) &#123; return (proto: any, name: string) =&gt; &#123; const target = proto.constructor; const routeMap = Reflect.getMetadata(ROUTER_MAP, target, 'method') || []; routeMap.push(&#123; name, method, path &#125;); Reflect.defineMetadata(ROUTER_MAP, routeMap, target, 'method'); &#125;; &#125;;&#125;// 导出 http method 装饰器export const post = createMethodDecorator('post');export const get = createMethodDecorator('get');export const del = createMethodDecorator('del');export const put = createMethodDecorator('put');export const patch = createMethodDecorator('patch');export const options = createMethodDecorator('options');export const head = createMethodDecorator('head');export const all = createMethodDecorator('all'); 装饰控制器的方法export default class Sign &#123; @post('/login') async login (ctx: Context) &#123; const &#123; email, password &#125; = ctx.request.body; const users = await userDao.getUser(&#123; email &#125;); // ... return ctx.body = &#123; code: 0, message: '登录成功', data &#125;; &#125; @post('/register') async register (ctx: Context) &#123; const &#123; email, password &#125; = ctx.request.body; const salt = makeSalt(); // ... return ctx.body = &#123; code: 0, message: '注册成功！', data &#125; &#125; &#125; 收集元数据和添加路由我们已经把装饰器添加到对应控制器的方法上了，那么怎么把元数据收集起来呢？这就需要用到 node 提供的 fs 文件模块，node服务第一次启动的时候，扫描一遍controller文件夹，收集到所有控制器模块，结合装饰器收集到的metadata，就可以把对应的方法添加到 koa-router。 import 'reflect-metadata'import fs from 'fs'import path from 'path'import &#123; ROUTER_MAP &#125; from './constant'import &#123; RouteMeta &#125; from './type'import Router from 'koa-router'const addRouter = (router: Router) =&gt; &#123; const ctrPath = path.join(__dirname, 'controller'); const modules: ObjectConstructor[] = []; // 扫描controller文件夹，收集所有controller fs.readdirSync(ctrPath).forEach(name =&gt; &#123; if (/^[^.]+?\\.(t|j)s$/.test(name)) &#123; modules.push(require(path.join(ctrPath, name)).default) &#125; &#125;); // 结合meta数据添加路由 modules.forEach(m =&gt; &#123; const routerMap: RouteMeta[] = Reflect.getMetadata(ROUTER_MAP, m, 'method') || []; if (routerMap.length) &#123; const ctr = new m(); routerMap.forEach(route =&gt; &#123; const &#123; name, method, path &#125; = route; router[method](path, ctr[name]); &#125;) &#125; &#125;)&#125;export default addRouter 最后这样对koa项目脚手架的改造基本完成，源码请查看 koa-server","tags":[{"name":"node","slug":"node","permalink":"https://edwardzhong.github.io/tags/node/"},{"name":"koa","slug":"koa","permalink":"https://edwardzhong.github.io/tags/koa/"},{"name":"typescript","slug":"typescript","permalink":"https://edwardzhong.github.io/tags/typescript/"}]},{"title":"WebGL之物体选择","date":"2019-05-28T07:07:25.000Z","path":"2019/05/28/webglray/","text":"使用WebGL将图形绘制到画布后，如何与外部进行交互？这其中最关键的就是如何实现物体的选择。比如鼠标点击后判断是否选中了某个图形或图形的某个部分。 本节实现的效果: WebGL选中物体 如何实现选中物体颜色区分法《WebGL编程指南》中提出了一个原理很简单的解决方案，步骤如下： 鼠标按下时物体重绘为红色或其他能区分的颜色 读取鼠标点击处像素的颜色 gl.readPixels(x,y,width,height,format,type,pixels) 使用物体原来的颜色进行重绘，以恢复物体本来颜色 判断第2步读取到的颜色是否与预设的颜色值相等，相等则表示点击中物体 可以说这是个非常容易实现的方案，不过要为每个物体分别设置不同的区分颜色却是个隐患，同时也不够友好。 光线投射法这是使用最广泛也最精确的一种方案了，Three.js 中的光线投射器 (Raycaster) 就实现了这种方案，可以看里面的源代码。它的基本原理: 从视点出发的光线首先投射到近截面，最后投射到远截面，结合鼠标点击的位置 (x, y) 和视图投影矩阵 (viewProjection)。可以得出由近截面坐标 (x1, y1, z1) 和远截面坐标 (x2, y2, z2) 组成的射线向量。然后我们就可以将物体坐标构成的面逐个与这个向量进行对比。这涉及到线性代数中的向量，点积，叉积，矩阵等概念，比较复杂。主要分两个步骤： 创建物体的包围盒，判断射线是否穿过该物体包围盒 判断射线是否穿过该物体的某个三角形面，如果经过即可判断选中了该物体 下面就分步实现光线投射算法的上面两个步骤 包围盒包围盒算法原理如下： 首先用视图投影模型矩阵 (mvp) 对图形坐标进行变换，得到在屏幕中的绘制坐标[x,y,z] 遍历每个坐标得出一个由最大最小xy坐标 [xmax, xmin, ymax, ymin] 构成的二维包围盒 鼠标位置 (x, y) 与包围盒边界进行比较，如果坐标处于盒子边界之内，那么就可判断选中了该物体 核心代码如下: canvas.addEventListener('mousemove', function(e) &#123; //坐标转换为webgl表示区间 const pos = util.windowToWebgl(tCanvas,e.clientX,e.clientY); const ps = []; Polygons.forEach((p,i)=&gt;&#123; //重置状态 p.select = false; //mvp矩阵 const matrix = m4.translate(viewProjection, p.pos); let xmax, ymax, xmin, ymin, zmax, zmin;//包围盒边界 //遍历顶点获取包围盒的边界 for(let j = 0; j &lt; p.position.length; j = j+3)&#123; //对坐标进行矩阵转换 const s = m4.transformPoint(matrix, p.position.slice(j,j+3)); if(j == 0)&#123; xmax = s[0]; xmin = s[0]; ymax = s[1]; ymin = s[1]; zmax = s[2]; zmin = s[2]; continue; &#125; if(s[0]&gt;xmax) xmax = s[0]; if(s[0]&lt;xmin) xmin = s[0]; if(s[1]&gt;ymax) ymax = s[1]; if(s[1]&lt;ymin) ymin = s[1]; if(s[2]&gt;zmax) zmax = s[2]; if(s[2]&lt;zmin) zmin = s[2]; &#125; // 射线处于包围盒内 if(pos.x &gt;= xmin &amp;&amp; pos.x &lt;= xmax &amp;&amp; pos.y &gt;= ymin &amp;&amp; pos.y &lt;= ymax)&#123; p.coord = [(xmax+xmin)/2,(ymax+ymin)/2,(zmax+zmin)/2]; ps.push(p); &#125; &#125;); if(!ps.length) return; //获取最靠近视点的图形 const sel = ps.length == 1? ps[0]: ps.sort((a,b)=&gt; a.coord[2] - b.coord[2])[0]; sel.select = true;&#125;,false); 射线与三角形相交但是包围盒算法判断地不是很精准，在物体形状不是很规则或物体间靠拢的比较紧时表现得尤其明显。 我们知道WebGL图形是由三角形构成的，那么进一步判断射线是否相交该物体某个三角形面就会非常精确了。 数学原理如下： 三角形内的任意一点都可以用它相对于三角形的顶点的位置来定义: T(u,v) = (1 - u - v)V0 + uV1 + vV2 其中 u &gt;= 0, v &gt;= 0, u + v &lt;= 1 ，称为重心坐标 射线可以用参数方程表示为: T(t) = P + td 其中P为起始点，d为方向向量 因此计算直线与三角的交点的等式为： P + td = (1-u-v)V0 + uV1 + vV2 整理后最终得到一个齐次线性方程组，其中[t u v] 为1 x 3 的矩阵，(t,u,v) 是它的解 [-d V1-V0 V2-V0] [t u v] = [P-V0] 根据克莱姆法则求解，其中T = P - V0, E1 = V1 - V0, E2 = V2 - V0，( [(T x E1) • E2] [(d x E2) • T] [(T x E1) • d] ) 为 3 x 3 矩阵，等式最终可以写成如下： (t,u,v) = 1/((d x E2) • E1) ( [(T x E1) • E2] [(d x E2) • T] [(T x E1) • d] ) 具体实现代码如下： // 射线处于包围盒内if(pos.x &gt;= xmin &amp;&amp; pos.x &lt;= xmax &amp;&amp; pos.y &gt;= ymin &amp;&amp; pos.y &lt;= ymax)&#123; p.coord = [(xmax+xmin)/2,(ymax+ymin)/2,(zmax+zmin)/2]; const P = [pos.x,pos.y,0.5];//射线起始点 const d = [0,0,1];//射线方向 for(let j = 0; j &lt; p.position.length; j = j + 9)&#123; //三角形顶点 const V0 = m4.transformPoint(matrix, p.position.slice(j,j+3)); const V1 = m4.transformPoint(matrix, p.position.slice(j+3,j+6)); const V2 = m4.transformPoint(matrix, p.position.slice(j+6,j+9)); const T = v3.subtract(P,V0); const E1 = v3.subtract(V1,V0); const E2 = v3.subtract(V2,V0); const M = v3.cross(d,E2); const det = v3.dot(M,E1); if(det == 0) continue; const K = v3.cross(T,E1); const t = v3.dot(K,E2)/det; const u = v3.dot(M,T)/det; const v = v3.dot(K,d)/det; //射线与三角形相加 if(u &gt;= 0 &amp;&amp; v &gt;= 0 &amp;&amp; u+v&lt;=1 )&#123; ps.push(p); break; &#125; &#125;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL学习之HDR与Bloom","date":"2019-05-21T07:09:15.000Z","path":"2019/05/21/webglhdr/","text":"什么是HDRHDR (High Dynamic Range，高动态范围)，在摄影领域，指的是可以提供更多的动态范围和图像细节的一种技术手段。简单讲就是将不同曝光拍摄出的最佳细节的LDR (低动态范围) 图像合成后，就叫HDR，它能同时反映出场景最暗和最亮部分的细节。为什么需要多张图片？因为目前的单反相机的宽容度还是有限的，一张照片不能反映出高动态场景的所有细节。一张图片拍摄就必须要在暗光和高光之间做出取舍，只能亮部暗部两者取其一。但是通过HDR合成多张图片，却能达到我们想要的效果。 那么在WebGL中，HDR具体指的是什么。它指的是让我们能用超过1.0的数据表示颜色值。到目前为止，我们用的都是LDR（低动态范围），所有的颜色值都被限制在了 [0,1] 范围。在现实当中，太阳，灯光这类光源它们的颜色值肯定是远远超出1.0的范围的。 本节实现的效果请看hdr &amp; bloom 浮点帧缓冲当帧缓冲使用标准化的定点格式(像gl.RGB)为其颜色缓冲的内部格式，WebGL会在将这些值存入帧缓冲前自动将其约束到0.0到1.0之间。这一操作对大部分帧缓冲格式都是成立的，除了专门用来存放被拓展范围值的浮点格式。 WebGL扩大颜色值范围的方法就是：把颜色的格式设置成16位浮点数或者32位浮点数，即把帧缓冲的颜色缓冲的内部格式设定成 gl.RGB16F, gl.RGBA16F, gl.RGB32F 或者 gl.RGBA32F，这些帧缓冲被叫做浮点帧缓冲(Floating Point Framebuffer)，浮点帧缓冲可以存储超过0.0到1.0范围的浮点值，所以非常适合HDR渲染。 创建浮点帧缓冲，我们只需要改变颜色缓冲的内部格式参数就行了（注意 gl.FLOAT参数)： gl.bindTexture(gl.TEXTURE_2D, colorBuffer);gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, gl.RGB, gl.FLOAT, NULL); 帧缓冲默认一个颜色分量只占用8位(bits)。当使用一个使用32位每颜色分量时(使用gl.RGB32F 或者 gl.RGBA32F)，我们需要四倍的内存来存储这些颜色。所以除非你需要一个非常高的精确度，32位不是必须的，使用 gl.RGB16F就足够了。 色调映射色调映射(Tone Mapping)是一个损失很小的转换浮点颜色值至我们所需的LDR[0.0, 1.0]范围内的过程，通常会伴有特定的风格的色平衡(Stylistic Color Balance)。 最简单的色调映射算法是Reinhard色调映射，它涉及到分散整个HDR颜色值到LDR颜色值上，所有的值都有对应。Reinhard色调映射算法平均地将所有亮度值分散到LDR上。将Reinhard色调映射应用到之前的片段着色器上，并且加上一个Gamma校正过滤： void main()&#123; const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; // Reinhard色调映射 vec3 mapped = hdrColor / (hdrColor + vec3(1.0)); // Gamma校正 mapped = pow(mapped, vec3(1.0 / gamma)); color = vec4(mapped, 1.0);&#125; 有了Reinhard色调映射的应用，我们不再会在场景明亮的地方损失细节。当然，这个算法是倾向明亮的区域的，暗的区域会不那么精细也不那么有区分度。 另一个色调映射应用是曝光(Exposure)参数的使用。HDR图片包含在不同曝光等级的细节。如果我们有一个场景要展现日夜交替，我们当然会在白天使用低曝光，在夜间使用高曝光，就像人眼调节方式一样。有了这个曝光参数，我们可以去设置可以同时在白天和夜晚不同光照条件工作的光照参数，我们只需要调整曝光参数就行了。 一个简单的曝光色调映射算法会像这样： uniform float exposure;void main()&#123; const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; // 曝光色调映射 vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure); // Gamma校正 mapped = pow(mapped, vec3(1.0 / gamma)); color = vec4(mapped, 1.0);&#125; 什么是BloomBloom 泛光 (或者眩光)，是用来模拟光源那种发光或发热的技术。区分明亮光源的方式是使它们发出光芒，光源的光芒向四周发散，这样观察者就会产生光源或亮区的确是强光区。Bloom使我们感觉到一个明亮的物体真的有种明亮的感觉。而Bloom和HDR的结合使用能非常完美地展示光源效果。 泛光的品质很大程度上取决于所用的模糊过滤器的质量和类型。下面这几步就是泛光后处理特效的过程，它总结了实现泛光所需的步骤。 提取亮色首先我们要从渲染出来的场景中提取两张图片。可以渲染场景两次，每次使用一个不同的不同的着色器渲染到不同的帧缓冲中，但可以使用一个叫做MRT（Multiple Render Targets多渲染目标）的小技巧，有了它我们能够在一个单独渲染处理中提取两个图片。在片元着色器的输出前，我们指定一个布局location标识符，这样我们便可控制一个片元着色器写入到哪个颜色缓冲： layout (location = 0) out vec4 FragColor;layout (location = 1) out vec4 BrightColor; 使用多个片元着色器输出的必要条件是，有多个颜色缓冲附加到了当前绑定的帧缓冲对象上。直到现在，我们一直使用着 gl.COLOR_ATTACHMENT0，但通过使用 gl.COLOR_ATTACHMENT1，可以得到一个附加了两个颜色缓冲的帧缓冲对象。 但首先我们还是将创建帧缓冲的功能进行封装： function createFramebuffer(gl,opt,width,height)&#123; const fb = gl.createFramebuffer(); gl.bindFramebuffer(gl.FRAMEBUFFER, fb); const framebufferInfo = &#123; framebuffer: fb, textures: [] &#125;; const texs = opt.texs || 1;//颜色缓冲数量 const depth = !!opt.depth; // SECTION 创建纹理 for(let i=0;i&lt; texs;i++)&#123; const tex = initTexture(gl,opt, width, height); framebufferInfo.textures.push(tex); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, tex, 0); &#125; // SECTION 创建用于保存深度的渲染缓冲区 if(depth) &#123; const depthBuffer = gl.createRenderbuffer(); gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height); gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer); &#125; // 检查帧缓冲区对象 const e = gl.checkFramebufferStatus(gl.FRAMEBUFFER); if (gl.FRAMEBUFFER_COMPLETE !== e) &#123; throw new Error('Frame buffer object is incomplete: ' + e.toString()); &#125; // 解绑帧缓冲区对象 gl.bindFramebuffer(gl.FRAMEBUFFER, null); gl.bindTexture(gl.TEXTURE_2D, null); if(depth) gl.bindRenderbuffer(gl.RENDERBUFFER, null); return framebufferInfo;&#125; 接着调用上面的函数创建包含两个颜色附件和一个深度附件的帧缓冲区。 //场景帧缓存(2颜色附件 包含正常颜色 和 hdr高光颜色，1深度附件)const fbo = createFramebuffer(gl,&#123;informat:gl.RGBA16F, type:gl.FLOAT, texs:2, depth:true&#125;); 在渲染的时候还需要显式告知WebGL我们正在通过gl.drawBuffers渲染到多个颜色缓冲，否则WebGL只会渲染到帧缓冲的第一个颜色附件，而忽略所有其他的。 //采样到2个颜色附件gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]); 当渲染到这个帧缓冲的时候，一个着色器使用一个布局location修饰符，然后把不同颜色值渲染到相应的颜色缓冲。这样就省去了为提取高光区域的额外渲染步骤。 #version 300 esprecision highp float; layout (location = 0) out vec4 FragColor;layout (location = 1) out vec4 BrightColor;//...void main() &#123; vec3 normal = normalize(vNormal); vec3 viewDirection = normalize(u_viewPosition - vposition); //... vec3 result = ambient + lighting; // 检查结果值是否高于某个门槛，如果高于就渲染到高光颜色缓存中 float brightness = dot(result, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0)&#123; BrightColor = vec4(result, 1.0); &#125; else &#123; BrightColor = vec4(0.0, 0.0, 0.0, 1.0); &#125; FragColor = vec4(result, 1.0);&#125; 这里先正常计算光照，将其传递给第一个片元着色器的输出变量FragColor。然后我们使用当前储存在FragColor的东西来决定它的亮度是否超过了一定阈限。我们通过恰当地将其转为灰度的方式计算一个fragment的亮度，如果它超过了一定阈限，我们就把颜色输出到第二个颜色缓冲，那里保存着所有亮部。 这也说明了为什么泛光在HDR基础上能够运行得很好。因为HDR中，我们可以将颜色值指定超过1.0这个默认的范围，我们能够得到对一个图像中的亮度的更好的控制权。没有HDR我们必须将阈限设置为小于1.0的数，虽然可行，但是亮部很容易变得很多，这就导致光晕效果过重。 有了一个提取出的亮区图像，我们现在就要把这个图像进行模糊处理。 高斯模糊要实现高斯模糊过滤需要一个二维四方形作为权重，从这个二维高斯曲线方程中去获取它。然而这个过程有个问题，就是很快会消耗极大的性能。以一个32×32的模糊kernel为例，我们必须对每个fragment从一个纹理中采样1024次！ 幸运的是，高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：一个描述水平权重，另一个描述垂直权重。我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊。利用这个特性，结果是一样的，但是可以节省难以置信的性能，因为我们现在只需做32+32次采样，不再是1024了！这叫做两步高斯模糊。这意味着我们如果对一个图像进行模糊处理，至少需要两步，最好使用帧缓冲对象做这件事。具体来说，我们将实现像乒乓球一样的帧缓冲来实现高斯模糊。意思是使用一对帧缓冲，我们把另一个帧缓冲的颜色缓冲放进当前的帧缓冲的颜色缓冲中，使用不同的着色效果渲染指定的次数。基本上就是不断地切换帧缓冲和纹理去绘制。这样我们先在场景纹理的第一个缓冲中进行模糊，然后在把第一个帧缓冲的颜色缓冲放进第二个帧缓冲进行模糊，接着将第二个帧缓冲的颜色缓冲放进第一个，循环往复。 在我们研究帧缓冲之前，先来实现高斯模糊的片元着色器： #version 300 esprecision highp float;uniform sampler2D image;uniform bool horizontal;in vec2 texcoord;out vec4 FragColor;const float weight[5] = float[](0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);void main() &#123; vec2 tex_offset = vec2(1.0 / float(textureSize(image, 0)));//每个像素的尺寸 vec3 result = texture(image, texcoord).rgb * weight[0]; if (horizontal) &#123; for (int i = 0; i &lt; 5; ++i) &#123; result += texture(image, texcoord + vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i]; result += texture(image, texcoord - vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i]; &#125; &#125; else &#123; for (int i = 0; i &lt; 5; ++i) &#123; result += texture(image, texcoord + vec2(0.0, tex_offset.y * float(i))).rgb * weight[i]; result += texture(image, texcoord - vec2(0.0, tex_offset.y * float(i))).rgb * weight[i]; &#125; &#125; FragColor = vec4 (result, 1.0);&#125; 这里使用一个比较小的高斯权重做例子，每次我们用它来指定当前fragment的水平或垂直样本的特定权重。你会发现我们基本上是将模糊过滤器根据我们在uniform变量horizontal设置的值分割为一个水平和一个垂直部分。通过用1.0除以纹理的大小（从textureSize得到一个vec2）得到一个纹理像素的实际大小，以此作为偏移距离的根据。 接着为图像的模糊处理创建两个基本的帧缓冲，每个只有一个颜色缓冲纹理，调用上面封装好的createFramebuffer函数即可。 //2乒乓帧缓存(都只包含1颜色附件)const hFbo = createFramebuffer(gl,&#123;informat:gl.RGBA16F, type:gl.FLOAT&#125;);const vFbo = createFramebuffer(gl,&#123;informat:gl.RGBA16F, type:gl.FLOAT&#125;); 得到一个HDR纹理后，我们用提取出来的亮区纹理填充一个帧缓冲，然后对其模糊处理6次（3次垂直3次水平）： /** * 乒乓帧缓存 */gl.useProgram(pProgram.program);for(let i=0; i &lt; 6; i++)&#123; bindFramebufferInfo(gl, i%2 ? hFbo:vFbo); setBuffersAndAttributes(gl, pProgram, pVao); setUniforms(pProgram,&#123; horizontal: i%2? true:false, image: i == 0 ? fbo.textures[1]: i%2 ? vFbo.textures[0]: hFbo.textures[0], //第1次两个乒乓帧缓存都为空，因此第一次要将灯光纹理传入 &#125;); drawBufferInfo(gl, pVao);&#125; 每次循环根据渲染的是水平还是垂直来绑定两个缓冲其中之一，而将另一个绑定为纹理进行模糊。第一次迭代，因为两个颜色缓冲都是空的所以我们随意绑定一个去进行模糊处理。重复这个步骤6次，亮区图像就进行一个重复3次的高斯模糊了。这样我们可以对任意图像进行任意次模糊处理；高斯模糊循环次数越多，模糊的强度越大。 把两个纹理混合有了场景的HDR纹理和模糊处理的亮区纹理，只需把它们结合起来就能实现泛光或称光晕效果了。最终的片元着色器要把两个纹理混合： #version 300 esprecision highp float;in vec2 texcoord;uniform sampler2D image;uniform sampler2D imageBlur;uniform bool bloom;out vec4 FragColor;const float exposure = 1.0;const float gamma = 2.2;void main() &#123; vec3 hdrColor = texture(image, texcoord).rgb; vec3 bloomColor = texture(imageBlur, texcoord).rgb; if (bloom) hdrColor += bloomColor; //添加融合 //色调映射 // vec3 result = hdrColor / (hdrColor + vec3(1.0)); vec3 result = vec3 (1.0) - exp(-hdrColor * exposure); //进行gamma校正 result = pow(result, vec3 (1.0 / gamma)); FragColor = vec4(result, 1.0);&#125; 注意要在应用色调映射之前添加泛光效果。这样添加的亮区的泛光，也会柔和转换为LDR，光照效果相对会更好。把两个纹理结合以后，场景亮区便有了合适的光晕特效： 这里只用了一个相对简单的高斯模糊过滤器，它在每个方向上只有5个样本。通过沿着更大的半径或重复更多次数的模糊，进行采样我们就可以提升模糊的效果。因为模糊的质量与泛光效果的质量正相关，提升模糊效果就能够提升泛光效果。 后记这个HDR + Bloom的是目前为止渲染流程最复杂的一个特效了，使用了3个着色器program和3个帧缓冲区，绘制的时候要不断切换program 和 帧缓冲区。目前有个问题是，从帧缓冲渲染到正常缓冲后场景的锯齿感挺严重的，后续还得深入学习下抗锯齿(anti-aliasing)。 参考资料:HDR泛光","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL学习之纹理盒","date":"2019-05-05T13:34:20.000Z","path":"2019/05/05/webglskybox/","text":"我们之前已经学习过二维纹理 gl.TEXTURE_2D，而且还使用它实现了各种效果。但还有一种立方体纹理 gl.TEXTURE_CUBE_MAP，它包含了6个纹理代表立方体的6个面。不像常规的纹理坐标有2个纬度，立方体纹理使用法向量，换句话说三维方向。本节实现的demo请看 天空盒 根据法向量的朝向选取立方体6个面中的一个，这个面的像素用来采样生成颜色。这六个面通过他们相对于立方体中心的方向被引用。它们是分别是 gl.TEXTURE_CUBE_MAP_POSITIVE_X//右gl.TEXTURE_CUBE_MAP_NEGATIVE_X//左gl.TEXTURE_CUBE_MAP_POSITIVE_Y//上gl.TEXTURE_CUBE_MAP_NEGATIVE_Y//下gl.TEXTURE_CUBE_MAP_POSITIVE_Z//后gl.TEXTURE_CUBE_MAP_NEGATIVE_Z//前 环境贴图其实我们更应该把cube map叫作纹理盒，通常纹理盒不是给立方体设置纹理用的，设置立方体纹理的标准用法其实是使用二维贴图，那么纹理盒用来做什么的呢？纹理盒最常见的用法是用来做环境贴图。在百度和google地图中的3D街景就是环境贴图应用的一个例子。 纹理下面是6张红色峡谷图片 将以上尺寸为512x512的图片填充到立方体的每个面，以下就是纹理的创建加载过程 // 创建纹理。var texture = gl.createTexture();gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture); const faceInfos = [ &#123; target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, url: '/img/sorbin_rt.jpg', &#125;, &#123; target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, url: '/img/sorbin_lf.jpg', &#125;, &#123; target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, url: '/img/sorbin_up.jpg', &#125;, &#123; target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, url: '/img/sorbin_dn.jpg', &#125;, &#123; target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, url: '/img/sorbin_bk.jpg', &#125;, &#123; target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, url: '/img/sorbin_ft.jpg', &#125;,];faceInfos.forEach((faceInfo) =&gt; &#123; const &#123;target, url&#125; = faceInfo; // 上传画布到立方体贴图的每个面 const level = 0; const format = gl.RGBA; const width = 512; const height = 512; const type = gl.UNSIGNED_BYTE; // 设置每个面，使其立即可渲染 gl.texImage2D(target, level, format, width, height, 0, format, type, null); // 异步加载图片 const image = new Image(); image.src = url; image.onload = function() &#123; // 图片加载完成将其拷贝到纹理 gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture); gl.texImage2D(target, level, internalFormat, format, type, image); gl.generateMipmap(gl.TEXTURE_CUBE_MAP); &#125;;&#125;);gl.generateMipmap(gl.TEXTURE_CUBE_MAP);gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); 法向量标准立方体法向量 和 纹理盒法向量的区别 3D立方体使用纹理盒有一个巨大的好处就是不需要额外指定纹理坐标。只要盒子是被放置在世界坐标系的原点，盒子本身的坐标就可以作为纹理坐标使用，因为在3D世界中位置本身就是一个向量，表示一个方向，我们要的就是这个方向。 所以顶点着色器非常简单 attribute vec4 a_position;uniform mat4 u_vpMatrix;varying vec3 v_normal;void main() &#123; gl_Position = u_vpMatrix * a_position; //因为位置是以几何中心为原点的,可以用顶点坐标作为法向量 v_normal = normalize(a_position.xyz);&#125; 片段着色器中我们需要用samplerCube 代替 sampler2D 用 textureCube代替texture2D。textureCube 需要vec3类型的向量。 法向量从顶点着色器传递过来经过了插值处理，需要重新单位化。 precision mediump float; // 从顶点着色器传入。varying vec3 v_normal; // 纹理。uniform samplerCube u_texture; void main() &#123; gl_FragColor = textureCube(u_texture, normalize(v_normal));&#125; 实现运行后得到如下的效果，很明显就能看出是个立方体，并不是我们想要的360度环绕的3D场景。 其实我们只需要将相机位置置于原点(0,0,0)，同时lookAt向其中的一个面就可以了。但是在原点有个问题，如果要旋转查看场景怎么办？我们可以通过旋转相机的位置，这其实就相当于立方体旋转，同时我们不需要矩阵位移相关的信息，只需要方向相关的信息就好了。同时还可以禁止写入深度缓存，造成背景在很远的假象，让效果更加真实。 const viewPosition = new Vector3([0,0,1]);//相机位置const lookAt = [0, 0, 0];//原点//相机绕y轴旋转cameraMatrix.rotate(0.2,0,1,0);viewPoint = cameraMatrix.multiplyVector3(viewPosition);vpMatrix.setPerspective( 30, canvas.width / canvas.height, 0.1, 5 );vpMatrix.lookAt(...viewPoint.elements, ...lookAt, 0, 1, 0);//重置位移vpMatrix.elements[12] = 0;vpMatrix.elements[13] = 0;vpMatrix.elements[14] = 0;// 禁止写入深度缓存，造成背景在很远的假象gl.depthMask(false); 环境纹理映射环境贴图还有个更通俗的叫法-天空盒。接着我们还要实现一个非常帅气的效果，在天空盒三维场景中，让其中的物体反射场景周围的着色。这个操作就叫做环境纹理映射（environment mapping）。 反射如果物体的表面像光滑的镜子，那么我们就能看到物体反射出天空和周围的景色。反射的原理非常简单，那就是使用反射公式映射纹理盒对应的纹素： 相机位置(观察点)和 物体顶点的位置，顶点位置又包含着法线信息，通过GLSL的reflect函数就可以非常容易的计算反射向量R，进而确定看到的是哪一块表面的着色。 实现我们就在天空盒下面增加一个镜面立方体，那就需要增加一对着色器，首先顶点着色器需要增加法线，mvp矩阵 attribute vec4 a_position;attribute vec4 a_normal;uniform mat4 u_vpMatrix;uniform mat4 u_modelMatrix;varying vec3 v_position;varying vec3 v_normal;void main() &#123; v_position = (u_modelMatrix * a_position).xyz; v_normal = vec3(u_modelMatrix * a_normal); gl_Position = u_vpMatrix * u_modelMatrix * a_position;&#125; 片元着色器则需要添加相机位置，纹理以及顶点着色器传递过来的法线和顶点位置 precision highp float;varying vec3 v_position;varying vec3 v_normal;uniform samplerCube u_texture;uniform vec3 u_viewPosition;void main() &#123; vec3 normal = normalize(v_normal); vec3 eyeToSurfaceDir = normalize(v_position - u_viewPosition); vec3 direction = reflect(eyeToSurfaceDir,normal); gl_FragColor = textureCube(u_texture, direction);&#125; 这样我们绘制的时候就要轮流切换着色器program function draw()&#123; gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //天空盒 gl.useProgram(program.program); //绘制天空盒 //... //立方体 gl.useProgram(cProgram.program); //绘制立方体 //... requestAnimationFrame(draw);&#125; 最后实现如下效果，demo情况 天空盒 后记其实纹理盒除了可以做环境贴图，还可以结合光照，阴影贴图作出很多酷炫的效果。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL半透明物体的绘制","date":"2019-05-02T05:16:29.000Z","path":"2019/05/02/webglalpha/","text":"WebGL 中当透明和半透明物体共存时，相关设置不正确的话，物体表面会出现破碎杂乱的断面，非常影响效果，我们接着就来解决这个问题。完成的展示Demo请看: 半透明物体和透明物体共存 α 混合让物体实现半透明效果需要用到颜色的α分量。该功能被称为a混合(alpha blending) 或 混合 blending，WebGL已经内置该功能，但需要开启，如果只设置了颜色的第四个分量 α 是看不到透明效果的，这第四分量α其实和 css 样式的 rgba / hsla 颜色模式 中的 α 是一样的，或者类似 opacity 属性。必须要执行下面两个步骤才能看到透明效果: 开启混合功能：gl.enable(gl.BLEND)。 指定混合函数：gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)。 gl.blendFunc(src_factor, dst_factor)a混合函数，指定如如何混合两者的颜色，权重因子的类型多种多样，参数： src_factor: 指定源颜色在混合颜色的权重因子，如下表所示 dst_factor: 指定目标颜色在混合后颜色的权重因子，如下表所示 // 混合颜色计算公式： &lt;混合后的颜色&gt; = &lt;源颜色&gt; * src_factor + &lt;目标颜色&gt; * dst_factor// 一般半透明效果常用如下形式gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA) 权重因子列表(Rs,Gs,Bs,As) 表示源颜色各分量， (Rd,Gd,Bd,Ad) 表示目标颜色的各分量 常量 R分量的系数 G分量的系数 B分量的系数 gl.ZERO 0.0 0.0 0.0 gl.ONE 1.0 1.0 1.0 gl.SRC_COLOR Rs Gs Bs gl.ONE_MINUS_SRC_COLOR 1-Rs 1-Gs 1-Bs gl.DST_COLOR Rd Gd Bd gl.ONE_MINUS_DST_COLOR 1-Rd 1-Gd 1-Bd gl.SRC_ALPHA As As As gl.ONE_MINUS_SRC_ALPHA 1-As 1-As 1-As gl.DST_ALPHA Ad Ad Ad gl.ONE_MINUS_DST_ALPHA 1-Ad 1-Ad 1-Ad gl.SRC_ALPHA_SATUREATE min(As,Ad) min(As,Ad) min(As,Ad) 透明和不透明物体共存实现 a 混合最简单的方式是屏蔽掉隐藏面消除功能，即去掉 gl.enable(gl.DEPTH_TEST)，但关闭隐藏面消除功能是一个粗暴的解决方案，并不能满足实际需求。其实可通过某些机制，同时实现隐藏面消除和半透明效果，步骤如下： //1.开启隐藏面消除功能:gl.enable(gl.DEPTH_TEST)。//2.绘制所有不透明的物体(a == 1.0)//3.锁定深度缓冲区的写入操作，使之只读 (深度缓冲区用于隐藏面消除):gl.depthMask(false);//4.绘制所有半透明的物体 a &lt; 1.0，注意将物体按深度排序，a 最小最先绘制//5.释放深度缓冲区，使之可读可写: gl.depthMask(true) gl.depthMask(mask)锁定或释放深度缓冲区的写入操作 mask: 锁定深度缓冲区的写入操作 false，释放 true 实现效果我们写个Demo来实际演示效果，比如我要绘制8个物体，其中前面4个是非透明的物体，即 α 分量值则为1，剩余物体的 α 分量分别从 0.1至0.4不等。 for (var i = 0; i &lt; 8; i++) &#123; let color = randomColor(); color[3] = i &gt; 3 ? (i - 3)/10 :1;// 透明物体 α 分量小于1，非透明物体则等于1 Polygons.push(&#123; x: random(-9,9), y: random(0, 6), z: random(-5,5), color: color &#125;);&#125; 如果是绘制的物体队列是无序的，则必须手动排序。但我这里建立图形时已经排好序，前4个为不透明物体，剩余是透明物体，所以可直接按顺序绘制，针对是否为透明物体，分别设置缓冲区写入和隐藏面删除功能。 if(i &lt; 4)&#123; // 非透明物体 gl.depthMask(true); gl.disable(gl.BLEND);&#125; else &#123; //透明物体 gl.depthMask(false); gl.enable(gl.BLEND); gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );&#125;drawBufferInfo(gl, vao); 最终完成效果请看：半透明物体和透明物体共存","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL学习之法线贴图","date":"2019-04-30T03:07:27.000Z","path":"2019/04/30/webglnormap/","text":"实际效果请看demo：纹理贴图 为了增加额外细节，提升真实感，我们使用了漫反射贴图和高光贴图，它们都是向三角形进行附加纹理。但是从光的视角来看是表面法线向量使表面被视为平坦光滑的表面。以光照算法的视角考虑的话，只有一件事决定物体的形状，那就是垂直于它的法线向量。砖块表面只有一个法向量，表面完全根据这个法向量被以一致的方式照亮。如果每个片元都用不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉： 每个片元使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个片元使用各自的法线，替代一个面上所有片元使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。 以上都是从 LearnOpenGL CN 相关的文章摘抄 法线贴图。没办法，WebGL相关比较深入的知识你只能去看openGL，好在原理基本相同，WebGL1就是基于openGL es 2.0，WebGL2就是基于openGL es 3.0。 法线贴图法线贴图就是用纹理中的颜色向量r、g、b存储法线向量的x、y、z。不过它们有另外的称呼：t (切线)、b (副切线)、n (法线)，它们组成了一个切线空间，被称为TBN坐标系。由于颜色与方向的表示范围有区别，颜色范围是[0,1]，而作为表示位置方向的TBN坐标系则是[-1,1]，那么从法线贴图取出来的值要使用的话，得进行转换。 // 将法线向量转换为范围[-1,1]vec3 normal = normalize(normal * 2.0 - 1.0); 法线贴图偏蓝是因为所有法线的指向都偏向z轴（0, 0, 1）， 对应于rgb 中的 blue分量，也就是蓝色。法线向量从z轴方向向其他方向轻微偏移，于是颜色也就发生轻微变化，这样看起来便有了一种深度。例如，你可以看到顶部颜色倾向于偏绿，这是因为顶部的法线偏向于指向正y轴方向（0, 1, 0）对应于rgb总的 green分量，也就是绿色。 法线贴图的优点是可以用一个低精度模型表现出非常高的细节，看起来像高精度模型那样。 只需要500个三角形的简单网格加上法线贴图就能达到媲美4M个三角形的精细网格模型的效果，可以说法线贴图优势巨大，处理4M个三角形的复杂度简直不可想象。 但法线贴图也不是万能的，它也有缺点。因为它只是改变了物体表面的光照计算方式，所以不适合用在凹凸起伏较大的物体上，这些物体会有遮挡的效果，法线贴图是无法实现的。 而文章 法线贴图 里面有很详细的原理讲解和切线推导过程，最后求出如下的公式，我这里也不再叙述了。 着色器我这里使用了另外一种更加方便的算法，能达到同样的效果，原理就是使用导数(dFdx/dFdy)求出每个像素在插值化传值过来的点的变化率当成一个法线，请看函数 dHdxy_fwd。然后再通过与当前平面的法向量进行叉积 (cross)，即可求得同时垂直于这两个方向的法向量，请看函数 perturbNormalArb，而最终的这个法向量就是我们所要求的值，非常地高明。下面是glsl 内置的几个关键函数。 dFdx(p) //在x方向的偏导数dFdy(p) //在y方向的偏导数cross(p0,p1) //向量p0,p1的叉乘 我们用到的求导函数 dFdx / dFdy，在WebGL1是需要开启扩展的，顶点着色器无需变动，主要变动的是片元着色器。具体的计算过程，请看如下片元着色器代码： #extension GL_OES_standard_derivatives : enable// 注意要开启该扩展//...uniform sampler2D u_diffMap;uniform sampler2D u_specMap;uniform sampler2D u_normMap;//...vec2 dHdxy_fwd() &#123; vec2 dSTdx = dFdx( v_texcoord ); vec2 dSTdy = dFdy( v_texcoord ); float Hll = bumpScale * texture2D( u_normMap, v_texcoord ).x; float dBx = bumpScale * texture2D( u_normMap, v_texcoord + dSTdx ).x - Hll; float dBy = bumpScale * texture2D( u_normMap, v_texcoord + dSTdy ).x - Hll; return vec2( dBx, dBy );&#125;vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) &#123; vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) ); vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) ); vec3 vN = surf_norm; vec3 R1 = cross( vSigmaY, vN ); vec3 R2 = cross( vN, vSigmaX ); float fDet = dot( vSigmaX, R1 ); fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 ); vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 ); return normalize( abs( fDet ) * surf_norm - vGrad );&#125;//...// 从法线贴图计算出逐像素法线向量vec3 normal = perturbNormalArb( -v_position, normal, dHdxy_fwd());//...// 总的光照gl_FragColor = vec4(ambient + diffuse + specular, diffuseColor.a); 最后效果请看demo：纹理贴图 后记相关资料 LearnOpenGL CN","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL学习之纹理贴图","date":"2019-04-29T03:24:21.000Z","path":"2019/04/29/webgltexture/","text":"为了使图形能获得接近于真实物体的材质效果，一般会使用贴图，贴图类型主要包括两种：漫反射贴图和镜面高光贴图。其中漫反射贴图可以同时实现漫反射光和环境光的效果。实际效果请看demo：纹理贴图 2D纹理实现贴图就需要用到纹理，常用的纹理格式有：2D纹理，立方体纹理，3D纹理。我们使用最基本的2D纹理就能实现本节需要的效果，我们来看一下使用纹理需要的api。 因为纹理的坐标原点位于左下角，和我们通常的左上角坐标原点刚好相反，下面就是将它按Y轴进行反转，方便我们设置坐标。 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); 激活和绑定纹理，gl.TEXTURE0 表示0号纹理，可以从0一直往上递增。TEXTURE_2D 则是表示2D纹理。 gl.activeTexture(gl.TEXTURE0);//激活纹理gl.bindTexture(gl.TEXTURE_2D, texture);//绑定纹理 接着就是设置纹理参数，这个api非常重要，也是纹理最复杂的部分。 gl.texParameteri(target, pname, param) ，将param的值赋给绑定到目标的纹理对象的pname参数上。参数： target: gl.TEXTURE_2D 或 gl.TEXTURE_CUBE_MAP pname: 可指定4个纹理参数 放大（gl.TEXTURE_MAP_FILTER）:当纹理的绘制范围比纹理本身更大时，如何获取纹理颜色。比如，将16*16的纹理图像映射到32*32像素的空间时，纹理的尺寸变为原始的两倍。默认值为gl.LINEAR。 缩小（gl.TEXTURE_MIN_FILTER）: 当纹理的绘制返回比纹理本身更小时，如何获取纹素颜色。比如，将32*32的纹理图像映射到16*16像素空间里，纹理的尺寸就只有原始的一般。默认值为gl.NEAREST_MIPMAP_LINEAR。 水平填充（gl.TEXTURE_WRAP_S）: 表示如何对纹理图像左侧或右侧区域进行填充。默认值为gl.REPEAT。 垂直填充（gl.TEXTURE_WRAP_T）: 表示如何对纹理图像上方和下方的区域进行填充。默认值为gl.REPEAT。 param: 纹理参数的值 可赋给 gl.TEXTURE_MAP_FILTER 和 gl.TEXTURE_MIN_FILTER 参数的值 gl.NEAREST: 使用原纹理上距离映射后像素中心最近的那个像素的颜色值，作为新像素的值。 gl.LINEAR: 使用距离新像素中心最近的四个像素的颜色值的加权平均，作为新像素的值（和gl.NEAREST相比，该方法图像质量更好，但也会有较大的开销。） 可赋给 gl.TEXTURE_WRAP_S 和 gl.TEXTURE_WRAP_T 的常量： gl.REPEAT: 平铺式的重复纹理 gl.MIRRORED_REPEAT: 镜像对称的重复纹理 gl.CLAMP_TO_EDGE: 使用纹理图像边缘值 设置样例如下所示： gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texImage2D，将 pixels 指定给绑定的纹理对象，这个api在 WebGL1 和 WebGL2 中的重载函数多达十几个，格式类型非常多样。pixels参数既可以是图像，canvas，也可以是视频，我们只看 WebGL1中的调用形式。 // WebGL1:void gl.texImage2D(target, level, internalformat, width, height, border, format, type, ArrayBufferView? pixels);void gl.texImage2D(target, level, internalformat, format, type, ImageData? pixels);void gl.texImage2D(target, level, internalformat, format, type, HTMLImageElement? pixels);void gl.texImage2D(target, level, internalformat, format, type, HTMLCanvasElement? pixels);void gl.texImage2D(target, level, internalformat, format, type, HTMLVideoElement? pixels);void gl.texImage2D(target, level, internalformat, format, type, ImageBitmap? pixels);// WebGL2://... 我封装出了一个纹理加载函数，每个api的调用格式可以查看资料，还是先实现我们想要的效果吧。 function loadTexture(url) &#123; const texture = gl.createTexture(); gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); let textureInfo = &#123; width: 1, height: 1, texture: texture, &#125;; const img = new Image(); return new Promise((resolve,reject) =&gt; &#123; img.onload = function() &#123; textureInfo.width = img.width; textureInfo.height = img.height; gl.bindTexture(gl.TEXTURE_2D, textureInfo.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img); resolve(textureInfo); &#125;; img.src = url; &#125;);&#125; 漫反射贴图首先实现漫反射光贴图，从网上下载了个地板的贴图，里面包含了各种类型的贴图。 缓冲区要增加顶点对应的纹理坐标，这样才能通过纹理坐标找到对应的纹理像素，简称纹素。 const arrays = &#123; position: [ -1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, 1 ], texcoord: [ 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0 ], normal: [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ],&#125;; 顶点着色器唯一区别是增加了纹理坐标，需要插值传入片元着色器 //...attribute vec2 a_texcoord;varying vec2 v_texcoord;void main() &#123; //... v_texcoord = a_texcoord;&#125; 片元着色器修改的多一些。主要是使用 texture2D 获取对应坐标下的纹素，代替之前的颜色就可以了。下面就是片元着色器相关代码 //...vec3 normal = normalize(v_normal);vec4 diffMap = texture2D(u_samplerD, v_texcoord);//光线方向vec3 lightDirection = normalize(u_lightPosition - v_position);// 计算光线方向和法向量夹角float nDotL = max(dot(lightDirection, normal), 0.0);// 漫反射光亮度vec3 diffuse = u_diffuseColor * nDotL * diffMap.rgb;// 环境光亮度vec3 ambient = u_ambientColor * diffMap.rgb;//... js部分加载贴图对应的图片，传递纹理单元，然后渲染 //...(async function ()&#123; const ret = await loadTexture('/model/floor_tiles_06_diff_1k.jpg') setUniforms(program, &#123; u_samplerD: 0//0号纹理 &#125;); //... draw();&#125;)() 效果如下，镜面高光部分似乎太刺眼了，因为地板是不会有镜子一样光滑强烈的反光的。 镜面高光贴图为了实现更逼真的高光效果，继续实现高光贴图，实现原理和漫反射一样，把对应的高光颜色替换成高光贴图纹素就可以了。下面就是片元着色器增加修改高光部分 //...vec3 normal = normalize(v_normal);vec4 diffMap = texture2D(u_samplerD, v_texcoord);vec4 specMap = texture2D(u_samplerS, v_texcoord);//光线方向vec3 lightDirection = normalize(u_lightPosition - v_position);// 计算光线方向和法向量夹角float nDotL = max(dot(lightDirection, normal), 0.0);// 漫反射光亮度vec3 diffuse = u_diffuseColor * nDotL * diffMap.rgb;// 环境光亮度vec3 ambient = u_ambientColor * diffMap.rgb;// 镜面高光vec3 eyeDirection = normalize(u_viewPosition - v_position);// 反射方向vec3 halfwayDir = normalize(lightDirection + eyeDirection);float specularIntensity = pow(max(dot(normal, halfwayDir), 0.0), u_shininess);vec3 specular = (vec3(0.2,0.2,0.2) + specMap.rgb) * specularIntensity;//... js同时加载漫反射和高光贴图 //...(async function ()&#123; const ret = await Promise.all([ loadTexture('/model/floor_tiles_06_diff_1k.jpg'), loadTexture('/model/floor_tiles_06_spec_1k.jpg',1) ]); setUniforms(program, &#123; u_samplerD: 0,//0号纹理 u_samplerS: 1 //1号纹理 &#125;); //... draw();&#125;)() 最后实现的效果如下，明显更加接近真实的地板 后记纹理贴图其实包括了很多高级应用，接着我们还将继续深入探索，下一节是法线贴图。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"如何将markdown转换为wxml","date":"2019-04-27T02:36:23.000Z","path":"2019/04/27/mdtowxml/","text":"话说我要为技术博客写一个小程序版，我的博客解决方案是 hexo + github-page，格式当然是技术控们喜欢的 markdown 了 。但小程序使用的却是独有的模版语言 WXML。我总不能把之前的文章手动转换成小程序的 wxml 格式吧，而网上也没完善的转换库，还是自己写个解析器吧。 解析器最核心的部分就是字符串模式匹配，既然涉及到字符串匹配，那么就离不开正则表达式。幸好，正则表达式是我的优势之一。 正则表达式JavaScript中的正则表达式解析器涉及到的 JavaScript 正则表达式知识 RegExp 构造函数属性，其中lastMatch，rightContent在字符串截取时非常有用 长属性名 短属性名 替换标志 说明 input $_ 最近一次要匹配的字符串。Opera未实现此属性 lastMatch $&amp; $&amp; 最近一次的匹配项。Opera未实现此属性 lastParen $+ 最近一次匹配的捕获组。Opera未实现此属性 leftContext $` $` input字符串中lastMatch之前的文本 rightContext $’ $’ Input字符串中lastMatch之后的文本 multiline $* 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性 $n $n 分组 $$ 转义$ test 方法 和 RegExp 构造函数test 方法调用后，上面的属性就会出现在 RegExp 中，不推荐使用短属性名，因为会造成代码可读性的问题，下面就是样例 var text = \"this has been a short summer\";var pattern = /(.)hort/g;if (pattern.test(text))&#123; alert(RegExp.input); // this has been a short summer alert(RegExp.leftContext); // this has been a alert(RegExp.rightContext); // summer alert(RegExp.lastMatch); // short alert(RegExp.lastParen); // s alert(RegExp.multiline); // false&#125;//长属性名都可以用相应的短属性名来代替。不过由于这些短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们if (pattern.test(text))&#123; alert(RegExp.$_); alert(RegExp[\"$`\"]); alert(RegExp[\"$'\"]); alert(RegExp[\"$&amp;\"]); alert(RegExp[\"$+\"]); alert(RegExp[\"$*\"]);&#125; replace 方法 一般使用的是没有回调函数的简单版本，而回调函数版本则是个大杀器，及其强大 //简单替换, replace默认只进行一次替换, 如设定全局模式, 将会对符合条件的子字符串进行多次替换，最后返回经过多次替换的结果字符串.var regex = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;\"2011-11-11\".replace(regex, \"$2/$3/$1\");//replace 使用回调函数自定义替换，必须启用全局模式g，因为要不断向前匹配，直到匹配完整个字符串//match为当前匹配到的字符串，index为当前匹配结果在字符串中的位置，sourceStr表示原字符串，//如果有分组，则中间多了匹配到的分组内容，match,group1(分组1)...groupN(分组n),index,sourceStr\"one two three\".replace(/\\bt[a-zA-Z]+\\b/g, function (match,index,str) &#123; //将非开头的单词大写 console.log(match,index,str); return match.toUpperCase(); &#125;); match 方法 全局模式和非全局模式有显著的区别，全局模式和 exec 方法类似。 // 如果参数中传入的是子字符串或是没有进行全局匹配的正则表达式，那么match()方法会从开始位置执行一次匹配，如果没有匹配到结果，则返回null.否则则会返回一个数组,该数组的第0个元素存放的是匹配文本，返回的数组还含有两个对象属性index和input，分别表示匹配文本的起始字符索引和原字符串，还有分组属性var str = '1a2b3c4d5e';console.log(str.match(/b/)); //返回[\"b\", index: 3, input: \"1a2b3c4d5e\"]//如果参数传入的是具有全局匹配的正则表达式，那么match()从开始位置进行多次匹配，直到最后.如果没有匹配到结果，则返回null.否则则会返回一个数组，数组中存放所有符合要求的子字符串，但没有index和input属性,也没有分组属性var str = '1a2b3c4d5e';str.match(/h/g); //返回nullstr.match(/\\d/g); //返回[\"1\", \"2\", \"3\", \"4\", \"5\"]var pattern = /\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;/g;var str =\"2010-11-10 2012-12-12\";var matchArray = str.match(pattern);for(vari = 0; i &lt; matchArray.length; i++) &#123; console.log(matchArray[i]);&#125; exec 方法 与全局模式下的 match 类似，但 exec 更强大，因为返回结果包含各种匹配信息，而match全局模式是不包含具体匹配信息的。 //逐步提取,捕获分组匹配文本,必须使用全局模式g, 成功则返回数组(包含匹配的分组信息), 否则为null//Regex每次匹配成功后,会把匹配结束位置更新到lastIndex,下次从lastIndex开始匹配//如果不指定全局模式,使用while循环,会造成无穷循环var pattern = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g;var str2 = \"2011-11-11 2013-13-13\" ;while ((matchArray = pattern.exec(str2)) != null) &#123; console.log( \"date: \" + matchArray[0]+\"start at:\" + matchArray.index+\" ends at:\"+ pattern.lastIndex); console.log( \",year: \" + matchArray[1]); console.log( \",month: \" + matchArray[2]); console.log( \",day: \" + matchArray[3]);&#125; search，split 这两个比较简单的方法则不再介绍 正则表达式高级概念正常情况下正则是从左向右进行单字符匹配，每匹配到一个字符, 就后移位置, 直到最终消耗完整个字符串， 这就是正则表达式的字符串匹配过程，也就是它会匹配字符，占用字符。相关的基本概念不再讲解，这里要讲的和字符匹配不同的概念 - 断言。 断言 正则中大多数结构都是匹配字符，而断言则不同，它不匹配字符，不占用字符，而只在某个位置判断左/右侧的文本是否符合要求。这类匹配位置的元素，可以称为 “锚点”，主要分为三类：单词边界，开始结束位置，环视。 单词边界 \\b 是这样的位置，一边是单词字符，一边不是单词字符，如下字符串样例所示 \\brow\\b //row\\brow //row， rowdyrow\\b //row， tomorow ^ 行开头，多行模式下亦匹配每个换行符后的位置，即行首 $ 行结束，多行模式下亦匹配每个换行符前的位置，即行尾 //js 中的 $ 只能匹配字符串的结束位置，不会匹配末尾换行符之前的换行符。但开启多行模式(m)后，^ 和 $ 则可以匹配中间的换行符。 如下例子可验证：// 默认全局模式下，^ 和 $ 直接匹配到了文本最开头和末尾，忽略了中间的换行符'hello\\nword'.replace(/^|$/g,'&lt;p&gt;')\"&lt;p&gt;hello\"+\"word&lt;p&gt;\"// 多行模式下，同时能匹配到结束符中间的换行符'hello\\nword\\nhi'.replace(/^|$/mg,'&lt;p&gt;')\"&lt;p&gt;hello&lt;p&gt;\"+\"&lt;p&gt;word&lt;p&gt;\"+\"&lt;p&gt;hi&lt;p&gt;\" 环视 环视是断言中最强的存在，同样不占用字符也不提取任何字符，只匹配文本中的特定位置，与\\b, ^ $ 边界符号相似；但环视更加强大，因为它可以指定位置和在指定位置处添加向前或向后验证的条件。 而环视主要体现在它的不占位（不消耗匹配字符）, 因此又被称为零宽断言。所谓不占宽度，可以这样理解： 环视的匹配结果不纳入数据结果； 环视它匹配过的地方，下次还能用它继续匹配。 环视包括顺序环视和逆序环视，javascript 在 ES 2018 才开始支持逆序环视 (?=) 顺序肯定环视 匹配右边 (?!) 顺序否定环视 (?&lt;=) 逆序肯定环视 匹配左边 (?&lt;!) 逆序否定环视 来看一下具体的样例 // 获取.exe后缀的文件名，不使用分组捕获，能使捕获结果不包含.exe后缀，充分利用了环视匹配结果同时不占位的特性'asd.exe'.match(/.+(?=\\.exe)/)=&gt; [\"asd\", index: 0, input: \"asd.exe\", groups: undefined]// 变种否定顺序环视，排除特定标签p/a/img，匹配html标签&lt;/?(?!p|a|img)([^&gt; /]+)[^&gt;]*/?&gt; //常规逆序环视，同样利用了环视匹配不占位的特性/(?&lt;=\\$)\\d+/.exec('Benjamin Franklin is on the $100 bill') // [\"100\",index: 29,...]/(?&lt;!\\$)\\d+/.exec('it’s is worth about €90') // [\"90\", index: 21,...] // 利用环视占位但不匹配的特性'12345678'.replace(/\\B(?=(\\d&#123;3&#125;)+$)/g , ',') =&gt; \"12,345,678\" //分割数字 解析器的编写正则表达式相关写得有点多，但磨刀不误砍柴工，开始进入主题 markdown格式hexo 生成的 markdwon 文件格式如下，解析器就是要把它解析成json格式的输出结果，供小程序输出 wxml ---title: Haskell学习-functordate: 2018-08-15 21:27:15tags: [haskell]categories: 技术banner: https://upload-images.jianshu.io/upload_images/127924-be9013350ffc4b88.jpg---&lt;!-- 原文地址：[Haskell学习-functor](https://edwardzhong.github.io/2018/08/15/haskellc/) --&gt;## 什么是Functor**functor** 就是可以执行map操作的对象，functor就像是附加了语义的表达式，可以用盒子进行比喻。**functor** 的定义可以这样理解：给出a映射到b的函数和装了a的盒子，结果会返回装了b的盒子。**fmap** 可以看作是一个接受一个function 和一个 **functor** 的函数，它把function 应用到 **functor** 的每一个元素（映射）。```haskell-- Functor的定义class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b```&lt;!-- more --&gt; 入口使用node进行文件操作，然后调用解析器生成json文件 const &#123; readdirSync, readFileSync, writeFile &#125; = require(\"fs\");const path = require(\"path\");const parse = require(\"./parse\");const files = readdirSync(path.join(__dirname, \"posts\"));for (let p of files) &#123; let md = readFileSync(path.join(__dirname, \"posts\", p)); const objs = parse(md); writeFile(path.join(__dirname, \"json\", p.replace('.md','.json')), JSON.stringify(objs), function( err )&#123; err &amp;&amp; console.log(err); &#125;);&#125; 来看一下解析器入口部分，主要分为：summary 部分，code代码部分，markdown文本部分。将文本内容的注释和空格过滤掉，但是代码部分的注释要保留。 module.exports = function analyze(str) &#123; let ret = &#123; summary: &#123;&#125;, lines: [] &#125;; while (str) &#123; // 空格 if (/^([\\s\\t\\r\\n]+)/.test(str)) &#123; str = RegExp.rightContext; &#125; // summary 内容块 if (/^(\\-&#123;3&#125;)[\\r\\n]?([\\s\\S]+?)\\1[\\r\\n]?/.test(str)) &#123; str = RegExp.rightContext; ret.summary = summaryParse(RegExp.$2); ret.num = new Date(ret.summary.date).getTime(); &#125; // code if (/^`&#123;3&#125;(\\w+)?([\\s\\S]+?)`&#123;3&#125;/.test(str)) &#123; const codeStr = RegExp.$2 || RegExp.$1; const fn = (RegExp.$2 &amp;&amp; codeParse[RegExp.$1]) ? codeParse[RegExp.$1] : codeParse.javascript; str = RegExp.rightContext; ret.lines.push(&#123; type: \"code\", child: fn(codeStr) &#125;); &#125; // 注释行 if (/^&lt;!--[\\s\\S]*?--&gt;/.test(str)) &#123; str = RegExp.rightContext; &#125; // 提取每行字符串, 利用 . 不匹配换行符的特性 if (/^(.+)[\\r\\n]?/.test(str)) &#123; str = RegExp.rightContext; ret.lines.push(textParse(RegExp.$1)); &#125; &#125; return ret;&#125;; 文本内容提取summary 内容块的提取比较简单，不讲叙。还是看 markdown 文本内容的解析吧。这里匹配 markdown 常用类型，比如列表，标题h，链接a，图片img等。而返回结果的数据结构就是一个列表，列表里面可以嵌套子列表。但基本就是正则表达式提取内容，最终消耗完字符行。 function textParse(s) &#123; const trans = /^\\\\(\\S)/; //转义字符 const italy = /^(\\*)(.+?)\\1/; //倾斜 const bold = /^(\\*&#123;2&#125;)(.+?)\\1/; //加粗 const italyBold = /^(\\*&#123;3&#125;)(.+?)\\1/; //倾斜和加粗 const headLine = /^(\\#&#123;1,6&#125;)\\s+/; //h1-6 const unsortList = /^([*\\-+])\\s+/; //无序列表 const sortList = /^(\\d+)\\.\\s+/; //有序列表 const link = /^\\*?\\[(.+)\\]\\(([^()]+)\\)\\*?/; //链接 const img = /^(?:!\\[([^\\]]+)\\]\\(([^)]+)\\)|&lt;img(\\s+)src=\"([^\"]+)\")/; //图片 const text =/^[^\\\\\\s*]+/; //普通文本 if (headLine.test(s)) return &#123; type: \"h\" + RegExp.$1.length, text: RegExp.rightContext &#125;; if (sortList.test(s)) return &#123; type: \"sl\", num: RegExp.$1, child: lineParse(RegExp.rightContext) &#125;; if (unsortList.test(s)) return &#123; type: \"ul\", num: RegExp.$1, child: lineParse(RegExp.rightContext) &#125;; if (img.test(s)) return &#123; type: \"img\", src: RegExp.$2||RegExp.$4, alt: RegExp.$1||RegExp.$3 &#125;; if (link.test(s)) return &#123; type: \"link\", href: RegExp.$2, text: RegExp.$1 &#125;; return &#123; type: \"text\", child: lineParse(s) &#125;; function lineParse(line) &#123; let ws = []; while (line) &#123; if (/^[\\s]+/.test(line)) &#123; ws.push(&#123; type: \"text\", text: \"&amp;nbsp;\" &#125;); line = RegExp.rightContext; &#125; if (trans.test(line)) &#123; ws.push(&#123; type: \"text\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (sortList.test(line)) &#123; return &#123; child: lineParse(RegExp.rightContext) &#125;; &#125; if (unsortList.test(line)) &#123; return &#123; child: lineParse(RegExp.rightContext) &#125;; &#125; if (link.test(line)) &#123; ws.push(&#123; type: \"link\", href: RegExp.$2, text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (italyBold.test(line)) &#123; ws.push(&#123; type: \"italybold\", text: RegExp.$2 &#125;); line = RegExp.rightContext; &#125; if (bold.test(line)) &#123; ws.push(&#123; type: \"bold\", text: RegExp.$2 &#125;); line = RegExp.rightContext; &#125; if (italy.test(line)) &#123; ws.push(&#123; type: \"italy\", text: RegExp.$2 &#125;); line = RegExp.rightContext; &#125; if (text.test(line)) &#123; ws.push(&#123; type: \"text\", text: RegExp.lastMatch &#125;); line = RegExp.rightContext; &#125; &#125; return ws; &#125;&#125; 代码块显示如果只是解析文本内容，还是非常简单的，但是技术博客嘛，代码块是少不了的。为了代码关键字符的颜色显示效果，为了方便阅读，还得继续解析。我博客目前使用到的语言，基本写了对应的解析器，其实有些解析器是可以共用的，比如 style方法不仅可应用到 css 上， 还可以应用到类似的预解析器上比如：scss，less。html也一样可应用到类似的标记语言上。 const codeParse = &#123; haskell(str)&#123;&#125;, javascript(str)&#123;&#125;, html:html, css:style&#125;; 来看一下比较有代表性的 JavaScript 解析器，这里没有使用根据换行符(\\n)将文本内容切割成字符串数组的方式，因为有些类型需要跨行进行联合推断，比如解析块，方法名称判断就是如此。只能将一整块文本用正则表达式慢慢匹配消耗完。最终的结果类似上面的文本匹配结果 - 嵌套列表，类型就是语法关键字，常用内置方法，字符串，数字，特殊符号等。 其实根据这个解析器可以进一步扩展和抽象一下，将它作为类 C 语言族的基本框架。然后只要传递 对应语言的正则表达式规则，就能解析出不同语言的结果出来，比如 C#，java，C++，GO。 javascript(str) &#123; const comReg = /^\\/&#123;2,&#125;.*/; const keyReg = /^(import|from|extends|new|var|let|const|return|if|else|switch|case|break|continue|of|for|in|Array|Object|Number|Boolean|String|RegExp|Date|Error|undefined|null|true|false|this|alert|console)(?=([\\s.,;(]|$))/; const typeReg = /^(window|document|location|sessionStorage|localStorage|Math|this)(?=[,.;\\s])/; const regReg = /^\\/\\S+\\/[gimuys]?/; const sysfunReg = /^(forEach|map|filter|reduce|some|every|splice|slice|split|shift|unshift|push|pop|substr|substring|call|apply|bind|match|exec|test|search|replace)(?=[\\s\\(])/; const funReg = /^(function|class)\\s+(\\w+)(?=[\\s(&#123;])/; const methodReg = /^(\\w+?)\\s*?(\\([^()]*\\)\\s*?&#123;)/; const symbolReg = /^([!&gt;&lt;?|\\^$&amp;~%*/+\\-]+)/; const strReg = /^([`'\"])([^\\1]*?)\\1/; const numReg = /^(\\d+\\.\\d+|\\d+)(?!\\w)/; const parseComment = s =&gt; &#123; const ret = []; const lines = s.split(/[\\r\\n]/g); for (let line of lines) &#123; ret.push(&#123; type: \"comm\", text: line &#125;); &#125; return ret; &#125;; let ret = []; while (str) &#123; if (/^\\s*\\/\\*([\\s\\S]+?)\\*\\//.test(str)) &#123; str = RegExp.rightContext; const coms = parseComment(RegExp.lastMatch); ret = ret.concat(coms); &#125; if (/^(?!\\/\\*).+/.test(str)) &#123; str = RegExp.rightContext; ret.push(&#123; type: \"text\", child:lineParse(RegExp.lastMatch) &#125;); &#125; if(/^[\\r\\n]+/.test(str))&#123; str=RegExp.rightContext; ret.push(&#123;type:'text',text:RegExp.lastMatch&#125;); &#125; &#125; return ret; function lineParse(line) &#123; let ws = []; while (line) &#123; if (/^([\\s\\t\\r\\n]+)/.test(line)) &#123; ws.push(&#123; type: \"text\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (comReg.test(line)) &#123; ws.push(&#123; type: \"comm\", text: line &#125;); break; &#125; if (regReg.test(line)) &#123; ws.push(&#123; type: \"fun\", text: RegExp.lastMatch &#125;); line = RegExp.rightContext; &#125; if (symbolReg.test(line)) &#123; ws.push(&#123; type: \"keyword\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (keyReg.test(line)) &#123; ws.push(&#123; type: \"keyword\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (funReg.test(line)) &#123; ws.push(&#123; type: \"keyword\", text: RegExp.$1 &#125;); ws.push(&#123; type: \"text\", text: \"&amp;nbsp;\" &#125;); ws.push(&#123; type: \"fun\", text: RegExp.$2 &#125;); line = RegExp.rightContext; &#125; if (methodReg.test(line)) &#123; ws.push(&#123; type: \"fun\", text: RegExp.$1 &#125;); ws.push(&#123; type: \"text\", text: \"&amp;nbsp;\" &#125;); ws.push(&#123; type: \"text\", text: RegExp.$2 &#125;); line = RegExp.rightContext; &#125; if (typeReg.test(line)) &#123; ws.push(&#123; type: \"fun\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (sysfunReg.test(line)) &#123; ws.push(&#123; type: \"var\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (strReg.test(line)) &#123; ws.push(&#123; type: \"var\", text: RegExp.$1 + RegExp.$2 + RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (numReg.test(line)) &#123; ws.push(&#123; type: \"var\", text: RegExp.$1 &#125;); line = RegExp.rightContext; &#125; if (/^\\w+/.test(line)) &#123; ws.push(&#123; type: \"text\", text: RegExp.lastMatch &#125;); line = RegExp.rightContext; &#125; if (/^[^`'\"!&gt;&lt;?|\\^$&amp;~%*/+\\-\\w]+/.test(line)) &#123; ws.push(&#123; type: \"text\", text: RegExp.lastMatch &#125;); line = RegExp.rightContext; &#125; &#125; return ws; &#125;&#125; 显示WXML最后只要运行解析器，就能生成 markdown 对应的 json 文件了，然后把json加载到微信小程序的云数据库里面，剩下的显示就交由小程序完成。下面就是使用 taro 编写 jsx 显示部分 &lt;View className='article'&gt; &#123;lines.map(l =&gt; ( &lt;Block&gt; &lt;View className='line'&gt; &#123;l.type.search(\"h\") == 0 &amp;&amp; ( &lt;Text className=&#123;l.type&#125;&gt;&#123;l.text&#125;&lt;/Text&gt; )&#125; &#123;l.type == \"link\" &amp;&amp; ( &lt;Navigator className='link' url=&#123;l.href&#125;&gt; &#123;l.text&#125; &lt;/Navigator&gt; )&#125; &#123;l.type == \"img\" &amp;&amp; ( &lt;Image className='pic' mode='widthFix' src=&#123;l.src&#125; /&gt; )&#125; &#123;l.type == \"sl\" &amp;&amp; ( &lt;Block&gt; &lt;Text decode className='num'&gt; &#123;l.num&#125;.&#123;\" \"&#125; &lt;/Text&gt; &lt;TextChild list=&#123;l.child&#125; /&gt; &lt;/Block&gt; )&#125; &#123;l.type == \"ul\" &amp;&amp; ( &lt;Block&gt; &lt;Text decode className='num'&gt; &#123;\" \"&#125; &amp;bull;&#123;\" \"&#125; &lt;/Text&gt; &lt;TextChild list=&#123;l.child&#125; /&gt; &lt;/Block&gt; )&#125; &#123;l.type == \"text\" &amp;&amp; l.child.length &amp;&amp; ( &lt;TextChild list=&#123;l.child&#125; /&gt; )&#125; &lt;/View&gt; &#123;l.type == \"code\" &amp;&amp; ( &lt;View className='code'&gt; &#123;l.child.map(c =&gt; ( &lt;View className='code-line'&gt; &#123;c.type == 'comm' &amp;&amp; &lt;Text decode className='comm'&gt; &#123;c.text&#125; &lt;/Text&gt;&#125; &#123;c.type == 'text' &amp;&amp; c.child.map(i =&gt; ( &lt;Block&gt; &#123;i.type == \"comm\" &amp;&amp; ( &lt;Text decode className='comm'&gt; &#123;i.text&#125; &lt;/Text&gt; )&#125; &#123;i.type == \"keyword\" &amp;&amp; ( &lt;Text decode className='keyword'&gt; &#123;i.text&#125; &lt;/Text&gt; )&#125; &#123;i.type == \"var\" &amp;&amp; ( &lt;Text decode className='var'&gt; &#123;i.text&#125; &lt;/Text&gt; )&#125; &#123;i.type == \"fun\" &amp;&amp; ( &lt;Text decode className='fun'&gt; &#123;i.text&#125; &lt;/Text&gt; )&#125; &#123;i.type == \"text\" &amp;&amp; ( &lt;Text decode className='text'&gt; &#123;i.text&#125; &lt;/Text&gt; )&#125; &lt;/Block&gt; ))&#125; &lt;/View&gt; ))&#125; &lt;/View&gt; )&#125; &lt;/Block&gt; ))&#125;&lt;/View&gt; 后记经过这个项目的磨练，我的正则表达式的能力又上了一个台阶， 连 环视 都已经是信手拈来了😄 小程序预览","tags":[{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"wxml","slug":"wxml","permalink":"https://edwardzhong.github.io/tags/wxml/"},{"name":"markdown","slug":"markdown","permalink":"https://edwardzhong.github.io/tags/markdown/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://edwardzhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"小试小程序云开发","date":"2019-04-26T02:13:20.000Z","path":"2019/04/26/weappcloud/","text":"微信小程序刚出没多久时，曾经上手写过demo，但开发体验比较差，所以一直没怎么关注。不过自从诸多适配方案出炉，以及云端的开通，觉得还是有必要上手体验一番的，于是为我的技术博客也写了个小程序版。 原生开发我是不想再试了，那就选一种适配方案，目前比较知名的有基于vue的 mpvue，umi-app，基于react 的 taro，以及TX团队出的全新框架 wepy。个人对 react 的好感 以及 taro 框架的走向成熟，促使我选择了 taro。 云端开发就是将普通小程序的传统后端切换为微信提供的 轻量级云端。而这个云端服务部分的开发其实是针对前端开发的，前端工程师很容易就能全栈开发出一整个小程序。但是这种轻量级解决方案也只是针对业务简单的项目，因为公共平台肯定有各种限制，它的出现只是让我们多了一个选择方案而已。 接着进入主题，项目大体目录结构如下 client #前端目录├── config #配置├── dist #输出├── src #源目录└── index.html #入口文件cloud #云目录├── dao #数据库操作函数集合├── login #登录云函数└── ... #其他 前端小程序的前端部分，想必不用过多讲解，因为这都是前端的基本功。就以首页为样例，使用了typeScript，主要功能是分页加载数据，调用微信提供的触发到达底部的api-onReachBottom即可。 taro 相关部分的使用请看 taro import Taro, &#123; Component, Config &#125; from \"@tarojs/taro\";import &#123; View, Text, Navigator &#125; from \"@tarojs/components\";import \"./index.scss\";interface IState &#123; loading: boolean; size: number; page: number; total: number; list: Array&lt;&#123; _id: string; summary: object &#125;&gt;; context:object;&#125;export default class Index extends Component&lt;&#123;&#125;, IState&gt; &#123; state = &#123; loading: false, size: 10, page: 0, total: -1, list: [], context:&#123;&#125; &#125;; config: Config = &#123; navigationBarTitleText: \"Jeff's Blog\", onReachBottomDistance: 50 &#125;; componentWillMount() &#123; this.getList(); this.getLogin(); &#125; getDbFn(fn, param) &#123; return Taro.cloud.callFunction(&#123; name: \"dao\", data: &#123; fn, param &#125; &#125;); &#125; onReachBottom() &#123; this.getList(); &#125; getList() &#123; const &#123; size, page, total, loading &#125; = this.state; if (total &gt;= 0 &amp;&amp; size * page &gt;= total) return; if (loading) return; Taro.showLoading(&#123; title: 'loading', &#125;); this.setState(&#123; loading: true &#125;); this.getDbFn(\"getList\", &#123; size, page: page + 1 &#125;).then(res =&gt; &#123; Taro.hideLoading(); const total = res.result.total; const list = this.state.list.concat(res.result.list); this.setState(&#123; loading: false, page: page + 1, total, list &#125;); &#125;).catch(err =&gt; &#123; Taro.hideLoading(); this.setState(&#123; loading: false &#125;); &#125;); &#125; onShareAppMessage (res) &#123; return &#123; title: \"Jeff's Blog\", path: '/pages/index/index' &#125; &#125; render() &#123; return ( &lt;View className='container'&gt; &#123;this.state.list.map(l =&gt; ( &lt;View className='item' key=&#123;l._id&#125;&gt; &lt;Navigator url=&#123;'/pages/post/post?id=' + l._id&#125;&gt; &lt;Image className='banner' mode='widthFix' src=&#123;l.summary.banner&#125; /&gt; &lt;View className='title'&gt;&#123;l.summary.title&#125;&lt;/View&gt; &lt;/Navigator&gt; &lt;View className='sub-title'&gt; &#123;l.summary.tags.map(t =&gt; ( &lt;Navigator className='tag' url=&#123;'/pages/list/list?tag=' + t&#125;&gt; &#123;t&#125; &lt;/Navigator&gt; ))&#125; &lt;Text className='time'&gt;&#123;l.summary.date&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ))&#125; &lt;/View&gt; ); &#125;&#125; 与普通小程序不同的地方就是调用云端，云函数调用如官方样例所示 getLogin()&#123; Taro.cloud.callFunction(&#123; name: \"login\", data: &#123;&#125; &#125;).then(res =&gt; &#123; this.setState(&#123; context: res.result &#125;); &#125;).catch(err=&gt;&#123; &#125;);&#125; 云端云端数据库是个文档型，操作风格与mongodb如出一辙，格式自然是 json。最有用的还是操作数据库的部分，操作方法都已经 Promise 化，调用还是比较方便的。具体内容请查看文档: 小程序云开发 //数据库引用const db = wx.cloud.database()//获取数据集合const todos = db.collection('todos')//获取记录数todos.count();//条件查找todos.where(&#123;done: false,progress: 50&#125;).get()//插入todos.add(&#123;data: &#123;content:'11',time:new Date()&#125;&#125;,success:(res)&#123;&#125;);//更新todos.doc('todo').update(&#123; data: &#123; done: true&#125;&#125;,success:(res)&#123;&#125;);//删除todos.where(&#123;done:true&#125;).remove();//分页查找todos.orderBy('time','desc') .skip(start) .limit(size) .get(); 云函数调用云端的方式就要使用云函数，就以下面数据库操作库为例 // 云函数入口文件const cloud = require(\"wx-server-sdk\");cloud.init();// 云函数入口函数exports.main = async (event, context) =&gt; &#123; const &#123; fn, param &#125; = event; return dao[fn](param);&#125;;// 调用数据库const db = cloud.database();// 表const posts = db.collection(\"posts\");const tags = db.collection(\"tags\");const dao = &#123; async getList(&#123; page = 1, size = 10 &#125;) &#123; const start = (page - 1) * size; try &#123; const &#123; total &#125; = await posts.count(); const &#123; data &#125; = await posts .field(&#123; summary: true &#125;) .orderBy('num','desc') .skip(start) .limit(size) .get(); return &#123; code: 0, list: data, total, message: \"sucess\" &#125;; &#125; catch (err) &#123; return &#123; code: -1, list: [], total: -1, err: err, message: \"error\" &#125;; &#125; &#125;, getPost(&#123; id &#125;) &#123; return posts.doc(id).get(); &#125;, async getTagList(&#123; tag &#125;) &#123; try&#123; const &#123; data &#125; = await tags.where(&#123; name: tag &#125;).get(); if(!data.length)&#123; return &#123; code:0, list:[], message: \"success\" &#125;; &#125; const list = data[0].list.sort((a,b) =&gt; b.num - a.num); return &#123; code:0, list:list, message: \"success\" &#125;; &#125; catch(err)&#123; return &#123; code: -1, list:[], err: err, message: \"error\" &#125;; &#125; &#125;&#125; 将操作数据库的所有云函数合并成一个文件，将云函数入口封装一下，即把函数名字和参数都做为参数 exports.main = async (event, context) =&gt; &#123; const &#123; fn, param &#125; = event; return dao[fn](param);&#125;; 对应前端部分也封装出一个调用数据库的方法 getDbFn(fn, param) &#123; return Taro.cloud.callFunction(&#123; name: \"dao\", data: &#123; fn, param &#125; &#125;);&#125; 云端部分开发完之后，在微信开发者工具里面上传云端代码即可，而其余部分的流程和普通小程序一样，这里也不再介绍。 后记小程序部分的开发还是比较简单的，我开发的大部分时间其实是用在写 markdown 转 wxml 解析器上。下一篇讲解如何将 markdown 转换为 wxml 。","tags":[{"name":"taro","slug":"taro","permalink":"https://edwardzhong.github.io/tags/taro/"},{"name":"小程序","slug":"小程序","permalink":"https://edwardzhong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"koa+mysql+vue+socket.io全栈开发之前端篇","date":"2019-04-13T05:43:45.000Z","path":"2019/04/13/fullstack3/","text":"React 与 Vue 之间的对比，是前端的一大热门话题。 vue 简易上手的脚手架，以及官方提供必备的基础组件，比如 vuex，vue-router，对新手真的比较友好；react 则把这些都交给社区去做，虽然这壮大了 react 的生态链，但新手要弄出一套趁手的方案挺麻烦的，不过好在现在有很多类似 dva 的方案了。 vue 比较讨喜的一点，就是它的数据双向流动在表单开发时特别方便，而 react 在这方面可就麻烦多了。 但是 vue 复杂的 api ，简直让人头大，光是文档说明都几十页了。太多的语法，太多的魔法符号，对进化速度越来越快的前端届来说，就是入手这个框架的最大阻碍。 而相反 react 的 api 数量简直可以忽略不计了，顶多花几小时就能看完官方文档。你只要理解 JavaScript，就能理解 react 的很多行为。react 的很多用法，它的 api 都是符合直觉的，你对它用法的猜测基本都是八九不离十的，这真是大大降低了心智负担。 除此之外，react 的 jsx 语法表达能力更强，还有 hoc 和 hooks 使代码也更容易组织和复用。 虽然我更喜欢 React ，但工作上的需求，还不是要你用什么你就得用什么 😂，所以这个 demo 就当是探索 Vue 的前奏。 之前我还是有用过 vue 的，记得还是 1.0 版本，当时的潮流就是类似 angular 1.x 的 mvvm 方案，数据双向流动。那时的 vue 远没有现在的热度，组件也少，没有 vue-router，没有 vuex，组件之前的通信简直太痛苦了。现在 vue 2.x 比起之前，已经发生了天翻地覆的变化，vue 也在不断向 react 靠拢，而我也只能从头开始学起。 闲话说得有点多，还是赶紧进入主题吧 项目配置选择 webpack 4 打包和管理，template 引擎使用 pug ，css 预编译是 scss。 webpack.common.js 的配置// webpack.common.jsmodule.exports = &#123; entry: './src/main.js', output: &#123; path: resolve(__dirname, 'dist'), filename: '[name]-[hash].js', //输出文件添加hash &#125;, optimization: &#123; // 代替commonchunk, 代码分割 runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all', &#125;, &#125;, &#125;, &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, exclude: /node_modules/, use: ['vue-loader'], &#125;, &#123; test: /\\.js?$/, exclude: /node_modules/, use: ['babel-loader'], //'eslint-loader' &#125;, &#123; test: /\\.pug$/, use: ['pug-plain-loader'], &#125;, &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'], &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'], &#125;, &#123; test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 1000, &#125;, &#125;, ], &#125;, ], &#125;, plugins: [ new VueLoaderPlugin(), new CleanWebpackPlugin([resolve(__dirname, 'dist')]), //生成新文件时，清空生出目录 new HtmlWebpackPlugin(&#123; template: './public/index.html', //模版路径 filename: 'index.html', //生成后的文件名,默认index.html favicon: './public/favicon.ico', minify: &#123; removeAttributeQuotes: true, removeComments: true, collapseWhitespace: true, removeScriptTypeAttributes: true, removeStyleLinkTypeAttributes: true, &#125;, &#125;), new HotModuleReplacementPlugin(), //HMR ],&#125;; webpack.dev.js 的配置就是开发服务器 devServer 的配置，监控代码变更。 // webpack.dev.jsmodule.exports = merge(common, &#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: './dist', index: 'index.html', port: 3002, compress: true, historyApiFallback: true, hot: true, &#125;,&#125;); babel.config.js 的配置module.exports = &#123; presets: [ [ '@vue/app', &#123; useBuiltIns: 'entry', &#125;, ], ],&#125;; 目录结构public #公共目录server #后端目录src #前端目录├── assets #静态文件目录├── common #工具目录├── components #组件目录├── store # vuex store目录├── App.vue # 根组件├── main.js # 入口文件└── router.js #路由 入口和路由路由文件下面使用了嵌套路由，使用的是基于 history 的路由，也可以选择基于 hashchange 的路由。 import Vue from 'vue';import Router from 'vue-router';//...Vue.use(Router);//路由const routes = [ &#123; path: '/', name: 'home', component: Index, &#125;, &#123; path: '/sign', name: 'sign', component: Sign, children: [ //嵌套路由 &#123; path: 'log', name: 'login', component: Login, &#125;, &#123; path: 'reg', name: 'register', component: Register, &#125;, &#123; path: '*', redirect: 'log' &#125;, ], &#125;, &#123; path: '*', redirect: '/' &#125;,];export default new Router(&#123; mode: 'history', routes,&#125;); 入口文件把 router，store 和根组件组合起来 import Vue from 'vue';import App from './App.vue';import router from './router';import store from './store';import '../public/base.min.css';import '../public/fontello.css';Vue.config.productionTip = false;new Vue(&#123; router, store, render: h =&gt; h(App),&#125;).$mount('#app'); 模块的编写模版，逻辑代码，样式合成到一个页面也是我欣赏 vue 的一个方面，因为这样你就不需要在多个文件之间反复的切换。 模版 templatepug 就是之前的 jade，它的简洁在复杂的页面下会让 template 清晰不少，最起码会让你少敲代码，这里以 index 页面的部分代码为例。 &lt;template lang=\"pug\"&gt;div.content div.bar header(v-drag) div.avatar(v-on:click=\"profile(selfInfo)\") img(:src=\"selfInfo.avatar? selfInfo.avatar: aPic.src\") div.name &#123;&#123; selfInfo.nick &#125;&#125; p &#123;&#123; selfInfo.signature&#125;&#125; i.icon-logout(v-on:click=\"logout\") div.body div.main-panel(v-if=\"!isSearch\") nav div(v-on:click=\"showTab(0)\" :class=\"&#123;active:tabIndex==0&#125;\") 好友 div(v-on:click=\"showTab(1)\" :class=\"&#123;active:tabIndex==1&#125;\") 分组 div(v-on:click=\"showTab(2)\" :class=\"&#123;active:tabIndex==2&#125;\") 消息 span(v-if=\"dealCount\") &#123;&#123;dealCount&#125;&#125; ul.friends(v-if=\"tabIndex == 0\") li(v-for=\"item in friends\" :key=\"item.id\") div.avatar(v-on:click=\"profile(item)\") img(:src=\"item.avatar? item.avatar: aPic.src\") p(v-on:click=\"chatWin(item)\") &#123;&#123;item.nick&#125;&#125; span(v-if=\"item.reads &amp;&amp; item.reads &gt; 0\") (&#123;&#123;item.reads&#125;&#125;) //动态创建组件 component(:is=\"item.component\" v-for=\"(item,i) in wins\" :key=\"item.id\" :info=\"item.info\" :sty=\"item.sty\" :msgs=\"item.msgs\" v-on:close=\"closeWin(i)\" v-on:setZ=\"setZ(i)\")&lt;/template&gt; 动态创建组件上面用到了 vue 的 动态创建组件 的概念，什么意思呢？这个组件在当前页面中是不存在的，需要我们触发之后，才开始创建。比如，当你点击某个按钮，才开始加载创建组件，然后填充到页面中来。下面就是动态组件相关功能的编写。 data() &#123; return &#123; wins: [] //组件列表 &#125;&#125;,methods: &#123; addWin(info, com) &#123; // 添加组件的方法 this.wins.push(&#123; msgs: info.msgs || [], info, sty: &#123; left: l * 30 + 270, top: l * 30 + 30, z: 0 &#125;, component: com &#125;); &#125;&#125;//填充组件component(:is=\"item.component\" v-for=\"(item,i) in wins\" :key=\"item.id\" :info=\"item.info\" :sty=\"item.sty\" :msgs=\"item.msgs\" v-on:close=\"closeWin(i)\" v-on:setZ=\"setZ(i)\") javascript 部分这里就是业务逻辑的部分了，以部分代码为例, 具体的部分参考官方的文档 &lt;script&gt;import &#123; mapState, mapGetters &#125; from \"vuex\";import ChatMsg from \"./ChatMsg.vue\";import Profile from \"./Profile.vue\";import &#123; get, post &#125; from \"../common/request\";export default &#123; name: \"index\", data() &#123; return &#123; tabIndex: 0, wins: [], aPic: &#123; src: require(\"../assets/avatar.jpg\") &#125; &#125;; &#125;, async created() &#123; //... &#125;, computed: &#123; ...mapState([\"selfInfo\"]), ...mapGetters([ \"isLogin\", \"friends\", \"msgs\" ]) &#125;, watch: &#123; isLogin: &#123; //监听登录状态 handler: function(val, old) &#123; //... &#125; // ,immediate: true //进入组件立即执行一次 &#125; &#125;, methods: &#123; addWin(info, com) &#123;&#125;, sendMsg(user,data)&#123;&#125; //... &#125;&#125;&lt;/script&gt; style 部分使用了 vue 默认的 scoped ，当然最完善的方案是 css-module，配置要复杂一些，当然这要看你项目需求。预编译器使用的是 scss，个人认为比较强大和方便。 &lt;style lang=\"scss\" scoped&gt;$blue: hsl(200, 100%, 45%);@mixin nowrap &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.content &#123; height: 100%; width: 1000px; margin: 0 auto; position: relative;&#125;.main-panel &#123; width: 100%;&#125;.search-panel &#123; width: 100%; min-height: 313px; max-height: 513px; li &#123; line-height: 2; &#125;&#125;.bar &#123; position: absolute; top: 30px; width: 250px; background-color: #fff; user-select: none; box-shadow: 0 6px 20px 0 hsla(0, 0%, 0%, 0.19), 0 8px 17px 0 hsla(0, 0%, 0%, 0.2); header &#123; display: flex; align-items: flex-start; align-items: center; background-color: $blue; color: #fff; .avatar &#123; width: 30px; height: 30px; margin: 10px; border: 1px solid $blue; border-radius: 50%; overflow: hidden; cursor: pointer; &amp;:hover &#123; border-color: #fff; &#125; img &#123; width: 100%; height: 100%; &#125; &#125; &#125;&#125;&lt;style&gt; vuex 的使用vuex 相比 react 中的 redux，使用起来也更加简单和方便，尽管相比 redux 可能没有那么 “纯”，但好用就行。 vuex 直接把异步的 action 封装进里面，使用 module 将不同组件的状态区分开来。可以说 vuex 的 store 集中了 项目大部分与 状态相关的业务逻辑，这也是 vue 项目的一大关键点。 storevuex 的 store 和 redux 的 store 一样。 import Vue from 'vue';import Vuex from 'vuex';import &#123; state, mutations &#125; from './mutations';import * as getters from './getters';import * as actions from './actions';import friend from './modules/friend';import msg from './modules/msg';Vue.use(Vuex);export default new Vuex.Store(&#123; actions, getters, state, mutations, modules: &#123; friend, msg, &#125;,&#125;); 全局 state 和 mutationsvuex 中的 state 对应 redux 的 state，mutations 则类似 redux 中的 action，其中 mutations 是同步的。 export const state = &#123; loginInfo: &#123; token &#125;, selfInfo: selfInfo, dialog: &#123; txt: 'content', cancal: false, callback: () =&gt; &#123;&#125;, show: false &#125;,&#125;;export const mutations = &#123; showDialog(state, payload) &#123; state.modal.visible = true; state.dialog = Object.assign(&#123;&#125;, state.dialog, payload); state.dialog.show = true; &#125;, closeDialog(state) &#123; state.modal.visible = false; state.dialog.show = false; &#125;, setLoginInfo(state) &#123; state.loginInfo = &#123; token: localStorage.getItem('token') &#125;; &#125;, setSelfInfo(state, payload) &#123; state.selfInfo = payload; localStorage.setItem('selfInfo', JSON.stringify(payload)); &#125;, logout() &#123; state.loginInfo = &#123;&#125;; state.selfInfo = &#123;&#125;; localStorage.clear(); &#125;,&#125;; 全局 action 和 gettersvuex 的 aciton 就是将异步的动作封装起来。而redux 得通过 redux-saga 之类的中间件才能实现类似的效果。 import &#123; get, post &#125; from '../common/request';export const getInfo = (&#123; commit &#125;) =&gt; &#123; return get('/getinfo') .then(res =&gt; &#123; if (res.code == 0) &#123; commit('setSelfInfo', res.data.user); commit('setFriends', res.data.friends); commit('setGroup', res.data.groups); commit('setMsgs', res.data.msgs); &#125; else if (res.code == 1) &#123; commit('logout'); &#125; else &#123; commit('showDialog', &#123; txt: res.message &#125;); &#125; &#125;) .catch(err =&gt; &#123; commit('showDialog', &#123; txt: err.message &#125;); &#125;);&#125;;export const updateSelf = (&#123; commit &#125;, form) =&gt; &#123; post('/updateinfo', form) .then(res =&gt; &#123; if (res.code == 0) &#123; commit('updateSelfInfo', form); &#125; else if (res.code == 1) &#123; commit('logout'); &#125; else &#123; commit('showDialog', &#123; txt: res.message &#125;); &#125; &#125;) .catch(err =&gt; &#123; commit('showDialog', &#123; txt: err.message &#125;); &#125;);&#125;; getters 可以看成是对 state 中某些字段的封装 export const visible = state =&gt; state.modal.visible;export const isLogin = state =&gt; !!state.loginInfo.token; modules随着项目规模的扩展，拆分和模块化都是一个必然。针对某个子模块而设置的 store，它的结构和根 store 一样，module 的 store 最终会合并到根 store 里面。msg 为例的编写方式如下: import &#123; get, post &#125; from '../../common/request';export default &#123; state: &#123; msgs: [], &#125;, getters: &#123; msgs: state =&gt; state.msgs, dealCount: state =&gt; state.msgs.filter(i =&gt; i.status == 0).length, &#125;, actions: &#123; accept(&#123; commit &#125;, form) &#123; return post('/accept', &#123; id: form.id, friend_id: form.from_id &#125;) .then(res =&gt; &#123; if (res.code == 0) &#123; commit('setMsgState', &#123; id: form.id, status: 1 &#125;); commit('addFriend', Object.assign(&#123;&#125;, form, &#123; id: form.from_id &#125;)); &#125; else &#123; commit('showDialog', &#123; txt: res.message &#125;); &#125; &#125;) .catch(err =&gt; &#123; commit('showDialog', &#123; txt: err.message &#125;); &#125;); &#125;, reject(&#123; commit &#125;, form) &#123; post('/reject', &#123; id: form.id &#125;) .then(res =&gt; &#123; if (res.code == 0) &#123; form.status = 2; commit('setMsgState', form); &#125; else &#123; commit('showDialog', &#123; txt: res.message &#125;); &#125; &#125;) .catch(err =&gt; &#123; commit('showDialog', &#123; txt: err.message &#125;); &#125;); &#125;, &#125;, mutations: &#123; setMsgs(state, payload) &#123; state.msgs = payload; &#125;, setMsgState(state, payload) &#123; state.msgs.forEach(i =&gt; &#123; if (i.id == payload.id) &#123; i.status = payload.status; &#125; &#125;); &#125;, addMsg(state, payload) &#123; state.msgs.unshift(payload); &#125;, &#125;,&#125;; socket.io 的接入接着将 websocket 使用起来，让我们实现 好友聊天和分组聊天的功能，socket.io 的介绍可以看我之前的文章 _关于 socket.io 的使用_。 客户端首先连接服务端的 socket，然后将自身的用户信息注册到 socket.io 服务，这样服务端才知道你是谁，也才能与其他人实行通信。 async created() &#123;// vue 组件创建时建立socket连接 const token = localStorage.getItem(\"token\") || \"\"; if (!token) &#123; return this.$router.push(\"/sign/log\"); &#125; await this.$store.dispatch(\"getInfo\"); this.socket = io(\"http://localhost:3001?token=\" + token); //注册用户信息后才开始与服务端通信 this.socket.emit(\"sign\", &#123; user: this.selfInfo, rooms &#125;, res =&gt; &#123; // console.log(res); this.$store.commit(\"friendStatus\", res.data); this.socket.on(\"userin\", (map, user) =&gt; &#123; this.$store.commit(\"friendStatus\", map); showTip(user, \"上线了\"); &#125;); this.socket.on(\"userout\", (map, user) =&gt; &#123; this.$store.commit(\"friendStatus\", map); showTip(user, \"下线了\"); &#125;); this.socket.on(\"auth\", data =&gt; &#123; this.$store.commit('showDialog',&#123;txt:data.message&#125;) this.$store.commit(\"logout\"); &#125;); //接收申请好友和组群 this.socket.on(\"apply\", data =&gt; &#123; this.$store.commit(\"addMsg\", data); &#125;); //接收聊天信息 this.socket.on(\"reply\", (user, data) =&gt; &#123; this.sendMsg(user, data); &#125;); //接收群组聊天信息 this.socket.on(\"groupReply\", (info, data) =&gt; &#123; this.sendGroupMsg(info, data); &#125;); &#125;);&#125;,beforeDestroy() &#123; //组件销毁之前，将socket 关闭 this.socket.close();&#125;, 服务端socket.io 对应的服务端部分，逻辑主要包括用户注册，两人聊天，群聊天，当然对应的信息需要保存到数据库。 这里的技巧就是使用变量记录当前所有登录用户的信息。 const auth = require('./auth.js');const &#123; insertMsg, insertToUser &#125; = require('../daos/message');const log = require('../common/logger');let MAP = &#123;&#125;; //用户id和socket idlet LIST = []; //用户信息let ROOMS = []; //房间const currTime = () =&gt; &#123; const d = new Date(), date = `$&#123;d.getFullYear()&#125;-$&#123;d.getMonth()&#125;-$&#123;d.getDate()&#125;`; return ( ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2) + ':' + ('0' + d.getSeconds()).slice(-2) );&#125;;module.exports = io =&gt; &#123; // middleware io.use(auth); //namespace (/) io.on('connection', socket =&gt; &#123; socket.emit('open', &#123; code: 0, handshake: socket.handshake, namespace: '/', message: 'welcome to main channel, please sign', &#125;); //用户注册 socket.on('sign', (&#123; user, rooms &#125;, fn) =&gt; &#123; if (!user.id) &#123; return fn(&#123; code: 2, message: 'id not exist' &#125;); &#125; MAP[user.id] = socket.id; user.socketId = socket.id; LIST.push(user); socket.join(rooms); //加入自己所在的组 socket.emit('userin', MAP, user); socket.broadcast.emit('userin', MAP, user); fn(&#123; code: 0, message: 'sign success', data: MAP, &#125;); &#125;); //两人聊天 socket.on('send', async (uid, msg) =&gt; &#123; const sid = MAP[uid]; //接收用户socket.id const cid = findUid(socket.id); //发送用户id if (sid) &#123; // 好友在线则发送 socket.to(sid).emit('reply', &#123; id: cid, self: false &#125;, &#123; date: currTime(), msg &#125;); &#125; // 给自己也发一份 socket.emit('reply', &#123; id: uid, self: true &#125;, &#123; date: currTime(), msg &#125;); // 保存数据库 try &#123; const ret = await insertMsg(&#123; send_id: cid, receive_id: uid, content: msg &#125;); insertToUser(&#123; user_id: uid, send_id: cid, message_id: ret.insertId, is_read: sid ? 1 : 0 &#125;); &#125; catch (err) &#123; log.error(err); &#125; &#125;); //群组聊天 socket.on('groupSend', async (&#123; gid, user &#125;, msg) =&gt; &#123; //... &#125;); socket.on('acceptFriend', uid =&gt; &#123; //... &#125;); socket.on('sendApply', (uid, data) =&gt; &#123; //... &#125;); socket.on('disconnect', () =&gt; &#123; //... &#125;); &#125;);&#125;; 客户端的启动首先得编写 client.js，将前端服务启动起来，依然还是使用我们高效的 koa 框架。我这里图省事，和之前的服务端所在同一个根目录下，真正项目会将服务端部分和客户端部分 分离到不同目录或不同的服务器的。 const koa = require('koa');const app = new koa();const static = require('koa-static');const compress = require('koa-compress');const router = require('koa-router')();const &#123; clientPort &#125; = require('./server/config/app');const tpl = require('./server/middleware/tpl');const path = require('path');// gzipapp.use( compress(&#123; filter: function(content_type) &#123; return /text|javascript/i.test(content_type); &#125;, threshold: 2048, flush: require('zlib').Z_SYNC_FLUSH, &#125;),);// set static directioryapp.use(static(path.join(__dirname, 'dist'), &#123; index: false &#125;));// simple template engineapp.use( tpl(&#123; path: path.join(__dirname, 'dist'), &#125;),);// add routersrouter .get('/', ctx =&gt; &#123; ctx.render('index.html'); &#125;) .get('/sign/*', ctx =&gt; &#123; ctx.redirect('/'); &#125;);app.use(router.routes()).use(router.allowedMethods());// deal 404app.use(async (ctx, next) =&gt; &#123; ctx.status = 404; ctx.body = &#123; code: 404, message: '404! not found !' &#125;;&#125;);// koa already had event to deal with the error, just rigister itapp.on('error', (err, ctx) =&gt; &#123; ctx.status = 500; ctx.statusText = 'Internal Server Error'; if (ctx.app.env === 'development') &#123; //throw the error to frontEnd when in the develop mode ctx.res.end(err.stack); //finish the response &#125; else &#123; ctx.body = &#123; code: -1, message: 'Server Error' &#125;; &#125;&#125;);if (!module.parent) &#123; app.listen(clientPort); console.log('app server running at: http://localhost:%d', clientPort);&#125; 启动服务端和客户端，我们整个 demo 就能运行，主要实现如下功能点： 主页面的所有的窗口都可以拖动，关闭 可以编辑用户信息，群组信息，每个用户可以新建 3 个群组 可以好友聊天，群组聊天 搜索用户和群组 好友申请和群组申请 在线时，可以获得好友上线下线提醒，实时答复用户申请 离线时，仍然可以给用户和群组留言，下次登录获得提醒 后续接下来可以优化和增强的地方，我想到以下几点： 使用 nuxt 将 vue 进行服务端渲染 ，进一步提高性能 node 部分，使用 pm2 进行部署。 源代码: vue_qq","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://edwardzhong.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://edwardzhong.github.io/tags/vuex/"},{"name":"socket.io","slug":"socket-io","permalink":"https://edwardzhong.github.io/tags/socket-io/"}]},{"title":"koa+mysql+vue+socket.io全栈开发之数据访问篇","date":"2019-04-12T07:34:17.000Z","path":"2019/04/12/fullstack2/","text":"后端搭起大体的框架后，接着涉及到的就是如何将数据持久化的问题，也就是对数据库进行 CURD 操作。 关于数据库方案, mongodb 和 mysql 都使用过，但我选用的是 mysql，原因： 目前为止 mysql 与 mongodb 性能相差不大，尤其是 mysql 8.0 版本，速度非常快，查询数据是 mysql 更快，写数据方面 mongodb 则更胜一筹； mysql 建立 关联数据要更方便些，比如： 一对多，多对多的关系； mysql 作为关系型数据库，数据一致性方面更好，尤其是事务用起来更顺手； 本人对 sql 操作比较得心应手，毕竟大部分项目用得都是 mysql，而 mongodb 在正式些的项目上用的就少了，而且目前关系型数据库也在进化, postgrep 和 mysql 都已经支持 json了。 node-mysqlnode-mysql 是用 sql 语句对 mysql 进行操作的库, 并没有使用 Sequelize 这种 orm。因为我对 sql 熟悉，原生开发效率高。 连接池连接数据库我选用 连接池的方式，这种方式能高效的利用数据库连接 //dbPool.jsconst mysql = require('mysql');const dbconfig = require('../config/db');const log = require('../common/logger');let pool = null;/** * get the connection pool of database * 获取数据库连接池 */exports.getPool = function () &#123; if (!pool) &#123; log.info(\"creating pool\"); pool = mysql.createPool(dbconfig); &#125; return pool;&#125; 数据库配置文件emoji 格式要用 utf8mb4 格式存储，所以这里连接字符集选用 utf8mb4，当然客户端和数据结果集 一样也要设置为 utf8mb4。 module.exports=&#123; host: \"localhost\", port: \"3306\", user: \"root\", password: \"jeff\", database: \"chatdb\", charset : 'utf8mb4',//utf8mb4才能保存emoji multipleStatements: true,// 可同时查询多条语句, 但不能参数化传值 connectionLimit: 100 //连接数量&#125;; Dao的编写基本的代码编写方式如下，每个方法基本都是这么一种流程，获取数据库连接，执行 sql 语句，返回结果，处理异常。 exports.queryInfo = function (params, callback)&#123; pool.query('select ...', params, function (error, result, fields) &#123; if (error) &#123; log(error); callback(false); &#125; else callback(result) &#125;); &#125; exportDao这造成了一大堆重复的样板代码，我们需要封装它，用 JavaScript 高阶函数特性 很容易就能实现，同时加上 Promise，调用时就能方便地用 async await 了，还有日志记录功能也加上。 const pool = require(\"./dbPool\").getPool();const log = require('../common/logger');/** * export named query function */const exportDao = opts =&gt; Object.keys(opts).reduce((next, key) =&gt; &#123; next[key] = (...args) =&gt; new Promise((resolve, reject) =&gt; &#123; if (opts[key]) args.unshift(opts[key]); log.info('====== execute sql ======') log.info(args); pool.query(...args, (err, result, fields) =&gt; &#123;// fields is useless if (err) reject(err) else resolve(result); &#125;); &#125;); return next;&#125;, &#123;&#125;); userDao文件为例，使用 exportDao 直接就能把里面的 key-value 对象输出为 以key 为方法名的dao方法，挂载到 module.exports 下。 const &#123; exportDao &#125; = require('./common');//直接就exports里面的key值对应的方法module.exports = exportDao(&#123; sql: null,// 有些时候需要直接写sql count: 'select count(*) as count from user where ?', getUser: 'select * from user where ?', insert: 'insert into user set ?', update: 'update user set ? where id = ?', delete: 'delete from user where ?'&#125;);/* 最终输出格式module.exports = &#123; sql:() =&gt; &#123;&#125;, count:() =&gt; &#123;&#125;, ...&#125;*/ transaction还有事务 transaction 的功能需要用到，来看一下 node-mysql 官方的例子，层层回调😢，如果每个业务都要这样编写，简直不能忍，我们还是手动封装下事务吧。 // 官方的事务样例pool.getConnection(function(err, connection) &#123; if (err) &#123; throw err; &#125; connection.beginTransaction(function(err) &#123; if (err) &#123; throw err; &#125; connection.query('INSERT INTO posts SET title=?', title, function (error, results, fields) &#123; if (error) &#123; return connection.rollback(function() &#123; throw error; &#125;); &#125; var log = 'Post ' + results.insertId + ' added'; connection.query('INSERT INTO log SET data=?', log, function (error, results, fields) &#123; if (error) &#123; return connection.rollback(function() &#123; throw error; &#125;); &#125; connection.commit(function(err) &#123; if (err) &#123; return connection.rollback(function() &#123; throw err; &#125;); &#125; console.log('success!'); &#125;); &#125;); &#125;); &#125;);&#125;); 下面就是封装好的事务方法，调用参数为数组，数组项既可以是 sql 字符串，也可以是 node-mysql 中的带参数传值的数组，这才是给人用的嘛，心情好多了。推荐还是用 参数化传值，这样可以避免 sql 注入，如果确实要用sql字符串，可以调用 mysql.escape 方法对 参数 进行转换。 //调用封装后的事务const rets = await transaction([ [\"insert into user_group values (?,?)\",[11,11]], [\"insert into user_friend set ? \",&#123;user_id:'12',friend_id:12&#125;], 'select * from user' ]);/** * sql transaction 封装后的事务 * @param &#123;Array&#125; list */const transaction = list =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (!Array.isArray(list) || !list.length) return reject('it needs a Array with sql') pool.getConnection((err, connection) =&gt; &#123; if (err) return reject(err); connection.beginTransaction(err =&gt; &#123; if (err) return reject(err); log.info('============ begin execute transaction ============') let rets = []; return (function dispatch(i) &#123; let args = list[i]; if (!args) &#123;//finally commit connection.commit(err =&gt; &#123; if (err) &#123; connection.rollback(); connection.release(); return reject(err); &#125; log.info('============ success executed transaction ============') connection.release(); resolve(rets); &#125;); &#125; else &#123; log.info(args); args = typeof args == 'string' ? [args] : args; connection.query(...args, (error, ret) =&gt; &#123; if (error) &#123; connection.rollback(); connection.release(); return reject(error); &#125; rets.push(ret); dispatch(i + 1); &#125;); &#125; &#125;)(0); &#125;); &#125;); &#125;)&#125; controller 调用 dao都封装完毕，最后就是调用， 就以apply控制器为例，其中的 apply 方法是普通调用，accept 方法则使用了事务进行处理。 const &#123; stringFormat &#125; = require('../common/util')const &#123; transaction &#125; = require('../daos/common')const applyDao = require('../daos/apply')exports.apply = async function (ctx) &#123; const form = ctx.request.body; const token = await ctx.verify(); const ret = await applyDao.apply(&#123; ...form, from_id: token.uid &#125;); if (!ret.affectedRows) &#123; return ctx.body = &#123; code: 2, message: '申请失败' &#125;; &#125; ctx.body = &#123; code: 0, message: '申请成功', data:ret.insertId &#125;;&#125;exports.accept = async function (ctx) &#123; const &#123; id, friend_id &#125; = ctx.request.body; const token = await ctx.verify(); const ret = await transaction([// 非用户输入的 id，没有使用 escape 进行转换。 ['update apply set status = 1 where id = ? and to_id = ?', [id, token.uid]], stringFormat(\"replace into user_friend values ('$1','$2'),('$2','$1')\", token.uid, friend_id) ]); if (!ret[0].affectedRows || !ret[1].affectedRows) &#123; return ctx.body = &#123; code: 2, message: '添加好友失败' &#125;; &#125; ctx.body = &#123; code: 0, message: '添加好友成功' &#125;;&#125; sql脚本当然还需要定义数据结构，有很多工具可以方便建表和建生产sql，这里以部分表为例，项目使用到的表要多得多。我这里还写了些无关紧要的触发器处理 数据插入时间 和数据修改时间，这是个人的习惯。完全可以不用触发器，直接在代码里面赋值，不影响使用。有用到 emoji 的数据表，记得要用 utf8mb4 格式。 create database if not exists chatdb;use chatdb;drop table if exists `user`;CREATE TABLE `user` ( `id` char(36) NOT NULL DEFAULT '' COMMENT '主键', `name` varchar(50) DEFAULT NULL COMMENT '用户名', `num` int(8) DEFAULT NULL COMMENT '用户号码', `salt` varchar(13) DEFAULT NULL COMMENT '加密的盐', `hash_password` varchar(64) DEFAULT NULL COMMENT '加密后的密码', `email` varchar(50) NOT NULL COMMENT 'email地址', `nick` varchar(50) DEFAULT NULL COMMENT '昵称', `avatar` varchar(200) DEFAULT NULL COMMENT '头像', `signature` varchar(200) DEFAULT NULL COMMENT '个性签名', `status` tinyint(1) DEFAULT 0 COMMENT '状态(0 离线 1 在线 2 隐身)', `is_admin` tinyint(1) DEFAULT 0 COMMENT '是否管理员', `is_block` tinyint(1) DEFAULT 0 COMMENT '是否禁用', `create_date` int(10) unsigned DEFAULT NULL COMMENT '注册时间', `update_date` int(10) unsigned DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='用户表'; drop table if exists `message`;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `content` text NOT NULL COMMENT '内容', `type` tinyint(1) DEFAULT 0 COMMENT '类型(0 用户 1 组群)', `send_id` char(36) NOT NULL COMMENT '发送用户id', `receive_id` char(36) DEFAULT NULL COMMENT '接收用户id', `group_id` int(11) DEFAULT NULL COMMENT '组id', `create_date` int(10) unsigned DEFAULT NULL COMMENT '创建时间', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='消息表';drop table if exists `user_message`;CREATE TABLE `user_message` ( `user_id` char(36) DEFAULT NULL COMMENT '接收用户id', `send_id` char(36) NOT NULL COMMENT '发送用户id', `message_id` int(11) NOT NULL COMMENT '消息id', `is_read` tinyint(1) DEFAULT 0 COMMENT '是否读过(0 没有 1 读过)', PRIMARY KEY (`send_id`,`message_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户消息连接表';-- user表insert触发器delimiter $$create trigger `user_insert` before insert on `user`for each ROWbeginif (new.id = '' or new.id is null) then set new.id = uuid();end if;if (new.num = 0 or new.num is null) then set new.num = 1000;end if;if (new.`create_date` = 0 or new.`create_date` is null) then set new.`create_date` = unix_timestamp(now());end if;if (new.`update_date` = 0 or new.`update_date` is null) then set new.`update_date` = unix_timestamp(now());end if;END$$-- user表update触发器delimiter $$create trigger `user_update` before update on `user`for each ROWbeginif ((new.`name` &lt;&gt; old.`name`) or (new.`name` is not null and old.`name` is null) or (new.`email` &lt;&gt; old.`email`) or (new.`email` is not null and old.`email` is null) or (new.`nick` &lt;&gt; old.`nick`) or (new.`nick` is not null and old.`nick` is null) or (new.`avatar` &lt;&gt; old.`avatar`) or (new.`avatar` is not null and old.`avatar` is null) or (new.`signature` &lt;&gt; old.`signature`) or (new.`signature` is not null and old.`signature` is null)) then set new.`update_date` = unix_timestamp(now());end if;END$$-- message表insert触发器delimiter $$create trigger `message_insert` before insert on `message`for each ROWbeginif (new.`create_date` = 0 or new.`create_date` is null) then set new.`create_date` = unix_timestamp(now());end if;END$$ 后续接着就是我们的大前端部分了，将会用到 vue，vuex，请继续关注。","tags":[{"name":"node","slug":"node","permalink":"https://edwardzhong.github.io/tags/node/"},{"name":"mysql","slug":"mysql","permalink":"https://edwardzhong.github.io/tags/mysql/"}]},{"title":"koa+mysql+vue+socket.io全栈开发之web api篇","date":"2019-04-08T07:50:03.000Z","path":"2019/04/08/fullstack/","text":"目标是建立一个 web QQ 的项目，使用的技术栈如下： 后端是基于 koa2 的 web api 服务层，提供 curd 操作的 http 接口，登录验证使用的是 json web token，跨域方案使用的是 cors； 数据库使用的是 mysql； 为了实时通信，使用的是基于 websocket 协议的 socket.io 框架； 前端则使用的是 vue + vuex。 本篇则讲叙服务端的搭建，之所以使用 koa，而不使用其他封装过的框架，比如 Egg.js, Thinkjs。因为在我看来, koa2 已经够方便，插件也足够多，完全可以根据自己的需求，像搭积木一样构建出最适合业务需求的框架。这样不但摒弃了很多用不到的插件，使整个框架更加精简，也能对整个框架知根知底，减少了很多不可预知因素的影响。 当然我觉得最主要的是我比较懒 😄，不想再去学其他框架特有的 api，特有的配置。因为前端有太多框架太多 api 需要掌握了，对于非互联网公认的技术标准，我觉得学习的优先级还是要靠后一点的。因为这些个框架，三天两头就冒出个热门的，简直多不胜数，学不过来啊，而 koa 基本都是这些框架的底层，明显靠谱多了。 基本框架搭建这几个 koa 插件大部分项目八九不离十要用到： koa-body 解析 http 数据 koa-compress gzip 压缩 koa-router 路由 koa-static 设置静态目录 koa2-cors 跨域 cors log4js 老牌的日志组件 jsonwebtoken jwt 组件 基本的目录结构public #公共目录src #前端目录server #后端目录├── common #工具├── config #配置文件├── controller #控制器├── daos #数据库访问层├── logs #日志目录├── middleware #中间件目录├── socket #socketio目录├── app.js #入口文件└── router.js #路由 入口文件 app.js主要就是几个中间件配置需要注意一下，这里同时还加载了 socket.io 服务。socket.io 相关的基本知识点可以看我之前写的文章关于 socket.io 的使用。 //app.js//...const path = require('path');const baseDir = path.normalize(__dirname + '/..');// gzipapp.use( compress(&#123; filter: function(content_type) &#123; return /text|javascript/i.test(content_type); &#125;, threshold: 2048, flush: require('zlib').Z_SYNC_FLUSH, &#125;),);// 解析请求app.use( koaBody(&#123; jsonLimit: 1024 * 1024 * 5, formLimit: 1024 * 1024 * 5, textLimit: 1024 * 1024 * 5, multipart: true, // 解析FormData数据 formidable: &#123; uploadDir: path.join(baseDir, 'public/upload') &#125;, //上传文件目录 &#125;),);// 设置静态目录app.use(static(path.join(baseDir, 'public'), &#123; index: false &#125;));app.use(favicon(path.join(baseDir, 'public/favicon.ico')));//corsapp.use( cors(&#123; origin: 'http://localhost:' + config.clientPort, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], exposeHeaders: ['Authorization'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'], &#125;),);//json-web-token中间件app.use( jwt(&#123; secret: config.secret, exp: config.exp, &#125;),);// 登录验证中间件，exclude 表示不验证的页面，include 表示要验证的页面app.use( verify(&#123; exclude: ['/login', '/register', '/search'], &#125;),);// 错误处理中间件app.use(errorHandler());// 路由addRouters(router);app.use(router.routes()).use(router.allowedMethods());// 处理404app.use(async (ctx, next) =&gt; &#123; log.error(`404 $&#123;ctx.message&#125; : $&#123;ctx.href&#125;`); ctx.status = 404; ctx.body = &#123; code: 404, message: '404! not found !' &#125;;&#125;);// 处理中间件和系统错误app.on('error', (err, ctx) =&gt; &#123; log.error(err); //log all errors ctx.status = 500; ctx.statusText = 'Internal Server Error'; if (ctx.app.env === 'development') &#123; //throw the error to frontEnd when in the develop mode ctx.res.end(err.stack); //finish the response &#125; else &#123; ctx.body = &#123; code: -1, message: 'Server Error' &#125;; &#125;&#125;);if (!module.parent) &#123; const &#123; port, socketPort &#125; = config; /** * koa app */ app.listen(port); log.info(`=== app server running on port $&#123;port&#125;===`); console.log('app server running at: http://localhost:%d', port); /** * socket.io */ addSocket(io); server.listen(socketPort);&#125; 跨域 cors 和 json web token这里解释一下 koa-cors 参数的设置，我项目使用的是 json web token，需要把认证字段 Authorization 添加到 header，前端获取该 header 字段，之后给后台发送 http 请求的时候，再带上该 Authorization。 origin：如果要访问 header 里面的字段或者设置 cookie，要写具体的域名地址，用 星号 * 是不行的； credentials：主要是给前端获取 cookie； allowMethods：允许访问的方法； exposeHeaders：前端如果要获取该 header 字段，必须写明（json web token 用）； allowHeaders：添加到 header 的字段； 至于 json web token 的原理，网上资料齐全，这里不再介绍了。 app.use( cors(&#123; origin: 'http://localhost:' + config.clientPort, // 访问header,要写明具体域名才行 credentials: true, //将凭证暴露出来, 前端才能获取cookie allowMethods: ['GET', 'POST', 'DELETE'], exposeHeaders: ['Authorization'], // 将header字段expose出去 allowHeaders: ['Content-Type', 'Authorization', 'Accept'], // 允许添加到header的字段 &#125;),); 中间件 middlewarekoa 的中间件就是 web 开发的利器，通过它可以非常方便的实现 强类型语言中的 aop 切面编程，而 koa2 中间件 的编写也足够简单 koajs。 项目在以下几个地方都用中间件进行了封装，很多重复的样板代码因此得以简化。 json web token（jwt） 登录验证（verify） 错误处理（errorHandler） 就以最简单的错误处理中间件为例子，如果不使用错误处理中间件，我们需要每个控制器方法进行 try{…} catch{…} ，其他中间件编写方式类似，就不再介绍。 /** * error handler 中间件 */module.exports = () =&gt; &#123; return async (ctx, next) =&gt; &#123; try &#123; await next(); //没有错误则进入下一个中间件 &#125; catch (err) &#123; log.error(err); let obj = &#123; code: -1, message: '服务器错误', &#125;; if (ctx.app.env === 'development') &#123; obj.err = err; &#125; ctx.body = obj; &#125; &#125;;&#125;;// 控制器代码使用error handler中间件后，每个方法都不需要 try catch处理错误，记录错误日志，处理逻辑都集中在中间件里面了。exports.getInfo = async function(ctx) &#123; // try &#123; const token = await ctx.verify(); const [users, friends] = await Promise.all([userDao.getUser(&#123; id: token.uid &#125;), getFriends([token.uid])]); const msgs = applys.map(formatTime); ctx.body = &#123; code: 0, message: '好友列表', data: &#123; user: users[0], friends: mergeReads(friends, reads), groups, msgs, &#125;, &#125;; // &#125; catch (err) &#123; // log.error(err); // let obj = &#123; // code: -1, // message: \"服务器错误\" // &#125;; // if (ctx.app.env === \"development\") &#123; // obj.err = err; // &#125; // ctx.body = obj; // &#125;&#125;; 路由配置路由配置只使用了 get，post 方法，当然要使用 put，delete 也只是改一下名字就行。 // router.jsconst &#123; uploadFile &#125; = require('./controller/file');const &#123; login, register &#125; = require('./controller/sign');const &#123; addGroup, delGroup, updateGroup &#125; = require('./controller/group');//...module.exports = function(router) &#123; router .post('/login', login) .post('/register', register) .post('/upload', uploadFile) .post('/addgroup', addGroup) .post('/delgroup', delGroup) .post('/updategroup', updateGroup); //...&#125;; 控制器以 updateInfo 方法为例，koa2 已经全面支持 async await，编写方式和同步代码没多大区别。 exports.updateInfo = async function(ctx) &#123; const form = ctx.request.body; const token = await ctx.verify(); const ret = await userDao.update([form, token.uid]); if (!ret.affectedRows) &#123; return (ctx.body = &#123; code: 2, message: '更新失败', &#125;); &#125; ctx.body = &#123; code: 0, message: '更新成功', &#125;;&#125;; 后续接着下一编就是基于 mysql 构建 数据库访问层。","tags":[{"name":"node","slug":"node","permalink":"https://edwardzhong.github.io/tags/node/"},{"name":"koa","slug":"koa","permalink":"https://edwardzhong.github.io/tags/koa/"},{"name":"jwt","slug":"jwt","permalink":"https://edwardzhong.github.io/tags/jwt/"}]},{"title":"关于socket.io的使用","date":"2019-03-28T16:44:31.000Z","path":"2019/03/29/socketio/","text":"这段时间学习了socket.io，用它写了小项目，在此总结下它的基本使用方式和一些要点。socket.io是基于Node.js和WebSocket协议的实时通信开源框架，它包括客户端的JavaScript和服务器端的Node.js。 服务端这里后端使用的框架是koa2，socket.io将自身绑定到koa的进程中去，其中最重要的事件就是 connection 和 disconnect。它们是框架本身定义的系统事件，也就意味着它是自然就存在的不需要我们自定义，当然还有其它系统事件，但很少会用得到。 const koa = require('koa')const app = new koa()const server = require('http').createServer(app.callback())const io = require('socket.io')(server)//监听connect事件io.on('connection', socket =&gt; &#123; socket.emit('open');//通知客户端已连接 console.log('connected'); //监听disconnect事件 socket.on('disconnect', () =&gt; &#123; console.log('disconnect') &#125;&#125;);server.listen(3001); 客户端web端直接传入url地址即可，其中这里监听的 open 事件是用户自定义的，对应服务端的则是发送open事件。 import io from 'socket.io-client';//建立websocket连接const socket = io('http://127.0.0.1:3001');//收到server的连接确认socket.on('open', () =&gt; &#123; showTip('socket io is open !'); init();&#125;); emit 和 onemit 和 on 是最重要的两个api，分别对应 发送 和 监听 事件。 socket.emit(eventName[, …args])：发射（触发）一个事件 socket.on(eventName, callback)：监听一个 emit 发射的事件 我们可以非常自由的在服务端定义并发送一个事件emit，然后在客户端监听 on，反过来也一样。 发送的内容格式也非常自由，既可以是基本数据类型 Number，String，Boolean 等，也可以是 Object，Array 类型，甚至还可以是函数。而用回调函数的方式则可以进行更便携的交互。 /*** 服务端 **/socket.on('message',data =&gt;&#123; console.log(data)&#125;);socket.emit('send','hello everybody');/*** 客户端 **/socket.emit('message',&#123;id:'1',txt:'hello'&#125;);socket.on('send',data =&gt;&#123; console.log(data);&#125;);//回调函数/*** 服务端 **/socket.on('sayit', (word, callback)=&gt; &#123; callback('say ' + word);&#125;);/*** 客户端 **/socket.emit('sayit', 'wow', data =&gt; &#123; console.log(data); // say wow&#125;); broadcast 广播broadcast 默认是向所有的socket连接进行广播，但是不包括发送者自身，如果自己也打算接收消息的话，需要给自己单独发送。 /*** 服务端 **/io.on('connection', socket =&gt; &#123; const data= &#123; txt:'new user login', time:new Date() &#125; //广播向所有socket连接 socket.broadcast.emit('userin',data); //给自己也发一份 socket.emit('userin',data);&#125;); namespace 命名空间如果你想隔离作用域，或者划分业务模块，namespace 是个有效的法子。namespace 相当于建立新的频道，你可以在一个 socket.io 服务上面隔离不同的连接，事件和中间件。 默认的连接也是有namespace的，那就是 /；使用命名空间的方式一：直接在链接后面加子域名，这种其实用的还是同一个 sokcet 服务进程，可以看成是软隔离吧。 /*** 客户端 **/import io from 'socket.io-client';//默认的namespaceconst socket = io('http://127.0.0.1:3001');// mypathconst socket = io('http://127.0.0.1:3001/mypath', &#123; forceNew: true &#125;);/*** 服务端 **///默认的namespaceio.on('connection', socket =&gt; &#123;&#125;);// mypathio.of('/mypath').on('connection', socket =&gt; &#123;&#125;); 使用命名空间的方式二： path 参数，这种就是实打实的重新起了一个 socket 服务了。 /*** 客户端 **/const socket = io('http://localhost', &#123; path: '/mypath'&#125;);/*** 服务端 **/// 另外重新起socket服务const io = require('socket.io')(&#123; path: '/mypath'&#125;); middleware 中间件socket.io 的中间件 和 kao2 的非常相似，这意味着我们可以在变动很小的情况下，将koa2的中间件改造为 socket.io 所用。 const mypath = io.of('/mypath').on('connection', socket =&gt; &#123; socket.on('message', data =&gt; &#123; &#125;);&#125;);//中间件const auth = (socket, next) =&gt; &#123; const data = socket.request; if(!verify(data))&#123; throw new Error('not verify'); &#125; next();&#125;// mypath 这个 namespace 注册中间件mypath.use(auth); rooms每一个socket连接都会有一个独一无二的标志，那就是 socket.id，我们就是通过id来区分不同连接的。除此之外，socket.id 本身也是房间 room 的标志，通俗讲，每个socket 连接自身都拥有一间房 room。那么我们就可以给这个 room 发送消息，还有如果你加入了房间，就能接受到房间里的广播信息。当然你可以自定义 room ，让socket连接加入或离开。还有如果 socket 断开连接，也就是 disconnect 后，它会被自动移出room。 而这就是实现 单独聊天 和 群组聊天 的基础，来看一下对应的api。 socket.join(rooms[, callback])：加入房间 socket.leave(room[, callback]) ：离开房间 socket.to(room)： 给房间发送消息 // 自定义roomio.on('connection', socket =&gt;&#123; socket.join('some room')); // 加入房间 socket.leave('some room'); // 离开房间&#125;); // 向房间里的所有客户端发送消息io.to('some room').emit('some event'); // 默认房间（每一个id一个room）socket.on('say to someone', (id, msg) =&gt; &#123; socket.broadcast.to(id).emit('my message', msg); &#125;); 总结相信有了以上介绍的基础知识，再加上官网对应的文档，要开发聊天室或者其他 实时通信 的项目，是一件易如反掌的事情 socket.io官网 里面有对 api 非常详细的讲解和用例。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"socket.io","slug":"socket-io","permalink":"https://edwardzhong.github.io/tags/socket-io/"}]},{"title":"基于Webpack 4 和 React hooks 搭建项目","date":"2019-02-04T05:58:44.000Z","path":"2019/02/04/reacthooks/","text":"面对日新月异的前端，我表示快学不动了😂。 Webpack 老早就已经更新到了 V4.x，前段时间 React 又推出了 hooks API。刚好春节在家里休假，时间比较空闲，还是赶紧把 React技术栈这块补上。 网上有很多介绍 hooks 知识点的文章，但都比较零碎，基本只能写一些小 Demo。还没有比较系统的，全新的基于 hooks 进行搭建实际项目的讲解。所以这里就从开发实际项目的角度，搭建起单页面 Web App项目的基本脚手架，并基于 hooks API 实现一个 react 项目模版。 Hooks 最吸引人的地方就是用 函数式组件 代替面向对象的 类组件。此前的 react 如果涉及到状态，解决方案通常只能使用 类组件，业务逻辑一复杂就容易导致组件臃肿，模块的解藕也是个问题。而使用基于 hooks 的 函数组件 后，代码不仅更加简洁，写起来更爽，而且模块复用也方便得多，非常看好它的未来。 webpack 4 的配置没有使用 create-react-app 这个脚手架，而是从头开始配置开发环境，因为这样自定义配置某些功能会更方便些。下面这个是通用的配置 webpack.common.js 文件。 const &#123; resolve &#125; = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const &#123; HotModuleReplacementPlugin &#125; = require('webpack');module.exports = &#123; entry: './src/index.js',//单入口 output: &#123; path: resolve(__dirname, 'dist'), filename: '[name].[hash].js'//输出文件添加hash &#125;, optimization: &#123; // 代替commonchunk, 代码分割 runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all' &#125; &#125; &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, use: ['babel-loader'] &#125;, &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1, modules: true,//css modules localIdentName: '[name]___[local]___[hash:base64:5]' &#125;, &#125;, 'postcss-loader', 'sass-loader'] &#125;, &#123; /* 当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方 当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径 */ test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 1000 &#125; &#125;] &#125; ] &#125;, plugins: [ new CleanWebpackPlugin(['dist']),//生成新文件时，清空生出目录 new HtmlWebpackPlugin(&#123; template: './public/index.html',//模版路径 favicon: './public/favicon.png', minify: &#123; //压缩 removeAttributeQuotes:true, removeComments: true, collapseWhitespace: true, removeScriptTypeAttributes:true, removeStyleLinkTypeAttributes:true &#125;, &#125;), new HotModuleReplacementPlugin()//HMR ]&#125;; 接着基于 webpack.common.js 文件，配置出开发环境的 webpack.dev.js 文件，主要就是启动开发服务器。 const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: './dist', port: 4001, hot: true &#125;&#125;); 生成模式的 webpack.prod.js 文件，只要定义了 mode:’production’， webpack 4 打包时就会自动压缩优化代码。 const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; mode: 'production', devtool: 'source-map'&#125;); 配置 package.js 中的 scripts &#123; \"scripts\": &#123; \"start\": \"webpack-dev-server --open --config webpack.dev.js\", \"build\": \"webpack --config webpack.prod.js\" &#125;&#125; Babel 的配置 babel 的 .babelrc 文件， css module 包这里推荐 *babel-plugin-react-css-modules。 *react-css-modules** 既支持全局的css(默认 className 属性)，同时也支持局部css module( styleName 属性)，还支持css预编译器，这里使用的是 scss。 &#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ], \"plugins\": [ \"@babel/plugin-proposal-class-properties\", \"@babel/plugin-transform-runtime\", [ \"react-css-modules\", &#123; \"exclude\": \"node_modules\", \"filetypes\": &#123; \".scss\": &#123; \"syntax\": \"postcss-scss\" &#125; &#125;, \"generateScopedName\": \"[name]___[local]___[hash:base64:5]\" &#125; ] ]&#125; React 项目下面是项目基本的目录树结构，接着从入口开始一步步细化整个项目。 ├ package.json├ src│ ├ component // 组件目录│ ├ reducer // reducer目录│ ├ action.js│ ├ constants.js│ ├ context.js│ └ index.js├ public // 静态文件目录│ ├ css│ └ index.html├ .babelrc├ webpack.common.js├ webpack.dev.js└ webpack.prod.js 状态管理组件使用 redux， react-router 用于构建单页面的项目，因为使用了 hooks API，所以不再需要 react-redux 连接状态 state。 入口文件 index.js // index.jsimport React, &#123; useReducer &#125; from 'react'import &#123; render &#125; from 'react-dom'import &#123; HashRouter as Router, Route, Redirect, Switch &#125; from 'react-router-dom'import Context from './context.js'import Home from './component/home.js'import List from './component/list.js'import rootReducer from './reducer'import '../public/css/index.css'const Root = () =&gt; &#123; const initState = &#123; list: [ &#123; id: 0, txt: 'webpack 4' &#125;, &#123; id: 1, txt: 'react' &#125;, &#123; id: 2, txt: 'redux' &#125;, ] &#125;; // useReducer映射出state，dispatch const [state, dispatch] = useReducer(rootReducer, initState); // &lt;Context.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt; 基本代替了 react-redux 的 &lt;Provider store=&#123;store&#125;&gt; return &lt;Context.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt; &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route exact path=\"/list\" component=&#123;List&#125; /&gt; &lt;Route render=&#123;() =&gt; (&lt;Redirect to=\"/\" /&gt;)&#125; /&gt; &lt;/Switch&gt; &lt;/Router&gt; &lt;/Context.Provider&gt;&#125;render( &lt;Root /&gt;, document.getElementById('root')) constants.js ， action.js 和 reducer.js 与之前的写法是一致的。 // constants.jsexport const ADD_COMMENT = 'ADD_COMMENT'export const REMOVE_COMMENT = 'REMOVE_COMMENT' action.js // action.jsimport &#123; ADD_COMMENT, REMOVE_COMMENT &#125; from './constants'export function addComment(comment) &#123; return &#123; type: ADD_COMMENT, comment &#125;&#125;export function removeComment(id) &#123; return &#123; type: REMOVE_COMMENT, id &#125;&#125; list.js //list.jsimport &#123; ADD_COMMENT, REMOVE_COMMENT &#125; from '../constants.js'const list = (state = [], payload) =&gt; &#123; switch (payload.type) &#123; case ADD_COMMENT: if (Array.isArray(payload.comment)) &#123; return [...state, ...payload.comment]; &#125; else &#123; return [...state, payload.comment]; &#125; case REMOVE_COMMENT: return state.filter(i =&gt; i.id != payload.id); default: return state; &#125;&#125;;export default list reducer.js //reducer.jsimport &#123; combineReducers &#125; from 'redux'import list from './list.js'import user from './user.js'const rootReducer = combineReducers(&#123; list, user&#125;);export default rootReducer 最大区别的地方就是 component 组件，基于 函数式，内部的表达式就像是即插即用的插槽，可以很方便的抽取出通用的组件，然后从外部引用。相比之前的 面向对象 方式，我觉得 函数表达式 更受前端开发者欢迎。 useContext 获取全局的 state useRef 代替之前的 ref useState 代替之前的 state useEffect 则可以代替生命周期钩子函数 //监控数组中的参数，一旦变化就执行useEffect(() =&gt; &#123; updateData(); &#125;,[id]);//不传第二个参数的话，它就等价于每次componentDidMount和componentDidUpdate时执行useEffect(() =&gt; &#123; updateData(); &#125;);//第二个参数传空数组，等价于只在componentDidMount和componentWillUnMount时执行， //第一个参数中的返回函数用于执行清理功能useEffect(() =&gt; &#123; initData(); reutrn () =&gt; console.log('componentWillUnMount cleanup...'); &#125;, []); 最后就是实现具体界面和业务逻辑的组件了，下面是其中的List组件 // list.jsimport React, &#123; useRef, useState, useContext &#125; from 'react'import &#123; bindActionCreators &#125; from 'redux'import &#123; Link &#125; from 'react-router-dom'import Context from '../context.js'import * as actions from '../action.js'import Dialog from './dialog.js'import './list.scss'const List = () =&gt; &#123; const ctx = useContext(Context);//获取全局状态state const &#123; user, list &#125; = ctx.state; const [visible, setVisible] = useState(false); const [rid, setRid] = useState(''); const inputRef = useRef(null); const &#123; removeComment, addComment &#125; = bindActionCreators(actions, ctx.dispatch); const confirmHandle = () =&gt; &#123; setVisible(false); removeComment(rid); &#125; const cancelHandle = () =&gt; &#123; setVisible(false); &#125; const add = () =&gt; &#123; const input = inputRef.current, val = input.value.trim(); if (!val) return; addComment(&#123; id: Math.round(Math.random() * 1000000), txt: val &#125;); input.value = ''; &#125; return &lt;&gt; &lt;div styleName=\"form\"&gt; &lt;h3 styleName=\"sub-title\"&gt;This is list page&lt;/h3&gt; &lt;div&gt; &lt;p&gt;hello, &#123;user.name&#125; !&lt;/p&gt; &lt;p&gt;your email is &#123;user.email&#125; !&lt;/p&gt; &lt;p styleName=\"tip\"&gt;please add and remove the list item !!&lt;/p&gt; &lt;/div&gt; &lt;ul&gt; &#123; list.map(l =&gt; &lt;li key=&#123;l.id&#125;&gt;&#123;l.txt&#125;&lt;i className=\"icon-minus\" title=\"remove item\" onClick=&#123;() =&gt; &#123; setVisible(true); setRid(l.id); &#125;&#125;&gt;&lt;/i&gt;&lt;/li&gt;) &#125; &lt;/ul&gt; &lt;input ref=&#123;inputRef&#125; type=\"text\" /&gt; &lt;button onClick=&#123;add&#125; title=\"add item\"&gt;Add Item&lt;/button&gt; &lt;Link styleName=\"link\" to=\"/\"&gt;redirect to home&lt;/Link&gt; &lt;/div&gt; &lt;Dialog visible=&#123;visible&#125; confirm=&#123;confirmHandle&#125; cancel=&#123;cancelHandle&#125;&gt;remove this item ?&lt;/Dialog&gt; &lt;/&gt;&#125;export default List; 项目代码https://github.com/edwardzhong/webpack_react","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"react","slug":"react","permalink":"https://edwardzhong.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://edwardzhong.github.io/tags/webpack/"}]},{"title":"动画函数的绘制及自定义动画函数","date":"2019-01-02T18:01:23.000Z","path":"2019/01/03/animationfun/","text":"制作动画效果离不开动画运动函数，而我们用得最多的无疑就是 Tween.js。根据不同的数学公式原理，Tween.js 划分出了不同的动画类型，每种动画类型里面都包含以下的缓动类型： ease in 先慢后快 ease out 先块后慢 ease in out 先慢后快再慢 关于缓动函数，我们在 css3 动画里已经用得太多了，不再细讲。Tween.js 源代码请看：Tween.js 绘制动画曲线我们可以根据实际情况选择对应的动画函数，但问题是有十几个动画函数，一个个试过去也太麻烦了。有没有一种直观的方式让我们一目了然的知道每种动画的运动效果呢？当然有，那就是把动画函数绘制出来，渲染方式多种多样，css，svg，canvas，从效果和便携考虑，我选择用 canvas 实现。实现原理其实非常简单，基本就是调用canvas的基础api，demo的效果请看：TweenJS动画运动函数绘制 这里解释一下坐标界面，X轴是运动时间，Y轴则是运动的距离。点击 tween 类型和 ease 类型选择框，就可以看到对应运动曲线的绘制动画，以及右边小球的实际运动效果。核心代码如下： function orbit()&#123; ctx.save(); ctx.translate(10,450); ctx.strokeStyle ='hsl(30,100%,50%)'; ctx.beginPath(); ctx.clearRect(0,1,500,150); ctx.moveTo(0,0); pos.forEach(function(n,i)&#123; ctx.lineTo(n.x,n.y); &#125;); ctx.stroke(); ctx.restore();&#125;function ball(y)&#123; ctx.save(); ctx.clearRect(520,0,90,600); ctx.translate(540,450-y); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2,false); ctx.fill(); ctx.restore();&#125;~function animate()&#123; isRunning = true; t = new Date() - start; if(t &gt; duration) &#123; pos.push(&#123;x:xLen,y:-yLen&#125;); orbit(); ball(yLen); isRunning = false; return; &#125; y = fn(t,0,yLen,duration); pos.push(&#123;x:t*space,y:-y&#125;) orbit(); ball(y); requestAnimationFrame(animate); &#125;(); 自定义动画函数有了这个小工具，选择动画函数就非常方便了。仔细观察这些运动曲线，它们的形状都像什么？像贝塞尔曲线呀，应该说大部分像。而刚好 canvas 也有绘制贝塞尔曲线的api，那么使用三次贝塞尔曲线绘制方法 bezierCurveTo() 就可以可视化的自定义自己想要的运动曲线。 绘制原理和拖动原理在之前的文章 canvas图形编辑器 有详细介绍（编辑器里面绘制贝塞尔曲线同时还要检测移动起始点，结束点，控制点，中心点，比这里的功能还要复杂）。实现的demo请看：自定义动画公式这里固定了起始点和结束点，剩余两个控制点可以鼠标拖动，原理无非就是检测鼠标的位置是否在控制点上，如果在控制点上，就将鼠标坐标值设为对应控制点，同时绘制曲线，也就达到了曲线实时绘制的效果了。 有了可视化的曲线，接着还要用公式将它表达出来，也就是传入某个时间点，返回对应的运动位置。这里面用到了如下的公式，只需要将当前时间 t 和 起始点，结束点，控制点的 y 坐标传入( y 对应距离)，就可获得当前时间 t 对应的位置。 /** * 获取三次贝塞尔曲线坐标 * @param &#123;Number&#125; p0 [起始点] * @param &#123;Number&#125; p1 [控制点1] * @param &#123;Number&#125; p2 [控制点2] * @param &#123;Number&#125; p3 [结束点] * @param &#123;Number&#125; t [取值范围：0～1] * @return &#123;Number&#125; */function BezierPos(p0,p1,p2,p3,t)&#123; return p0*Math.pow(1-t,3)+3*p1*t*Math.pow(1-t,2)+3*p2*Math.pow(t,2)*(1-t)+p3*Math.pow(t,3);&#125; 根据上面的公式，再结合 Tween.js 里面的函数调用格式，就可以实现生成代码的功能了。 function showCode()&#123; var code = `function bezierFun(t,b,c,d)&#123;\\n`+ `\\tt = t/d;\\n`+ `\\tvar y = $&#123;start.y&#125;*Math.pow(1-t,3)+3*$&#123;controls[0].y&#125;*t*Math.pow(1-t,2)+3*$&#123;controls[1].y&#125;*Math.pow(t,2)*(1-t)+$&#123;end.y&#125;*Math.pow(t,3);\\n`+ `\\treturn b+(300-y)/200*c;\\n&#125;`; txt.value = code;&#125; 最后也就实现了鼠标拖动控制点，即实时调整曲线形状，同时生成曲线对应的运动函数。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"canvas实现俄罗斯方块","date":"2018-12-12T13:35:33.000Z","path":"2018/12/12/tetris/","text":"好久没使用canvas了，于是通过写小游戏“俄罗斯方块”再次熟悉下canvas，如果有一定的canvas基础，要实现还是不难的。实际完成的Demo请看：*canvas俄罗斯方块*。 原理详解看游戏最终界面，可知需要实现以下关键功能： 游戏面板，也就是12 * 20的方格，以及是否填充了方块信息； 运动方块，方块需要实现移动，变形的功能。 界面的实现整个面板就是以左上角（0,0）为原点的坐标系，右上角（12,0）左下角（0,20）右下角（12,20），每个点的坐标位置都可以确定。是否已经填充方块，我们可以将每个方格看成一个数组元素，0表示没有，1表示已经填充。12 * 20 的面板使用两层数组，即用20个长度为12的数组实现。var maps = [[0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,1,0], ...]; 画出面板的代码，用最基础的canvas的api就能实现 //格子for(var i=0;i&lt;12;i++)&#123; for(var j=0;j&lt;20;j++)&#123; ctx.fillRect(i*40,j*40,40,40); ctx.strokeRect(i*40,j*40,40,40); if(this.maps[j][i]==1)&#123;//方格已经有填充内容 ctx.save(); ctx.lineWidth=4; ctx.fillStyle='hsla(200,100%,50%,.5)'; ctx.strokeStyle='hsla(200,100%,50%,.9)'; ctx.fillRect(i*40,j*40,40,40); ctx.strokeRect(i*40+2,j*40+2,38,38); ctx.restore(); &#125; &#125;&#125;//边框ctx.lineWidth=4;ctx.strokeStyle='hsla(0,100%,0%,.3)';ctx.moveTo(0,0);ctx.lineTo(0,20*40);ctx.lineTo(12*40,20*40);ctx.lineTo(12*40,0);ctx.stroke();ctx.restore(); 方块的实现游戏中用到以下 7 种图形 结合上面介绍的坐标系，数组 [x1, y1, x2, y2, x3, y3, x4, y4] 就是上面图形中4个点坐标的数据表现形式，7 种图形的坐标分别如下： var Arr = [[4,0,4,1,5,1,6,1],[4,1,5,1,6,1,6,0],[4,0,5,0,5,1,6,1],[4,1,5,0,5,1,6,0],[5,0,4,1,5,1,6,1],[4,0,5,0,6,0,7,0],[5,0,6,0,5,1,6,1]]; 方块的移动，遍历整个数组，加上位移向量就行，非常简单 class Shape &#123; constructor(m)&#123; this.m = Object.assign([],m); &#125; move(x,y)&#123; // 位移 var m = this.m, l = m.length; y = y||0; for (var i=0;i&lt;l;i=i+2)&#123; m[i]+=x; m[i+1]+=y; &#125; return this; &#125; 方块的旋转，俄罗斯方块里面方块除了左右和上下运动，还会旋转，不是吗？稍微思考下就知道，这不过就是矩阵变换而已，也就是每次图形绕中心点旋转90度。我这里用数组第三个点作为图形变换的中心点，当然这样处理不够完善。 class Shape &#123; transform()&#123;//二维矩阵变换 var m =this.m, l = m.length, c = Math.ceil(l/2), x = m[c], y = m[c+1], cos = Math.cos(Math.PI/2), sin = Math.sin(Math.PI/2); for (var i=0;i&lt;l;i=i+2)&#123; if(i == c) continue; var mx = m[i]- x, my = m[i+1] - y, nx = mx*cos - my*sin, ny = my*cos + mx*sin; m[i]=x+nx; m[i+1]=y+ny; &#125; return this; &#125; 边界条件主要包括如下三个方面 方块位置不能超出界面的判断； 方块到达底部或放置完成的判断； 游戏结束的判断。 遍历数组 （1）任意一个点y坐标为19时表示到达了底部；（2）获取该坐标的y+1位置在maps的信息，如果为1表示已经填充。这两种情况下，运动方块的周期结束，将该方块的坐标填充到maps对应的数组里面即可。 如果坐标的y+1已经有填充，同时当前坐标小于1，即已经在界面的顶部了，那么表示游戏结束。 var isEnd = false,isOver=false,x,y;for(var i=0,sl=that.shape.m.length;i&lt;sl;i=i+2)&#123; x=that.shape.m[i]; y=that.shape.m[i+1]; if(y &gt;= 19)&#123; // 到了底部 isEnd = true;break; &#125; if(that.maps[y+1][x]==1)&#123; // y+1位置已经填充 isEnd = true; if(y &lt;= 1)&#123;isOver=true;&#125; // 游戏结束 break; &#125;&#125; 方块运动周期结束时检测每一层是否满格，以及满格后的处理。某项数组全部元素都为1则表示已经满格，那么删除该项数组，同时列表头再压入一项每个元素都为0的数组即可。 checkPoint()&#123; var that = this, maps = that.maps; for(var i=0,l=maps.length;i&lt;l;i++)&#123; if(Math.min.apply(null,maps[i]) == 1)&#123;// 表示该层已经满格 that.maps.splice(i,1); that.score+=10; // 增加分数 that.maps.unshift([0,0,0,0,0,0,0,0,0,0,0,0]); &#125; &#125; return this;&#125; 绑定事件主要就是绑定keydown事件，要注意的是左移和右移事件包括了边界判断 bindEvent()&#123; var that = this; document.addEventListener('keydown',function(e)&#123; switch(e.keyCode)&#123; case 13: //enter cancelAnimationFrame(that.timer); that.init().update(); break; case 80: //p that.pause = !that.pause; break; case 40: //down that.d = 0.5; break; case 37: //left var over = false, maps = that.maps, shape = that.shape, m = shape.m; for(var i=0,l=m.length;i&lt;l;i=i+2)&#123; if(m[i]&lt;=0 || maps[m[i+1]][m[i]-1] == 1)&#123; over = true;break; &#125; &#125; if(!over) shape.move(-1,0); break; case 39: //right var over = false, shape = that.shape, maps = that.maps, m = shape.m; for(var i=0,l=m.length;i&lt;l;i=i+2)&#123; if(m[i]&gt;=11 || maps[m[i+1]][m[i]+1] == 1)&#123; over = true;break; &#125; &#125; if(!over) shape.move(1,0); break; case 32: //space that.shape.transform(); break; &#125; &#125;,false);&#125; 总结这里面实现了俄罗斯方块的最基本功能，还有关卡等功能点并没有实现，同时该demo仍然有不完善的地方需要修正。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"Haskell学习-monad","date":"2018-08-16T01:29:31.000Z","path":"2018/08/16/haskelld/","text":"什么是MonadHaskell是一门纯函数式的语言，纯函数的优点是安全可靠。函数输出完全取决于输入，不存在任何隐式依赖，它的存在如同数学公式般完美无缺。可是纯函数因为隔绝了外部环境，连最基本的输入输出都无法完成。而 Monad 就是 Haskell 给出的解决方案。但Monad 并不仅仅是 IO 操作的抽象，它更是多种类似操作之间共性的抽象。所以 Monad 解决的问题并不局限在 IO 上，像 Haskell 中的 Maybe 和 [] 都是 Monad。Haskell 中漂亮的错误处理方式， do 表示法和灵活的列表推导式 (list comprehension) 都算是 Monad 的贡献。 Monad 基本上是一种加强版的 Applicative Functor，正如 Applicative Functor 是 Functor 的加强版一样。所以在充分理解 Applicative Functor 的基础上，过渡到 Monad 其实是非常平滑的。 -- Monad的定义class Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b x &gt;&gt; y = x &gt;&gt;= \\_ -&gt; y fail :: String -&gt; m a fail msg = error msg return 跟其他语言中的 return 是完全不一样的，它是一个把普通值包进一个 context 里面的函数，并不是结束函数执行的关键字。其实等价于Applicative中的 pure。 &gt;&gt; 忽略前面表达式的返回值，直接执行当前表达式。 &gt;&gt;= 接受一个 monadic value（也就是具有 context 的值，可以用装有普通值的盒子来比喻）并且把它喂给一个接受普通值的函数，并回传一个 monadic value。 =&lt;&lt; 和上面 &gt;&gt;= 功能一样，只是结合顺序相反。 Monad 的原理函数之间要协作，就必须以各种形式交互连接。但如何隔离纯函数与副作用函数，同时又能让两类函数相互复用呢？ 以 IO 操作为例子分析，为了充分隔离纯函数与 IO 函数，Haskell 中不能实现 IO Char -&gt; Char 这样一种输入是 IO 类型返回值却是普通类型的函数。否则副作用函数就能很容易变身为纯函数了。事实上一旦参数中有 IO，返回值必有 IO，这就保证了充分隔离。 那如何让纯函数与 IO 函数相互复用呢？这就要靠 IO Monad 中定义的 return 和 &gt;&gt;= 这两个函数了。return （在 Haskell 中不是关键字，只是一个函数名）的作用是将某个类型为 A 的值 a 提升（装箱）为类型为 IO A 的值 Char -&gt; IO Char 。有了这个函数后，纯函数就可以通过 return 变成返回值为 IO 带副作用的函数了。 有了提升而没有下降操作，怎么复合 putChar :: Char -&gt; IO() 与 getChar :: IO Char 呢。 getChar 从 IO 读取一个字符， putChar 把字符写入 IO。但 getChar 返回的是 IO Char 类型，而 putChar 需要的是普通的 Char 类型，两者不匹配怎么办？ &gt;&gt;= 函数出马了！ &gt;&gt;= 的类型是 IO a -&gt; (a -&gt; IO b) -&gt; IO b 这样 &gt;&gt;= 就可以连接 getChar 与 putChar ，把输入写到输出中 getChar &gt;&gt;= putChar 可以看到 &gt;&gt;= 操作实际上是类型下降（或拆箱）操作，同时执行下降操作的函数返回值也必须是 IO 类型。这样既充分隔离纯函数与副作用函数，又能让函数相互复用。通过 return 和 &gt;&gt;= 两个平行世界 (范畴) 就有了可控的交流通道。 do 表示法Haskell的 do 表示法实际上是Monad的语法糖：它给我们提供了一种不使用 (&gt;&gt;=) 和匿名函数来写monadic代码的方式。去除do语法糖的过程就是把它转换为 (&gt;&gt;=) 和匿名函数。 do 表示法可以使用分号 ; 和大括号 { } 将语句分块；但一般会使用一个表达式一行的方式，不同的作用域用不同的缩进区分。 我们还是以IO 为例子，接受两次的键盘输入，然后将两次输入的字符串合并成一个字符串，最后屏幕打印输出。 &gt;&gt;= 会接受前面表达式的值；&gt;&gt; 则会忽略前面表达式的值；这里使用 return 实际它返回的仍然是IO String，因为Haskell会自动类型推导得出。monadic 的表达式代码如下： (++) &lt;$&gt; getLine &lt;*&gt; getLine &gt;&gt;= print &gt;&gt; return \"over\"111222&gt; \"111222\"&gt; \"over\" 使用 do改写，明显更加清晰，和我们熟悉的命令式语言风格差不多。&lt;- 表示从monadic value中取出普通值，可以看成是拆开盒子取出所需要的值。 foo :: IO String foo = do x &lt;- getLine y &lt;- getLine print (x ++ y) return \"over\" do语法对应模式 do &#123;e&#125; -&gt; edo &#123;e; es&#125; -&gt; e &gt;&gt; do &#123;es&#125;do &#123;let decls; es&#125; -&gt; let decls in do &#123;es&#125;do &#123;p &lt;- e; es&#125; -&gt; e &gt;&gt;= \\p -&gt; es Monad 类型来看一下几个默认的Monad类型，它们都必须实现 return,&gt;&gt;=,fail这几个函数。 Maybe中间任何一步只要有Nothing，结果就提前返回Nothing。没有任何意外的情况才返回Just 值。 -- Maybe 的 Monad instanceinstance Monad Maybe where return x = Just x Nothing &gt;&gt;= f = Nothing Just x &gt;&gt;= f = f x fail _ = Nothing-- 实例Just 3 &gt;&gt;= (\\x -&gt; Nothing &gt;&gt;= (\\y -&gt; Just (show x ++ y)))&gt; NothingJust 3 &gt;&gt;= (\\x -&gt; Just \"!\" &gt;&gt;= (\\y -&gt; Just (show x ++ y)))&gt; Just \"3!\" 使用 do 表示法写成这样： foo :: Maybe Stringfoo = do x &lt;- Just 3 y &lt;- Just \"!\" Just (show x ++ y) List &gt;&gt;= 基本上就是接受一个有 context 的值，把他喂进一个只接受普通值的函数，并回传一个具有 context 的值。[] 其实等价于 Nothing。 当我们用 **&gt;&gt;=** 把一个 list 喂给这个函数，lambda 会映射每个元素，会计算出一串包含一堆 list 的 list，最后再把这些 list 压扁，得到一层的 list。这就是我们得到 列表 **list** 处理 Mondic value 的过程。 --list 的 Monad instanceinstance Monad [] where return x = [x] xs &gt;&gt;= f = concat (map f xs) fail _ = []-- 实例[3,4,5] &gt;&gt;= \\x -&gt; [x,-x]&gt; [3,-3,4,-4,5,-5][1,2,3] &gt;&gt;= \\x -&gt; return (-x)&gt; [-1,-2,-3] list comprehension 也不过是 Monad 的语法糖 [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) -- Monad[ (n,ch) | n &lt;- [1,2], ch &lt;- ['a','b'] ] -- list comprehension&gt; [(1,'a'),(1,'b'),(2,'a'),(2,'b')] list comprehension 的过滤基本上跟 guard 是一致的。 [1..50] &gt;&gt;= (\\x -&gt; guard ('7' `elem` show x) &gt;&gt; return x)&gt; [7,17,27,37,47] 用 do 改写, 如果不写最后一行 return x，那整个 list 就会是包含一堆空 tuple 的 list。 sevensOnly :: [Int]sevensOnly = do x &lt;- [1..50] guard ('7' `elem` show x) return x-- 对应的 list comprehension[ x | x &lt;- [1..50], '7' `elem` show x ]&gt; [7,17,27,37,47] Either在 Control.Monad.Error 里面有 Error的 Monad instance。 instance (Error e) =&gt; Monad (Either e) where return x = Right x Right x &gt;&gt;= f = f x Left err &gt;&gt;= f = Left err fail msg = Left (strMsg msg)Right 3 &gt;&gt;= \\x -&gt; return (x + 100) :: Either String Int&gt; Right 103 Monad 规则 return a &gt;&gt;= f == f a== 左边的表达式等价于右边的表达式。如果仅仅是把一个值包装到monad里面然后使用 (&gt;&gt;=) 调用的话，我们就没有必要使用 return ；这条规则对于我们的代码风格有着实际的指导意义：我们不应该写一些不必要的代码；这条规则保证了简短的写法和冗余的写法是等价的。 return 3 &gt;&gt;= (\\x -&gt; Just (x+100000)) -- 和直接函数调用没有区别 m &gt;&gt;= return == m这一条规则对风格也有好处：如果在一系列的action块里面，如果最后一句就是需要返回的正确结果，那么就不需要使用 return 了；和第一条规则一样，这条规律也能帮助我们简化代码。 Just \"move on up\" &gt;&gt;= return -- 可以不需要 return (m &gt;&gt;= f) &gt;&gt;= g == m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)当我们用 &gt;&gt;= 把一串 monadic function 串在一起，他们的先后顺序不应该影响结果。而这不就是结合律吗？我们可以把那些子action提取出来组合成一个新action。 (&lt;=&lt;) 可以用来合成两个 monadic functions, 类似于普通函数结合(.)， 而(&gt;=&gt;) 表示结合顺序相反。 (&lt;=&lt;) :: (Monad m) =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)f &lt;=&lt; g = (\\x -&gt; g x &gt;&gt;= f)-- 普通函数结合(.)let f = (+1) . (*100)f 4&gt; 401-- 合成monadic functions (&lt;=&lt;)let g = (\\x -&gt; return (x+1)) &lt;=&lt; (\\x -&gt; return (x*100))Just 4 &gt;&gt;= g&gt; Just 401-- 也可以将 monadic 函数用foldr,id 和(.)合成 let f = foldr (.) id [(+1),(*100),(+1)]f 1&gt; 201 Monad 的 (-&gt;) r 形态(-&gt;) r 不只是一个 functor 和 applicative functor，同时也是一个 monad。 每一个 monad 都是个 applicative functor，而每一个 applicative functor也都是一个 functor。尽管 moand 有 functor 跟 applicative functor 的性质，但他们不见得有 Functor 跟 Applicative 的 instance 定义。 instance Monad ((-&gt;) r) where return x = \\_ -&gt; x h &gt;&gt;= f = \\w -&gt; f (h w) w Monad 辅助函数带下划线函数等价于不带下划线的函数, 只是不返回值 &gt;&gt;= :: m a -&gt; (a -&gt; m b) -&gt; m b=&lt;&lt; :: (a -&gt; m b) -&gt; m a -&gt; m bform :: t a -&gt; (a -&gt; m b) -&gt; m (t b)form_ :: t a -&gt; (a -&gt; m b) -&gt; m ()mapM :: (a -&gt; m b) -&gt; t a -&gt; m (t b)mapM_ :: (a -&gt; m b) -&gt; t a -&gt; m ()filterM :: (a -&gt; m Bool) -&gt; [a] -&gt; m [a]foldM :: (b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m bsequence :: t (m a) -&gt; m (t a)sequence_ :: t (m a) -&gt; m ()liftM :: (a1 -&gt; r) -&gt; m a1 -&gt; m rwhen :: Bool -&gt; f () -&gt; f ()join :: m (m a) -&gt; m a 其中在 IO 中经常用到的一些函数 sequence sequence 接受一串 I/O action，并回传一个会依序执行他们的 I/O action。运算的结果是包在一个 I/O action 的一连串 I/O action 的运算结果。 main = do a &lt;- getLine b &lt;- getLine c &lt;- getLine print [a,b,c] 其实可以写成 main = do rs &lt;- sequence [getLine, getLine, getLine] print rs 一个常见的使用方式是我们将 **print** 或 **putStrLn** 之类的函数 map 到串列上。 sequence (map print [1,2,3,4,5])12345[(),(),(),(),()] mapM 跟 mapM_由于对一个串列 map 一个回传 I/O action 的函数，然后再 sequence 这个动作太常用了。所以函式库中提供了 mapM 跟 mapM_。mapM 接受一个函数跟一个串列，将对串列用函数 map 然后 sequence 结果。mapM_ 也作同样的事，只是他把运算的结果丢掉而已。在我们不关心 I/O action 结果的情况下，mapM_ 是最常被使用的。 mapM print [1,2,3]123[(),(),()]mapM_ print [1,2,3]123 form 和 form_ 与 mapM 和 mapM_ 类似，不过只是把列表参数提前。 还有一些是在 monad 中定义，且等价于 functor 或 applicative functor 中所具有的函数。 liftM liftM 跟 fmap 等价, 也有 liftM3，liftM4 跟 liftM5 liftM :: (Monad m) =&gt; (a -&gt; b) -&gt; m a -&gt; m bliftM f m = m &gt;&gt;= (\\x -&gt; return (f x))liftM (*2) [1,2]&gt; [2,4] ap ap 基本上就是 &lt;*&gt;，只是他限制在 Monad 上而不是 Applicative 上。 ap :: (Monad m) =&gt; m (a -&gt; b) -&gt; m a -&gt; m bap mf m = do f &lt;- mf x &lt;- m return (f x)ap [(*2)] [1,2,3]&gt; [2,4,6] join m &gt;&gt;= f 永远等价于 join (fmap f m) 这性质非常有用 join :: (Monad m) =&gt; m (m a) -&gt; m ajoin (Just (Just 9))&gt; Just 9join [[1,2,3],[4,5,6]] -- 对于 list 而言 join 不过就是 concat&gt; [1,2,3,4,5,6] filterM filterM，除了能做 filter 的动作，同时还能保有 monadic context。 filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]filterM (\\x -&gt; return (x &gt; 2)) [1,2,3,4]&gt; [3,4] foldM foldl 的 monadic 的版本叫做 foldM foldM :: (Monad m) =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m afoldM (\\x y -&gt; return (x + y)) 0 [1,2,3]&gt; 6","tags":[{"name":"haskell","slug":"haskell","permalink":"https://edwardzhong.github.io/tags/haskell/"}]},{"title":"Haskell学习-functor","date":"2018-08-15T13:27:15.000Z","path":"2018/08/15/haskellc/","text":"什么是Functorfunctor 就是可以执行map操作的对象，functor就像是附加了语义的表达式，可以用盒子进行比喻。functor 的定义可以这样理解：给出a映射到b的函数和装了a的盒子，结果会返回装了b的盒子。fmap 可以看作是一个接受一个function 和一个 functor 的函数，它把function 应用到 functor 的每一个元素（映射）。 -- Functor的定义class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 某个类型要能进行映射操作(map over)，就必须继承Functor基类，并实现其中的fmap函数。我们来看一下几种默认的Functor形态： 列表list，非常好理解，操作列表我们一般使用map函数，它其实就是fmap针对列表的一个具体实例，在list中它们是等价的。 -- 作为functor 的定义：instance Functor [] where fmap = map-- 实例fmap (*2) [1,2,3]&gt; [2,4,6] Maybe，它是haskell中使用很广泛的数据类型，它有 Just 值 和 Nothing 两种情况，分别用于表示成功和失败的情况。 -- Maybe 的 functor 定义：instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing-- 实例fmap (*2) (Just 1)&gt; Just 2fmap (*2) (Nothing)&gt; Nothing IO，输入与输出，比如读取键盘输入，打印字符串等 -- IO 的 Functor 定义instance Functor IO where fmap f action = do result &lt;- action return (f result)-- 实例fmap (\"hello! \"++) getLinejeff -- 输入名字，打印时添加“hello”&gt; \"hello! jeff\" Functor的 (-&gt;) r 形态(-&gt;) r 其实表示的是函数结合，也就是等价于 (.) -- 下面两个定义是等价的，也就是 (-&gt;) r 形式下的 Functor 其实等价于 结合律instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x))instance Functor ((-&gt;) r) where fmap = (.)-- 实例fmap (*3) (+100) 1&gt; 303(*3) . (+100) $ 1&gt; 303 functor law如果某个类型遵守这两个定律，那么它与其他Functor对于映射方面就具有相同的性质。 fmap id = id如果我们对 functor 做 map id，那得到的新的 functor 应该要跟原来的一样 fmap id (Just 3) &gt; Just 3id (Just 3) &gt; Just 3 fmap (f . g) = fmap f . fmap g 也就是 functor 是能应用于函数结合的。 Applicative Functor为什么需要 Applicative Functor，什么情况下使用它。从Functor定义我们知道，fmap函数只能映射单个盒子，但假设需要映射两个三个，甚至是更多的盒子呢？或者是要处理返回值是函数的盒子呢？而这就是Applicative Functor 要处理的情况。 Applicative Functor* 可以看作是Functor的增加版，从定义可知，它主要包括pure 和 &lt;\\&gt;两个函数。 -- Applicative Functor 定义class (Functor f) =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b pure :: a -&gt; f a 意思就是把普通值放到默认的context(语义)下。比如如果是list，那么它代表的就是[ ] ，如果是Maybe，那么它就是 Just 值 / Nothing。 (&lt;*&gt;) 接受一个装有函数的 functor 跟另一个 functor, 非常类似于fmap，它就像加强版的 fmap。以applicative style 的方式来使用 applicative functors。像是 pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; … 这个函数可以吃任意多的参数。 -- 与fmap类型的对比，可以看出函数 a -&gt; b 被装进了盒子 f 中(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f bfmap :: (a -&gt; b) -&gt; f a -&gt; f b-- &lt;*&gt; 是左结合的，因此以下两个表达式是相等的pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5 (pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5。 (&lt;$&gt;) 是applicative functor 中另一个很常用的符号，它其实就是中缀版的fmap。因为结合fmap写applicative functor更加方便。 (&lt;$&gt;) :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f bf &lt;$&gt; x = fmap f x-- 用&lt;*&gt;实现相同的功能pure f &lt;*&gt; x = fmap f x 接着看一下几个默认的 applicative functor，继承Applicative，必须实现 pure 和 (&lt;*&gt;) 函数 Maybe 类型 -- Maybe 的 Applicative 定义：instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something-- 实例pure (+3) &lt;*&gt; Just 9&gt; Just 12pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5&gt; Just 8 列表list 也是 applicative functor，从定义可以看出使用list的Applicative style完全可以实现 list comprehension 的功能。所以 Applicative style 对于 list 而言是取代某些类型的 list comprehension 的好方式。 -- list 的定义instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]-- 实例[(+3),(*2)] &lt;*&gt; [1,2]&gt; [4,5,2,4]--下面表达式具有相同的功能(*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11] -- Applicative style[ x * y | x &lt;- [2,5,10], y &lt;- [8,10,11]] -- list comprehension&gt; [16,20,22,40,50,55,80,100,110] IO ，下面的IO的实例，可以把 getLine 看做是一个去真实世界中拿取字串的盒子, 而 applicative functor 表达式会创造一个比较大的盒子，这个大盒子会派两个盒子去终端拿取字串，并把结果串接起来放进自己的盒子中。 --IO 的 Applicative instanceinstance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x)-- 实例 将输入的两个字符串合并(++) &lt;$&gt; getLine &lt;*&gt; getLineaabb&gt; \"aabb\" Applicative Functor 的 (-&gt;) r 形态 (-&gt;) r 形态定义 instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) 用 pure 将一个值包成 applicative functor 的时候，他产生的结果永远都会是那个值 将两个 applicative functor 喂给 &lt;*&gt; 可以产生一个新的 applicative functor 接着综合使用上面的知识，来看一下实际应用applicative的几种方式。相比起functor，applicative functor要更强大和灵活。 -- 左结合形式, 第一项必须为含有函数的functor,右边全部为functorpure (\\x y z -&gt; x+ y +z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5&gt; Just 12[(+3),(*2)] &lt;*&gt; [1,2]&gt; [4,5,2,4]-- fmap(&lt;$&gt;) 形式,第一项为普通函数,右边都为functor(+) &lt;$&gt; Just 1 &lt;*&gt; Just 2&gt; Just 3(\\x y z -&gt; x + y +z) &lt;$&gt; [1,2] &lt;*&gt; [2,3] &lt;*&gt; [4,5]&gt; [7,8,8,9,8,9,9,10]-- (&lt;$&gt;) (-&gt;) r 形式,全部为普通函数,用单个参数调用执行(\\x y z -&gt; [x,y,z]) &lt;$&gt; (3+) &lt;*&gt; (*100) &lt;*&gt; (`div`2) $ 2&gt; [5,200,1] Applicative Functor 辅助函数 liftA2只是applicative的套用函数而已，当然还有3个参数的版本 liftA3，而 liftA 则等价于 fmap -- 与applicative 的等价形式liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b-- 以下表达式功能一致liftA2 (:) (Just 3) (Just [4])(:) &lt;$&gt; Just 3 &lt;*&gt; Just [4]pure (:) &lt;*&gt; Just 3 &lt;*&gt; Just [4]&gt; Just [3,4] sequenceA当套用在函数上时，sequenceA 接受装有一堆函数的list，并回传一个回传list的函数。当我们有一串函数，想要将相同输入都喂给它们并查看结果的时候，sequenceA非常好用。 当使用在 I/O action 上的时候，sequenceA 跟 sequence 是等价的。他接受一串 I/O action 并回传一个 I/O action，这个 I/O action 会计算 list 中的每一个 I/O action，并把结果放在一个 list 中 -- 以下是两种实现sequenceA功能一致的函数sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs sequenceA = foldr (liftA2 (:)) (pure []) sequenceA [Just 3, Just 2, Just 1] &gt; Just [3,2,1] -- 将list组合成所有可能的组合sequenceA [[1,2,3],[4,5,6]] &gt; [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] sequenceA [(&gt;4),(&lt;10),odd] 7 map (\\f -&gt; f 7) [(&gt;4),(&lt;10),odd] &gt; [True,True,True] -- and接受一串Bool，并在所有值都为True时才返回True and $ sequenceA [(&gt;4),(&lt;10),odd] 7 and $ map (\\f -&gt; f 7) [(&gt;4),(&lt;10),odd] &gt; True","tags":[{"name":"haskell","slug":"haskell","permalink":"https://edwardzhong.github.io/tags/haskell/"}]},{"title":"Haskell学习-高阶函数","date":"2018-08-08T15:55:13.000Z","path":"2018/08/08/haskellb/","text":"高阶函数(higher-order function)就是指可以操作函数的函数，即函数可以作为参数，也可以作为返回结果。有了这两个特性，haskell可以实现许多神奇的效果。 柯里化（Currying）在haskell中所有的算术运算符都是函数(包括大小于等于关系符等)，而它们的快捷方式都可以省略操作数（参数）。 (+) 1 2 -- (+) 是需要两个操作数的函数&gt; 3(+1) 2 -- (+1) 是需要左操作数的函数&gt; 3(3*) 3 -- (3*) 是需要右操作数的函数&gt; 6map (*2) [1,2,3] -- map所有元素 *2 的操作&gt; [2,4,6]filter (&gt;3) [2,3,4,5] -- 过滤 &gt;3的元素&gt; [4,5] haskell中的函数默认都是前缀模式的，也就是：函数名 参数1 参数2 … 。但几乎所有拥有两个参数的函数都有中缀模式，只需要将函数名反引号包起来就可以了：参数1 `函数名` 参数2。因为在某些情况下中缀函数可读性更好，更符合人们的理解习惯。 5 `div` 3 -- 求余数&gt; 19 `mod` 7 -- 求模&gt; 2'f' `elem` ['a' .. 'z'] -- 是否包含'f'&gt; True 本质上，Haskell 的所有函数都只有一个参数，那么我们多个参数的函数又是怎么回事? 那是因为所有多个参数的函数都是 Curried functions。其实从上面的算术运算函数例子，我们大概就能猜出来了。接着用实例来进验证一下： moreThen4 = max 4 -- 最小为4的函数:t max -- 需要两个可比较的参数的函数max :: Ord a =&gt; a -&gt; a -&gt; a:t moreThen4 -- 需要一个可比较的数字的函数&gt; moreThen4 :: (Ord a, Num a) =&gt; a -&gt; a 通过查看函数的类型可发现，两个参数的 max 函数其实可以写成 (max x) y 。moreThen4 其实就是 max 函数以不全的参数调用后，再创建了一个新的返回函数，该函数是单个参数形式的。 这和 JavaScript 里用 闭包 的特性返回函数来实现 柯里化 是一样一样的。但在函数式语言当中，函数本来就是一等公民，这事情简直就是和吃饭睡觉一样地自然而然。 我们看起来很怪的函数类型描述 Num a =&gt; a -&gt; a -&gt; a ，这下也能理解通了。它表示的是函数取一个数字参数a后，会返回一个需要a类型参数的函数 (Num a) =&gt; a -&gt; a ，最后的这个函数再取一个参数a后 ，最终就会回传a类型的结果。利用柯里化去掉多余参数后的函数更加简洁： sum' xs = foldl (+) 0 xssum' = foldl (+) 0 -- 去掉xs后maxNum x = foldr max 0 xmaxNum = foldr max 0 -- 去掉x后 Lambda表达式lambda 已经不是什么新鲜事物了， 早在 .NET 4.0时代 C# 就已经引入了 lambda，JavaScript 也在 ES6 中引入。 编写匿名的函数，这样就不需要费力的创建命名函数。因为匿名函数从 lambda 演算而来，所以匿名函数通常也被称为 lambda 函数。 在 Haskell 中，匿名函数以反斜杠符号 \\ 开始，后跟函数的参数（可以包含模式），而函数体定义在 -&gt; 符号之后。lambda 函数的定义只能有一条语句，同时无法为一个参数设置多个模式，如 [] 和 (x:xs)。 plusOne = \\x -&gt; x+1checkZero = \\x -&gt; if x &gt; 0 then \"大于0\" else if x&lt;0 then \"小于0\" else \"等于0\" 折叠函数遍历列表是一个非常普遍的需求，用折叠函数代替显式递归进行遍历明显更加易于理解和实现。其中 foldl 是左结合，foldr 是右结合，一般右折叠效率比较高，同时 foldr 也可以用于无限列表，所以应尽量使用 foldr。 折叠函数调用格式: fold 处理函数 初始值(累加值) 需要折叠的列表 另外还提供了和 foldl/foldr 相似的 foldl1/foldr1，它们默认使用列表第一项为初始值，所以可以省略初始值。 map' :: Foldable t1 =&gt; (t2 -&gt; a) -&gt; t1 t2 -&gt; [a]map' f = foldr (\\x acc -&gt; f x:acc) []filter' :: Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; [a]filter' f = foldr (\\x acc -&gt; if f x then x:acc else acc) []elem' :: (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Boolelem' y = foldl (\\acc x -&gt; if y==x then True else acc) Falseand' :: Foldable t =&gt; t Bool -&gt; Booland' = foldr1 (\\x y-&gt;if not y then False else if not x then False else True)-- 执行map' (*2) [1,2]&gt; [2,4]filter (&gt;2) [1,2,3,4]&gt; [3,4]elem' 1 [1,2,3]&gt; Trueand' [True,False,True]&gt; False 与 foldl 和 foldr 相似的scanl 和 scanr，它们会记录下累加值的所有状态到一个 List。也有 scanl1 和 scanr1。 scanl (+) 0 [3,5,2,1] &gt; [0,3,8,10,11] scanr (+) 0 [3,5,2,1] &gt; [11,8,3,1,0] 还有 foldl’ 和 foldl1’ 是它们各自惰性实现的严格版本。在用 fold 处理较大的 List 时，经常会遇到堆栈溢出的问题。而这罪魁祸首就是 fold 的惰性: 在执行 fold 时，累加器的值并不会被立即更新，而是做一个”在必要时会取得所需的结果”的承诺。每过一遍累加器，这一行为就重复一次。而所有的这堆”承诺”最终就会塞满你的堆栈。严格的 fold 就不会有这一问题，它们不会作”承诺”，而是直接计算中间值的结果并继续执行下去。如果用惰性 fold 时经常遇到溢出错误，就应换用它们的严格版。 函数组合（$) 叫作函数呼叫符，它的优先级最低。 f $ g x =&gt; f (g x)-- 取&gt;2的列表长度length (filter (&gt;2) [1,2,3,4])length $ filter (&gt;2) [1,2,3,4] -- 降低优先级消除括号&gt; 2 (.) 函数复合运算符，它可以组合函数，并产生新函数，然后传递给其它函数。当然我们可以用 lambda 实现，但大多数情况下，使用函数组合无疑更清楚。 (f . g) x =&gt; f(g x) -- 验证字符串是否为数字not ( and ( map isDigit $ \"12as\"))not . and . map isDigit $ \"12as\" -- 使用组合消除括号&gt; True 这两个运算符是消除括号的神器，有了它们，代码的可读性大大提高。我们再利用haskell强大的模式匹配能力，改变函数运行方向，改造后的效果类似于unix/linux的管道，把上面两个表达式重写。现在连 ($) (.) 都不需要了，吊炸天了，有木有😊 -- 让参数和结果首尾相连，就是这么简单x |&gt; f = f x-- unix/linux 中的管道？[1,2,3,4] |&gt; filter (&gt;2) |&gt;length&gt; 2\"12as\" |&gt; map isDigit |&gt; and |&gt; not&gt; True 参考资料《HASKELL 趣学指南》《Real World Haskell》","tags":[{"name":"haskell","slug":"haskell","permalink":"https://edwardzhong.github.io/tags/haskell/"}]},{"title":"Haskell学习-函数式编程初探","date":"2018-08-07T13:49:46.000Z","path":"2018/08/07/haskella/","text":"为什么要学习函数式编程？为什么要学习Haskell？ .net到前端，C#和JavaScript对我来说如果谈不上精通，最起码也算是到了非常熟悉的程度。这两门语言就像是我的盾牌和宝剑,给我保驾护航,开山劈石,伴随着我不断成长。同时C#和JavaScript它们本身也在不断地进化，不断出现越来越多方便的语法糖，但追根到底很多都是从函数式语言汲取的精华。比如高阶函数，lambada表达式，柯里化等。 于是从探险的角度，以好奇的心态开始学习函数式语言，探索这个宝库，拾取可供临摹的珍宝。最起码它能让你多一个不同的角度看待编程语言,影响你的思考方式。 学习的对象当然选择函数式语言的集大成者-Haskell。 什么是Haskell和函数式编程Haskell 是一门纯粹函数式的语言。 函数式编程是面向数学的抽象，将计算描述为一种表达式求值。命令式编程是关于解决问题的步骤，函数式编程是关于数据的映射。在纯粹函数式程式语言中，你不是像命令式语言那样命令计算机「要做什么」，而是通过用函数来描述出问题「是什么」，也就是所谓范畴论中的映射关系。函数式语言有以下的特性： 函数是一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合 变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。 函数式语言的条件语句，循环语句等也不是命令式编程语言中的控制语句，而是函数的语法糖 惰性求值 抽象数据类型 灵活的多态 高阶函数（Higher-order function） 柯里化（Currying） 闭包（Closure） 函数式编程的优点函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。 函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。 由于（多个线程之间）不共享状态，不会造成资源争用(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发，能够更好地利用多个处理器（核）提供的并行处理能力。 Haskell基本语法 变量和函数一起介绍是因为在我看来,haskell中变量和函数是没有区别的。它们都是表达式，根据表达式的不同形式，分别对应到命令式语言中变量和函数的概念。 而且 haskell 中 变量 赋值后就是不可变的，该 变量 就等于被赋予的值，与命令式语言中 变量 是内存地址的引用是完全不同的概念。 硬要对应的话它更像是 C# 中的不可变量 const 或 static readonly 。你能从下面代码中区分出哪些是变量,哪些是函数吗? a = 1 -- 变量arr = map (*2) [1,2,3] -- 变量还是函数?maxNum = foldr max 0 -- 函数--执行a &gt; 1arr&gt; [2,4,6]maxNum [3,5,1]&gt; 5 定义函数: 函数名 参数 = 代码调用函数: 函数名 参数调用函数不用大括号( )，注意的是函数首字母不能大写。 还有maxNum看不到形式参数是因为柯里化可以去掉参数，后面会介绍。 if else haskell中 if else 表达式中的 else 部分不能省略，也就是你不能只有 if 部分 -- 等于小于大于0 分别对应 0,-1,1sign x = if x == 0 then 0 else if x &lt; 0 then -1 else 1 case of case of 表达式,与其他语言的switch case 类似。 -- 求出列表第一项head' xs = case xs of [] -&gt; \"No head for empty lists!\" (x:_) -&gt; show x-- 执行head' \"hello\"&gt;'h'head' [3,2,1]&gt; 3 函数模式匹配函数模式匹配的方式定义 head’，以及定义阶乘函数 factorial，它本质上就是 case of 的语法糖。函数模式匹配，减少了一大堆类似 if else 的判断逻辑，是我最喜欢的特性之一。 -- 求出列表第一项head' [] = \"No head for empty lists!\"head' (x:_) = show x-- 阶乘factorial 0 = 1factorial n = n * factorial (n - 1)--执行head' [3,2,1]&gt; 3factorial 5&gt; 120 guards 和 where guards,类似 if else 表达式，但可读性更强，where语句定义的是局部变量表达式,它只能放在语句尾部，guards同样也是非常好的定义方式。 bmiTell weight height | bmi &lt;= 18.5 = \"You're underweight，you emo，you!\" | bmi &lt;= 25.0 = \"You're supposedly normal. Pffft，I bet you're ugly!\" | bmi &lt;= 30.0 = \"You're fat! Lose some weight，fatty!\" | otherwise = \"You're a whale，congratulations!\" where bmi = weight / height ^ 2 let in let in 表达式，let 中绑定的名字仅对 in 部分可见。 -- 圆柱体面积cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea递归 我们使用递归来实现斐波那契数列和快速排序，haskell写的快速排序是我见过的最容易理解的版本了，专门为解决数学问题而生的 haskell 在解决算法和数据结构方面果然是不同凡响。 -- 斐波那契数列fab 1 = 1fab 2 = 1fab n = fab (n-1) + fab (n-2)-- 快速排序quicksort [] = []quicksort (x:xs) = let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] biggerSorted = quicksort [a | a &lt;- xs, a &gt; x] in smallerSorted ++ [x] ++ biggerSorted 尾递归实现常用的map和filter函数 [] 表示空列表 _ 匹配的是任意值。 (x:xs) 非常有用的列表匹配模式，x表示第一项，xs表示除去第一项之后的部分。使用(x:xs)可以方便的实现尾递归 -- mapmap' f [] = []map' f (x:xs) = f x : map' f xs-- filterfilter' _ []= [] -- _代表任意值filter' f (x:xs) | f x = x : filter' f xs | otherwise = filter' f xs 数据类型了解了haskell基本语法后，我们再进一步了解haskell基本数据类型 :type 获取任何表达式的类型，可以用简写形式 :t 基本数据类型 Int 表示整数 Integer 也是整数，但表示的是无界的，所以可以表示非常大的数 Float 表示单精度的浮点数 Double 表示双精度的浮点数 Bool 表示布尔值，它只有两种值：True 和 False Char 表示一个字符。一个字符由单引号括起，一组字符的 List 即为字符串 List 列表中所有的项都必须是同一类型。 Tuple 的类型取决于它的长度及其项的类型。 :t 1 -- Number1 :: Num p =&gt; p:t 1::Integer1::Integer :: Integer:t 1::Float1::Float :: Float:t False -- BoolFalse :: Bool:t 'c' --字符'c' :: Char:t \"hello\" -- 字符串\"hello\" :: [Char]:t [1,2,3] -- 列表list[1,2,3] :: Num a =&gt; [a]:t [(\"hi\",1),(\"there\",2)] -- Tuple[(\"hi\",1),(\"there\",2)] :: Num b =&gt; [([Char], b)] 1::Integer 表示直接指定类型，如果不指定编译器会自动推导出类型，数字类型会推导出Number类型，它包括Int，Integer，Float，Double [Char] 和 String 表示的都是字符串类型 [1,2,3] :: Num a =&gt; [a] 列表中的 a 表示任意类型，意思你可以是Bool，Stirng，Int等等 [(“hi”,1),(“there”,2)] 这就是Tuple类型，列表里面的每个项都用 () 包起来，其中的每个项的元素数据类型必须相同，每个tuple中元素个数必须相等，但是每个tuple中的项可以不同类型，比如 (“hi”,1) 中一个是字符串，一个是Int。 函数也有类型，定义函数的时候，加上参数的类型和输出类型是好习惯。 &amp;&amp;、||、not 表示与或非逻辑 == 表示等于 /= 表示不等于 ++ 连接列表，相当于concat a, b这种类型参数，表示可以传入任何类型。 (Num a, Num p, Ord a) =&gt; a -&gt; p 在 =&gt; 之前表示的是类型约束，这里的 a 限定只能是 Num 类型和 Ord 类型。Num表示数字类型，Ord则表示可比较大小的型别，包含如下三种型别之一：GT, LT, EQ。 :t head -- 取列表第一项的函数head :: [a] -&gt; a:t sign -- sign函数sign :: (Num a, Num p, Ord a) =&gt; a -&gt; p:t (==) -- 是否相等(==) :: Eq a =&gt; a -&gt; a -&gt; Bool:t (++) -- 列表连接函数(++) :: [a] -&gt; [a] -&gt; [a] -- 执行 sign 2&gt; 1head [3,2,1]&gt; 3\"abc\" == \"bbc\"&gt; False\"hello \" ++ \"world\"&gt; \"hello world\" List 和 List comprehension 列表常用的函数 null 列表是否为空 length 返回列表长度 head 返回列表第一个元素 tail 返回列表除第一个元素以后的所有元素 last 返回列表最后一个元素 init 返回列表除最后一个元素之前的所有元素 take n 返回列表前n个元素 drop n 丢弃列表前n个元素 maximum 返回最大的元素 minimum 返回最小的元素 sum 返回元素的和 elem 元素是否包含于列表 list range 方便的range，尾递归加上list range，你真的还需要命令式语言中的循环语句吗？ [1..10] -- 1到10的列表&gt; [1,2,3,4,5,6,7,8,9,10]['a'..'z'] -- a到z的字母字符串&gt; \"abcdefghijklmnopqrstuvwxyz\"take 10 [1,3..] -- 前10个奇数&gt; [1,3,5,7,9,11,13,15,17,19]take 10 (cycle[1,2,3]) -- 取前10的[1,2,3]序列&gt; [1,2,3,1,2,3,1,2,3,1]take 5 $ repeat 3 -- 取前5项的3序列&gt; [3,3,3,3,3]replicate 5 10 -- 相比 take repeat更方便的用法&gt; [10,10,10,10,10] list comprehensionlist comprehension 相当于map 和 filter的函数的增强版, | 之前等于map, | 之后等于filter, 尤其在多限制条件和同时实现map,filter功能时更加明显。是个非常强大和有用的特性，完全可以替代列表的 map 和 filter 函数。 list comprehension 其实是由 monad 或 applicative functor 生成的语法糖。 [x*2 | x &lt;- [1..10], x*2 &gt;= 12] -- 取乘以 2 后大于等于 12 的元素, 等于map结合filter&gt; [12,14,16,18,20][if x `mod` 2 == 0 then \"even\" else \"odd\" | x &lt;- [1..10]] -- 偶数转换为even,基数为odd, 等于map&gt; [\"odd\",\"even\",\"odd\",\"even\",\"odd\",\"even\",\"odd\",\"even\",\"odd\",\"even\"][ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19] -- 取除了13、15、19之外的元素，多个限制条件,等于filter&gt; [10,11,12,14,16,17,18,20][ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]] -- 求两个列表所有可能的组合&gt; [16,20,22,40,50,55,80,100,110]-- 嵌套的列表, 在不拆开它的前提下除去其中的所有奇数let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]][ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]&gt; [[2,2,4],[2,4,6,8],[2,4,2,6,2,6]] --取得所有三边长度皆为整数且小于等于 10，周长为 24 的直角三角形[ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]&gt; [(6,8,10)]参考资料《HASKELL 趣学指南》《Real World Haskell》","tags":[{"name":"haskell","slug":"haskell","permalink":"https://edwardzhong.github.io/tags/haskell/"}]},{"title":"WebGL展示3D房屋内景","date":"2018-05-30T16:44:31.000Z","path":"2018/05/31/webglroom3d/","text":"由于生活和工作上的原因,从年前开始一直到处奔波,没有太多的时间去关注和学习WebGL图形学相关的技术, 不过陆陆续续都有学习使用blender进行3D建模, 而这篇文章涉及到的房屋内景3D建模就是我这段时间以来的学习成果,现在展示出来. 文件模型比较大,页面加载比较慢,请耐心等候, 实例: BlenderBlender是开源的建模和动画制作软件,功能虽然没有3dmax和maya强大,但它精简,易学易用,而且还是开源的, 非常适合像我这样的入门级新手.如果你也想做模型和特效,创建自己心目中的3D世界,Blender值得你去尝试.入门教程推荐台湾大神的blender教程全集 模型文件在blender制作好模型之后,接着就是导出obj文件,接着就是使用js读取obj文件,之后就开始涉及到WebGL,具体的步骤可以参考我之前的文章 WebGL学习(3) - 3D模型 着色器着色器代码实现的是WebGL最基本的功能,使用了一个平行光源,光照部分有环境光,漫反射,冯氏高光镜面反射.代码详情如下: 顶点着色器 attribute vec4 a_position;//顶点位置attribute vec4 a_color;//顶点颜色attribute vec4 a_scolor;//顶点高光颜色attribute vec4 a_normal;//法向量uniform mat4 u_MvpMatrix;//mvp矩阵uniform mat4 u_ModelMatrix;//模型矩阵uniform mat4 u_NormalMatrix;varying vec4 v_Color;varying vec4 v_Scolor;varying vec3 v_Normal;varying vec3 v_Position;void main() &#123; gl_Position = u_MvpMatrix * a_position; // 计算顶点在世界坐标系的位置，以便计算点光源在顶点处点位置 v_Position = vec3(u_ModelMatrix * a_position); // 计算变换后的法向量 v_Normal = vec3(u_NormalMatrix * a_normal); v_Color = a_color; v_Scolor = a_scolor;&#125; 片段着色器 #ifdef GL_ESprecision mediump float;#endifuniform vec3 u_LightPosition;//光源位置uniform vec3 u_diffuseColor;//漫反射光颜色uniform vec3 u_AmbientColor;//环境光颜色uniform vec3 u_specularColor;//镜面反射光颜色uniform float u_Shininess;// 镜面反射光泽度uniform vec3 u_viewPosition;// 视点位置varying vec3 v_Normal;//法向量varying vec3 v_Position;//顶点位置varying vec4 v_Color;//顶点颜色varying vec4 v_Scolor;//顶点高光颜色void main() &#123; vec3 normal = normalize(v_Normal); // 平行光 vec3 lightDirection = normalize(u_LightPosition); // 计算光线方向和法向量点积 float nDotL = max(dot(lightDirection, normal), 0.0); // 漫反射光亮度 vec3 diffuse = u_diffuseColor * nDotL * v_Color.rgb; // 环境光亮度 vec3 ambient = u_AmbientColor * v_Color.rgb; // gl_FragColor = vec4(diffuse + ambient, v_Color.a); // 观察方向的单位向量V vec3 eyeDirection = normalize(u_viewPosition - v_Position.xyz);// 反射方向 // 反射方向 vec3 reflectionDirection = reflect(-lightDirection, normal); // 镜面反射亮度权重 float specularWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), u_Shininess); vec3 specular = u_specularColor.rgb * specularWeighting; gl_FragColor = vec4(ambient + diffuse + specular, v_Color.a);&#125; 模型变换模型变换同样可参考我之前的文章WebGL多模型光照综合实例 总结这个实例最困难和花费时间最多的其实是3D建模部分,而开发所使用到的WebGL知识点由于比较基础,反而没多大难度.总之要做出酷炫逼真的特效和模型,还得继续深入学习3D建模.","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"2018春夏火车之旅","date":"2018-05-09T07:38:44.000Z","path":"2018/05/09/train/","text":"&emsp;&emsp;尼泊尔ACT之旅后,再次回到深圳,处理了一下个人事务.4月份开始一路搭火车在大江南北游历,顺着铁道线一直向着远方进发,主要是在省会和著名城市呆几天了解当地人文,饮食,气候,历史等.而这篇文章就是小小地记录下一路上的所看所闻,所思所想. 西安&emsp;&emsp;西安是我非常喜欢的城市,因为城市非常有历史感,同时还有数不清的美食.西安给我另一个很好的印象是,在街上每隔一段距离就有厕所,而且维护得很好,最起码在我停留过的很多国内城市里面,西安是做得最好的.&emsp;&emsp;西安城最中心是钟楼,延伸出的东西南北大街的方位丝毫不乱,外面是厚重的城墙,城墙外围绕着护城河,完全是古城池的典型.还记得初次来西安时,那厚达12米的城墙给我带来的震撼; 西安古城墙还只是明朝的秦王府,只是诸侯王的城池,最让人痛心的是南京和北京的帝都古城墙,如果能完整能保存下来,那将会是多么令人动容的景象.&emsp;&emsp;我最想说的是西安的面食,既花样繁多又非常美味,在西安天天吃面,完全吃上瘾了.一开始我也是分不清西安面的名称,后来才慢慢了解,从面的做法上可以分为拌面,油泼,汤面,蘸水面等等;从面的大小形状可以分为裤带面,扯面,biangbiang面,棍棍面,饸饹面;还可以从材质上分为荞麦,菠菜等等,真的是五花八门. 我最喜欢的类型是裤带面,扯面,biangbiang面这种宽宽的面,面和臊子混合均匀后,就着大蒜,吃起来那叫一个爽.就是在这里养成了就着生蒜头吃面的重口味习惯.&emsp;&emsp;还有各种夹馍也是好吃的很,肉夹馍,菜夹馍,牛肉夹馍.但网红小吃-蛋菜夹馍,我却喜欢不起来,夹馍很硬,里面的菜又干又咸.凉皮,擀面皮,大米面皮,热面皮也是妙极了,其中汉中热面皮有点像广东的肠粉,也是我的最爱之一.(夕阳中的鼓楼) (钟楼夜景) (鼓楼夜景1) (鼓楼夜景2) (永宁门) (长乐门) (大雁塔) (小雁塔) 太原&emsp;&emsp;接着来到三晋大地的首府-太原,太原有点破旧,发展得不是很好,中心是五一广场,城区也没有什么好看的景点,永祚寺(双塔寺)可以看一下,这会儿还在整修,在这里爬上了古塔的最高层,第一次爬这么古老的石塔.山西的景点非常分散,寺庙和古塔在全国也是最多的了,尤其是北部的大同,五台山等地.最出名的是悬空寺,应县木塔,云冈石窟等.而南部最出名的是古城,平遥古城,乔家大院等等.以后有时间一定要来一次山西全境游.&emsp;&emsp;山西博物馆很不错,这里保留了很多金辽时代的文物,里面各式各样的建筑,佛塔模型,让人眼前一亮.而山西因为表里山河的地形,长期以来一直能避开战乱,是目前全国唯一能看到唐朝时期建筑的地方.其中介绍春秋时代历史的馆,名字叫《晋国霸业》,非常霸气,很喜欢这个名字.&emsp;&emsp;而在太原吃到的面食让我有点失望,感觉比西安的面食差远了,在西安吃的刀削面都比太原的好太多了.或许应该去北边的大同才能吃到山西的美味面食.(双塔寺)(双塔寺)(双塔寺) 石家庄&emsp;&emsp;作为沿海省份之一的省会-石家庄,还是比较现代化的,城市规划得也比较好.不过河北知名的景点也主要在北边,同时北边也是河北经济最发达的部分.到时候到北京的时候可以顺道去游一下冀北.&emsp;&emsp;不过河北的博物馆是我参观过的省级博物馆里面最漂亮和规划得最好的.《大汉绝唱——满城汉墓》中的金缕玉衣是最值得一看的文物,是西汉诸侯-中山王刘胜墓出土的,刘胜和他夫人各一件玉衣,真是巧夺天工,穷奢极欲.这个刘胜就是以子孙众多而闻名的,也是三国时代刘备的祖先.《慷慨悲歌——燕赵故事》《战国雄风——古中山国》这两个馆也是喜欢春秋战国历史的我所流连的.(河北博物馆) 郑州&emsp;&emsp;郑州是中部的交通枢纽,但市区真的没啥好逛,二七广场也很一般,同时市容也不是很好.河南博物馆也是做的最差的了,展馆破旧(目前在改建),展出文物不多,同时也不用心,白白浪费了中原地区这么悠久的历史和灿烂的文化.郑州唯一让我服气的是,河南烩面还挺好吃,觉得河南的开封和洛阳才是最值得一去的城市.(二七广场) 武汉&emsp;&emsp;武汉给人的感觉就是大,光一个武昌城就已经够大的了,还要再加上汉口和汉阳,果然是大武汉.我最喜欢的就是长江,宽阔的江面,浩荡的江风,无数座的跨江大桥和轮渡码头,非常符合我印象中长江的想象.还有就是武汉市区分布着大大小小的湖,武汉的面食和小吃也还不错.湖北博物馆也建得很好,值得一去,能看到国宝级文物-越王勾践剑.还有辛亥革命/武昌起义相关的历史遗迹也值得缅怀.&emsp;&emsp;武汉主要的景点:汉口江滩,黄鹤楼,晴川阁都依托着着长江,登高远望一路奔向东海的长江,真是气势非凡.而晚上吹着江风,看着对面繁华的高楼大厦组成的五光十色的江景也是一件幸事.(武汉长江大桥) (长江) (武昌江滩) (鄂军都督府) 长沙&emsp;&emsp;湘江穿城而过的长沙市还是有一些值得游玩的景点:橘子洲头,岳麓书院.湖南博物馆也是重头戏,马王堆汉墓太震撼了,出土的文物非常精美,整个博物馆主要就是围绕着它而建.博物馆内部造型简直就是马王堆汉墓的再现,不过展出的干尸是复制品,但很真实.马王堆汉墓的主人是西汉时期的诸侯-长沙王的丞相利苍及其家属的墓葬.也就是他是比诸侯王要低的等级,但保存完好,文物精美.&emsp;&emsp;至于长沙的美食,臭豆腐还行,糖油粑粑很腻.其他日常的饮食我个人有点承受不了,为什么呢? 因为太辣了,在其他地方,我基本都能适应当地的饮食,比如四川和陕西. 在成都和西安,人们不仅要的是辣,更多的还是辣后面带出来的食物的鲜香,四川的红油和陕西的油泼辣子都是我很喜欢的调料.而对于直接干脆的湖南人来说,他们要的就是火爆的辣味,这点我确实适应不了.(橘子洲头正在修复的毛泽东头像) (岳麓书院) 韶关&emsp;&emsp;在韶关停留,是因为买不到上午到广州的火车票,所以干脆就在我的家乡所在的城市-韶关游览.再次回到母校-韶院回味曾经的校园时光,物是人非,不堪回首,然后再次匆匆离别.(风采楼) 广州&emsp;&emsp;我对省会广州并没有太深的感觉,尽管我很久以前,曾经在广州呆过一段时间,但我这次却是以游人的身份去品味羊城.主要的景点一一游览:红砖厂,黄埔军校,中山纪念堂,光孝寺,珠江新城,越秀公园,广东博物馆,沙面,陈家祠,圣心大教堂. 最喜欢的是明清广府建筑代表-陈家祠,以及天主教哥特式建筑-圣心大教堂.&emsp;&emsp;广州的美食当然非常美味,清淡的口味也非常符合我们广东人,各种点心和小吃当中,肠粉和云吞竹升面是我的最爱.(陈家祠) (陈家祠) (圣心大教堂外观) (圣心大教堂内景) (圣心大教堂漂亮的玻璃花窗) (黄埔军校) (广州塔) (珠江新城) (中山纪念堂) 南宁&emsp;&emsp;广东周边的省份多少都有亲身去过,唯独没有去过广西,这次就踏足八桂大地.我知道沿海和桂东的人文风俗和临近的广东很相似,但作为省会的南宁,本地人大部分竟然是说白话的,倒是出乎我的意料.广西东南部主要人群习俗类似于广东广府人,东北部分布着一部分客家人,类似广东, 果然是”两广一家亲”.而北部和西北一带主要是少数民族和西南官话区.&emsp;&emsp;南宁一样有很多大排档,晚上尤其热闹,生猛海鲜也是他们的最爱,中山路美食街可以去尝试一番,但要吃当地人喜欢的地道美食,水街更值得一去.我最喜欢的当地美食是卷筒粉和生榨米粉,老友粉也还行.卷筒粉有点类似肠粉,非常适合当早餐吃,生榨米粉也很美味,粉饺也还不错,但有点腻.(邕江) 柳州&emsp;&emsp;广西最出名的两大美食IP:桂林米粉和柳州螺蛳粉.如果不是螺蛳粉的缘故,我可能就略过柳州直接去桂林了.说来你可能不信,我之前在深圳住宿地附近有一家很美味的柳州螺蛳粉店,时不时我都要去吃一趟. 我就是冲着去吃一碗最正宗的螺蛳粉才来柳州的,不过柳州除了螺蛳粉外, 还有另一个文化名人,唐宋八大家之一-柳宗元,他曾在柳州上任,深得民心,最终也在柳州病逝.柳宗元在柳州,有种特别般配的感觉.&emsp;&emsp;柳州是一个让我非常惊喜的城市,柳江穿城而过,两岸到处都是怪石嶙峋的陡峭石山,整个城市就沉浸在山水之中.同时它的街道干净整洁,不像南宁那么热闹,不像桂林那样游人如织,似乎只有我一个游客懂得欣赏柳州城.城区里面分布着十几座可以攀登的石山,每个石山就对应着一个公园,我住宿的附近的就有箭盘山,马鞍山,鹅山,鱼峰山,蟠龙山,对喜欢爬山的我来说,简直是完美,况且还能吃到美味的螺蛳粉. 但柳州美食让我印象深刻的是炒螺蛳粉,毕竟干拌和汤的螺蛳粉大家都吃过,炒的估计在外地都没人听说过.&emsp;&emsp;虽说柳州在全国没多大存在感,不过在广西也是能排得上号的,它是广西的交通枢纽和重工业基地,不过改革开放后有些没落.还有柳州的博物馆比在南宁的广西博物馆好多了,其中的《古生物化石馆》非常好,这可让南宁情何以堪啊. 在柳州不方便的一点就是:这里竟然没有共享单车.(箭盘山公园) (鹅山公园) (马鞍山上看柳州夜景) (柳江) (文庙和蟠龙山) (柳州博物馆里面丰富的恐龙化石) 桂林&emsp;&emsp;桂林位于漓江与其支流交汇之处,市区有山有湖有河,漓江两岸是喀斯特地貌的石山,整个市区和山水融合为一体,非常优美的山水城市.但桂林市区的风景在当地只能算是一般,阳朔县才是桂林山水的精华.有一句话是这样说的:”桂林山水甲天下,阳朔山水甲桂林”.我还要再补一句:”兴坪山水甲阳朔”.&emsp;&emsp;来桂林重头戏是徒步阳朔,也就是从杨缇码头到兴坪古镇这一段.从桂林坐巴士到杨缇路口,接着再转车到杨缇码头.刚下车,一堆当地山民就像癞皮狗一样跟着我们,要我们买这买那,或者要我们坐他们的车,价格又坑,不答应就死缠不放,”穷山恶水出刁民”果然不假,桂林当地山民的贪婪真的很让人反感. 不知是改造还是安全的因素,杨缇码头到全家洲这段路被封,船渡也不去,我们几个徒步的好不容易摆脱贪婪的山民用滴滴打的出发去全家洲,从全家洲开始徒步,一路到九马画山风景很普通,这段路确实不值得一走. 九马画山到兴坪古镇这一段风景好很多,中间主要景点就是20元人民币取景地,但山重水复林木掩映的山水风光并不是我喜欢的类型. 到达兴坪古镇吃点小吃补充能量后,马上坐巴士出发到阳朔西街.&emsp;&emsp;阳朔县城位于漓江与遇龙河的交汇处,其中的西街与其他地方商业化的古镇没多大区别,它唯一的区别是坐落于山水之中,风景好一些,同时外国游客也比较多.但古镇对我真的是毫无吸引力,在这梅雨季节就更加糟糕了,又潮湿又闷热,恨不得早点离开.花了一个上午骑行,经过阳朔的大榕树,月亮山,十里画廊等景区,太普通了,我连票都懒得买,因为不值得.而这段时间泛黄的河水,遇龙河漂流也是不推荐的.&emsp;&emsp;晚上看攻略时一副航拍般的俯瞰漓江大转弯的震撼图片让我心头一动,一找原来是在兴坪古镇的老寨山顶拍摄的.于是有了再去兴坪古镇攀登的念头,不幸的是刚好赶上周日,古镇交通阻塞,从古镇门口一路堵到汽车站.只能下车一路徒步到古镇码头,老寨山就在码头旁边,不算很高,但后面一段很陡,雨后湿滑,有风险. 20分钟后登上顶峰,面对大好风光,忍不住长啸一声.顶峰已经有个带着三脚架,佳能5Dsr和各种滤镜的大爷在美景旁守候多时了.一会儿,阿根廷一家5口上来了,3个孩子也才四五岁的模样,带着来这么险的地方,厉害了.接着几个和我同一巴士的外国游客也上来了.在山顶呆了一个小时,欣赏够了美景,视频和照片也拍的够多了,我开始下山.刚到山脚马上就是瓢泼大雨,我真是够幸运的,这会在山上的驴友们估计淋得够呛.&emsp;&emsp;中午时分,兴坪古镇的交通就更加糟糕了,各种车辆一路堵了好几公里,有些车早上10点从古镇汽车站发车堵到12点多还没出古镇,古镇外面几公里处就不让车进入了,我明智的选择徒步到古镇外面不堵车的地方,临时拦车回阳朔,再从阳朔转车回桂林,下午三四点我就返回了桂林.&emsp;&emsp;要看风景的话,阳朔的兴坪是最精华中精华,尤其是攀登其中的老寨山,相公山,大面山,从高处俯瞰桂林山水才能看到震撼妖娆的风景,日出日落时分去就更加完美了,用无人机航拍也是不错的选择.我甚至认为看风景的话,攀登高峰远眺就可以了,因为从平地看到的风景实在平淡无奇.&emsp;&emsp;关于桂林的美食,最出名的就是桂林米粉,当地人更喜欢的是干拌的米粉,我吃的最好吃的就是同来馆的米粉,而名气很大的崇善米粉,味道非常一般. 阳朔徒步视频 (桂林靖江王城) (桂林日月双塔) (日落双塔) (日月双塔夜景) (全家洲到九马画山风景) (全家洲到九马画山风景) (九马画山) (20元人民币背景) (兴坪古镇码头和老寨山) (阳朔街道) (阳朔西街) (阳朔西街) (登顶老寨山) (俯瞰兴坪古镇) (俯瞰兴坪古镇) (阿根廷一家和单反大爷) (远眺) 贵阳&emsp;&emsp;贵阳是一座山城,但它不像重庆那样建依山而建.而是建在丘陵山地之间的谷地上,就像那句话说的一样“山中有城,城中有山”.贵阳的气候非常宜人,夏天则是个非常适合避暑的城市.我到达贵阳是5月15日,刚好五月中旬,这个时候广州南宁等地的温度已经超过30度,非常酷热.而这时的贵阳白天最高24度左右,最低是10多度,太舒服了,而晚上睡觉则需要盖一床薄薄的棉被, 因此在贵阳夏天是可以不需要空调的.贵阳非常舒服的一点就是不管怎么热都不会有潮湿闷热的感觉,只要在阴凉处就非常凉爽,街上也是清风徐来.在广州,南宁等地的热是那种无处可逃的闷热,夏天没有空调是没法活的.&emsp;&emsp;正因为被山地切割,贵阳城几个区太分散了,尤其是南北的跨度有点大,从两头到城市中心都有十几公里,几个区之间甚至有段路就是架在山上的高架桥,加上没有地铁,跨区坐公交车都要超过一小时,非常麻烦.还有让我觉得不可思议的一点是,作为省会城市的贵阳竟然没有共享单车.城区中心本来比较旧,再加上正在大规模改造,所以感觉市容不是很好,但是北面新建的高新区却规划得很好很漂亮,很多现代化的高楼大厦,尤其是在国际会议中心附近.&emsp;&emsp;参观贵州博物馆了解到,贵州省有18个民族,其中汉族主要分布在北部,南部主要以苗族,侗族,布依族等少数民族为主,对应的行政规划主要是黔东南,黔南,黔西南等自治州.&emsp;&emsp;贵州最明显的饮食特点就是喜欢酸辣.我最喜欢的小吃是丝娃娃和安顺裹卷,这两种小吃很相似,都是馅料外面裹一层面皮,馅料主要是各种凉菜.吃起来新鲜爽口,尤其是在夏天吃真的太美味了.(多彩贵州) (甲秀楼) 昆明&emsp;&emsp;从2014年到至今,昆明是我转乘航班次数最多的一个城市,加起来这已经是我第四次来昆明了,之前都是匆匆路过,没来得及品味它.第一次飞昆明是去丽江游泸沽湖和徒步雨崩,之后两次都是从尼泊尔回国中转,相信以后我还有很大可能再来昆明的.&emsp;&emsp;春城昆明同样也是一个避暑胜地,气候和贵阳很相似,但城市建设比贵阳好一点.由于之前已经去过大理和丽江,所以我这次只在昆明呆一两天,参观博物馆,陆军讲武学堂,品尝当地美食等.其中过桥米线味道不错,但价格太贵了,最便宜的都要20多一份.云南博物馆也建设的非常好,甚至部分场馆还使用VR小游戏来吸引游客参观,很值得一去.(正义路) (陆军讲武学堂) 成都&emsp;&emsp;终点就是我非常熟悉的城市-成都,中国西南最繁华富庶的大都会.种类繁多的美食小吃,比一线城市低的消费,工作机遇也多,让我选择留在了成都.但最重要的一点是,从成都向西出发一两个小时就能到多彩的川西,这是横断山脉挤压出来的一片神奇的土地,既有迷人的草原海子,也有壮观的冰川雪山,而再远的地方就是辽阔的青藏高原.西岭雪山,四姑娘山,贡嘎山,南迦巴瓦峰等无数的雪山是我的最爱.&emsp;&emsp;我去昆明的另一大原因就是想体验以险峻闻名于世的成昆线,但阴差阳错我们的火车走的却是东边的内昆铁路,还好这条路线一样也非常险峻,风景还不错.(崇山峻岭中穿梭) (两边险峻的石山) (武侯祠) (杜甫草堂) (春熙路)","tags":[{"name":"旅游","slug":"旅游","permalink":"https://edwardzhong.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"西安","slug":"西安","permalink":"https://edwardzhong.github.io/tags/%E8%A5%BF%E5%AE%89/"},{"name":"太原","slug":"太原","permalink":"https://edwardzhong.github.io/tags/%E5%A4%AA%E5%8E%9F/"},{"name":"石家庄","slug":"石家庄","permalink":"https://edwardzhong.github.io/tags/%E7%9F%B3%E5%AE%B6%E5%BA%84/"},{"name":"郑州","slug":"郑州","permalink":"https://edwardzhong.github.io/tags/%E9%83%91%E5%B7%9E/"},{"name":"武汉","slug":"武汉","permalink":"https://edwardzhong.github.io/tags/%E6%AD%A6%E6%B1%89/"},{"name":"长沙","slug":"长沙","permalink":"https://edwardzhong.github.io/tags/%E9%95%BF%E6%B2%99/"},{"name":"韶关","slug":"韶关","permalink":"https://edwardzhong.github.io/tags/%E9%9F%B6%E5%85%B3/"},{"name":"广州","slug":"广州","permalink":"https://edwardzhong.github.io/tags/%E5%B9%BF%E5%B7%9E/"},{"name":"南宁","slug":"南宁","permalink":"https://edwardzhong.github.io/tags/%E5%8D%97%E5%AE%81/"},{"name":"柳州","slug":"柳州","permalink":"https://edwardzhong.github.io/tags/%E6%9F%B3%E5%B7%9E/"},{"name":"桂林","slug":"桂林","permalink":"https://edwardzhong.github.io/tags/%E6%A1%82%E6%9E%97/"},{"name":"贵阳","slug":"贵阳","permalink":"https://edwardzhong.github.io/tags/%E8%B4%B5%E9%98%B3/"},{"name":"昆明","slug":"昆明","permalink":"https://edwardzhong.github.io/tags/%E6%98%86%E6%98%8E/"},{"name":"成都","slug":"成都","permalink":"https://edwardzhong.github.io/tags/%E6%88%90%E9%83%BD/"}]},{"title":"重返喜马拉雅之尼泊尔ACT篇","date":"2018-02-27T07:07:29.000Z","path":"2018/02/27/act/","text":"&emsp;&emsp;一年后重返喜马拉雅南坡的尼泊尔, 重回那片无数次在我梦里萦绕的壮丽辽阔的高山和雪原, 这次是探寻安娜普尔纳保护区(Annapurna Conservation Area, ACA), 徒步排名世界第一的安娜普尔纳大环线(Annapurna Circuit Trek, ACT), 然后从ACT终点Poon Hill开始重走ABC(Annapurna Base Camp), 最后欣赏冬天雪花飞舞的安娜普尔纳大本营, 所以这次徒步其实是ACT + Poon Hill + ABC组合起来的超级大环线. 2016年喜马拉雅之旅请看：喜马拉雅之旅（西藏篇）喜马拉雅之旅（尼泊尔ABC篇）喜马拉雅之旅（尼泊尔EBC篇） (Tilicho Lake) (Poon Hill日出) (安娜普尔纳大本营) 本次徒步视频: 徒步路线图&emsp;&emsp;我是按通常的逆时针方向徒步ACT,徒步起始点Besisahar,徒步结束点NayalPul,从加都直接出发,退出到博卡拉. 日程安排 时间 交通 地点 行程 住宿 2018/01/23 深圳到加德满都 飞机 07:30 - 15:00 加德满都泰米尔区 办理落地签,兑换尼币,换SIM卡,找住宿 Sunrise Cottage 家庭旅馆 2018/01/24 步行 加德满都泰米尔区 办理ACT、ABC徒步证件:TIMS 和 ACAP Sunrise Cottage 家庭旅馆 2018/01/25 加德满都到Besisahar的Tourist bus 9:00 - 16:30 Besisahar 坐车到ACT徒步起点Besisahar Besisahar 民宿 2018/01/26 ACT线 Besisahar到Chamche的Jeep 9:00 - 12:30 Chamche Besisahar-&gt;Chamche Tibet Lhasha hotel &amp; restaurant 民宿 2018/01/27 ACT线 Timang Chamche-&gt;Dharapani-&gt;Timang Timang 民宿 2018/01/28 ACT线 Chame Timang-&gt;Chame Chame 民宿 2018/01/29 ACT线 Upper Pisang Chame-&gt;Dhikur Pokhari-&gt;Upper Pisang Upper Pisang 民宿 2018/01/30 ACT线 Ngawal Upper Pisang-&gt;Ghyaru-&gt;Ngawal Ngawal 民宿 2018/01/31 ACT线 Manang Ngawal-&gt;Braka-&gt;Manang Manang民宿 2018/02/01 ACT线之 Tilicho支线 Tilicho Base Camp Manang-&gt;Khangsar-&gt;TBC New Tilicho Base Camp hotel &amp; restaurant 民宿 2018/02/02 ACT线之 Tilicho支线 Khangsar TBC-&gt;Tilicho Lake-&gt;Khangsar Khangsar 民宿 2018/02/03 ACT线 Ledar Khangsar-&gt;Yak Kharka-&gt;Ledar Ledar民宿 2018/02/04 ACT线 Thorung High Camp Ledar-&gt;Thorung Phedi-&gt;Thorung High Camp Thorung High Camp hotel &amp; restaurant 民宿 2018/02/05 ACT线( Thorung La Pass ) Muktinath Thorung High Camp-&gt;Thorung La Pass-&gt;Muktinath Muktinath 民宿 2018/02/06 ACT线 Kagbeni Muktinath-&gt;Kagbeni Kagbeni民宿 2018/02/07 ACT线 Marpha Kagbeni-&gt;Jomsom-&gt;Marpha Hotel TanPoPo 民宿 2018/02/08 ACT线 Larjung Marpha-&gt;Larjung Larjung民宿 2018/02/09 ACT线-&gt;PoonHill线 Ghara Larjung-&gt;Kalopani-&gt;Tatopani-&gt;Ghara Ghara 民宿 2018/02/10 PoonHill线 Ghorepani Ghara-&gt;Chitre-&gt;Ghorepani Ghorepani民宿 2018/02/11 ABC线 Chhomrong Ghorepani-&gt;Tadapani-&gt;Chhomrong International guest house 民宿 2018/02/12 ABC线 Himalaya Chhomrong-&gt;Bamboo-&gt;Himalaya Himalaya Hotel 民宿 2018/02/13 ABC线 ABC Himalaya-&gt;MBC-&gt;ABC Paradise Garden hotel &amp; restaurant 民宿 2018/02/14 ABC线 ABC ABC呆1天 Annapurna Guest house 民宿 2018/02/15 ABC线 Chhomrong ABC-&gt;MBC-&gt;Bamboo-&gt;Chhomrong International guest house 民宿 2018/02/16 ACT/ABC线 Chhomrong徒步到最近坐车点Matkyu,下午坐吉普经过ACA退出点Nayapul,最后14:00到达Pokhrara 博卡拉 Chhomrong-&gt;Matkyu-&gt;Nayapul-&gt;Pokhara Hotel Mandap 家庭旅馆 2018/02/17 休闲 博卡拉 山峰博物馆、湖滨区 Hotel Mandap 家庭旅馆 2018/02/18 休闲 博卡拉 博卡拉老城、萨朗科 Hotel Mandap 家庭旅馆 2018/02/19 博卡拉到加德满都Tourist bus 7:30 - 16:00 加德满都泰米尔区 博卡拉-&gt;加德满都 WanderThirst hotel 背包客客栈 2018/02/20 休闲 加德满都 猴庙、博达哈佛塔 WanderThirst hotel 背包客客栈 2018/02/21 加德满都到昆明 飞机 16:40 - 22:30 昆明 加德满都-&gt;昆明 昆明长水机场 ACT徒步要知道的事&emsp;&emsp;关于ACT徒步如何准备个人装备、器材、食物,网上有太多的游记和攻略论述这里也不再详述了,我是结合自己之前走EBC的经历和参考前人的攻略而准备的.因为本人自恃有过EBC全程负重徒步的经历,而ACT的平均海拔比EBC低得多,所以这次依旧是无背夫和向导全程自己负重,不同的是这次我是独自前往.下面是我主要的装备和器材,主要是本着轻量化的原则(单反都没带,用GoPro代替),毕竟我可是每一份重量都要自己背上去的. 衣物 装备 器材 冲锋衣裤 双登山杖 手机 快干衣裤 雪套 GoPro 保暖内衣 冰爪 IPad 抓绒手套、加厚手套 雪镜 充电宝 鸭舌帽、抓绒帽 睡袋 便携太阳能电池 多条魔术头巾 750ml保温杯 充电转接头 &emsp;&emsp;关于独自徒步,只要具备一定英语水平,基本读图能力和方向感,想要在ACT迷路还真不太容易,因为ACT步道规划得实在完善.这个季节一路接触到的徒步者百分之九十都是没有背夫向导的,一半以上都是和我一样的独行侠,欧美驴友比例更高一些.当然这个季节走ACT的很多是经验丰富的徒步者,而ABC则不管什么时候一向充斥着大量普通的游客. &emsp;&emsp;关于个人安危,你更应该担心干燥缺氧的环境给你带来的伤害.喜马拉雅山区多年来暴力犯罪都是零,相反每年都有人被喜马拉雅恶劣的环境夺去生命.在高海拔恶劣的环境,一点点缺陷都有可能会要了你的命,尽管我一直认为自己的体质非常适应喜马拉雅山区,但仍然没有丝毫的马虎.在我到达Manang之前几天就有个尼泊尔背夫在过坨龙垭口前因急性高反经抢救无效而死亡.感冒发烧在高海拔是大忌,所以能不洗澡就别洗了,那么干燥的环境不洗澡真不是事儿.高海拔极端干燥,尤其是冬季,要随时补充水分,而开水则是避免高反的利器. &emsp;&emsp;还有ACT一路被问得最多的一句就是:are you korean?原因我觉得一是中国人很少独自出行,喜欢成群结队,但很欣慰的是翻越坨龙垭口那天竟然碰到了和我一样独行的武汉小伙. 二是韩国人户外运动开展成熟,喜欢登山徒步的人特别多,他们几十年前登山就已经达到了世界一流水平,而尼泊尔则是他们最热衷的目的地之一,从EBC走到ACT,个人感觉他们确实为数不少. 也许我该带上一面五星红旗😂. &emsp;&emsp;喜马拉雅山区徒步每日行程,从山地气候景观和个人体能方面综合考量, 上午徒步,下午休息是一个合理的选择. 除了特殊情况要徒步一天之外, 徒步半天对身体健康的正常人会比较轻松,而按这个节奏徒步20多天也有助于保证体能,保养双腿膝盖. 还有个更重要的原因是喜马拉雅山区的上午是一天当中气象条件最好的时间段,一般都是天气晴朗,空气清晰,是欣赏风景和拍照的绝佳时机.而下午经常会多云,在低海拔的山谷则有很大几率会遇到阴雨水雾,一旦徒步进程延迟,还有可能要走夜路,在喜马拉雅山区夜间徒步是比较危险的,而上午徒步就避免了走夜路的情况,最多就是延迟到下午.&emsp;&emsp;关于ACT的难度,对我来说,ACT要比EBC要难一些,因为EBC的高海拔对我没多大影响,相反ACT非常多的上下坡和台阶路却非常的折磨人,损耗膝盖和脚踝.对高反比较敏感的人来说,EBC才会是比较困难的徒步路线,而ACT在海拔4000米以上的路段寥寥无几.但冬天早晚非常寒冷,而且有可能会遇到寒潮大风大雪等恶劣天气,有一定的危险性,不过好在恶劣天气一般持续时间很短,完全可以在住宿点休整避开.而ACT需要考虑的另一个不利徒步的因素-风,马斯扬迪和卡利甘达基峡谷的部分地段会刮起非常猛烈的狂风,中午在Jomsom附近的峡谷徒步甚至会有生命危险.而狂风对顺利通过坨龙垭口同样有着非常大的影响. ACA著名的山峰道拉吉里峰(Dhaulagiri I),海拔8167米,世界第七高峰 (2018/02/08 摄于Larjung) (2018/02/11 摄于Poon Hill) 马纳斯鲁峰(Manaslu),海拔8163米,世界第八高峰 (摄于Timang,引用网友图片) 安娜普尔纳一号峰(Annapurna I),海拔8091米,世界第十高峰 (2018/02/14 摄于ABC) 安娜普尔纳二号峰(Annapurna II),海拔7937米,世界第十六高峰 (2018/01/30 摄于Ghyaru) 安娜普尔纳三号峰(Annapurna III),海拔7555米 (2018/02/01 摄于Manang,左为Annapurna III) (2018/02/04 摄于Thorung High Camp,中间为Annapurna III) 安娜普尔纳南峰(Annapurna South),海拔7219米 (2018/02/14 摄于Chhomrong, 左为Annapurna South,右为Hiunchuli) (2018/02/14 摄于ABC) 鱼尾峰(Machhapuchhre),海拔6997米 (2016/11/20 摄于Ghandruk) (2016/11/22 摄于ABC) Ganggapurna,海拔7455米 (2018/02/01 摄于Manang) Tilicho Peak,海拔7134米 (2018/02/02 摄于Tilicho Base Camp) Nilgiri,最高峰Nilgiri North海拔7061米 (2018/02/07 摄于Kagbeni) (2018/02/07 摄于Jomsom) 安娜普尔纳的人文&emsp;&emsp;关于尼泊尔的山地人文,与EBC所在的昆布地区(Khumbu region)主体民族是夏尔巴人(sherpa)不同,安娜普尔纳保护区(ACA)的人文情况就复杂得多了,马斯扬迪河谷主要的山地民族是古荣族(gurung),他们就是参加廓尔喀雇佣军的主体之一;而卡利甘达基河谷的主体民族则是另一只支山地民族-塔卡利族(thakali),历史上他们垄断了当地跨喜马拉雅山区的盐马交易,他们明显也富庶得多,从他们的房子和当地完善的基础设施可以看出;低海拔地区是混有印度雅利安血统的山地民族-马嘉族(magars),主要从事耕种.在更高海拔地区都分布有藏族.还有另一些混有印度雅利安特征的达芒族(tamang),2003年在西藏吉隆沟附近归化入中国国籍的就是尼泊尔的达芒族,据信他们就是当年驰骋于中尼边境的山地骑兵后裔.夏尔巴,古荣,塔卡利和藏族和我们一样都是蒙古利亚人种,但他们属于藏缅语族.&emsp;&emsp;尼泊尔有一百多个民族,有一个基本规律就是,随着海拔的提升,人种逐渐从雅利安血统过渡到蒙古利亚-藏缅血统,宗教也从印度教逐渐过渡到藏传佛教,苯教.甚至还有极少数的基督教徒和伊斯兰教徒.然而真实情况远要复杂得多,他们之间又会产生很多的混合的民族,混合的信仰.当然占比最多的还是处于低海拔地区信仰印度教的纽瓦丽人(newar).但从某种意义上来说,尼泊尔是人种,民族和宗教的大熔炉. 01/23 - 01/24 加德满都&emsp;&emsp;航班经马来西亚的吉隆坡转机, 然后跨过浩瀚的印度洋孟加拉湾,进入印度次大陆. 飞过孟加拉国的时候飞机航向开始由西北转向正西, 远处的喜马拉雅山脉此刻出现在飞机的右舷窗, 干城章嘉,马卡鲁,珠峰,洛子,卓奥友依次登场.接着映入眼帘的就是群山怀抱的加德满都谷地,还有密布的建筑物,尼泊尔时间3点左右我们的航班最终平稳降落在加都的特里布万国际机场. (飞越孟加拉湾) (远处的喜马拉雅山脉) (进入加德满都谷地) (拥挤不堪的加德满都) (欢迎来到尼泊尔) &emsp;&emsp;来到泰米尔区后,首先要做的就是找住宿,兑换尼泊尔卢比和购买sim卡. 因为没有多余时间去找其他民宿,还是住之前的性价比不错的家庭旅馆sunrise cottage;将沉重的背包放在旅馆后,接着到附近国人开的圆梦客栈兑尼币(中国人开的旅馆、客栈、公司一般都可以直接用支付宝兑换尼币,他们经常要用到RMB,所以汇率都比尼泊尔开的兑换店要高得多,众所周知的凤凰宾馆汇率相对其他几家旅馆要低一些,所以我选择去其他店);&emsp;&emsp;购买尼泊尔的Ncell手机卡时,发现已经支持4G网络,这让我有些意外,估计少不了中国政府和公司背后的援助和支持,在加都和博卡拉信号都很好,当然了在山区很多地方连手机信号都没,更遑论是4G信号了.&emsp;&emsp;饥肠辘辘的我第一餐是在旅馆附近一家不起眼的餐厅-Mero Nepali Kitchen,环境挺精致.吃的是尼泊尔的国民食物Dal Bhat,即所谓的豆汤手抓饭,配有酱料,凉菜,蔬菜,薄饼,咖喱豆汤,我选的是羊肉的,所以还有肉食,食物做得很美味.当然尼泊尔的消费还是一如既往的便宜.&emsp;&emsp;尼泊尔传统的食物类似印度,但当前他们的饮食受西方影响很大,西餐到处都是,他们吃的早餐是最明显的,基本就是西式的toast,土豆,煎蛋,培根,沙拉等.而且尼泊尔的旅游业是他们的支柱产业,这里有来自全世界的食物,中餐厅也非常多,提出饮食无法适应问题的人,你确定找对吃饭的地方了吗? 而我对尼泊尔的食物是百分百的适应,这里同样有美味的食物,而我个人也喜欢咖喱,咖喱牛肉/羊肉/鸡肉简直是美味😋. (泰米尔区) (Mero Nepali Kitchen) (羊肉Dal Bhat) &emsp;&emsp;因为1月23号到达加都的航班延误了1个多小时,再加上取行李花费时间太久,到达泰米尔区已经4点多了,而办理徒步证件的Nepal tourism board是5点不到就下班的,只能在加都多呆一天办理徒步证件.&emsp;&emsp;其中TIMS(Trekker Information Manerger System, 徒步者信息管理系统) 2000rs; ACAP(Annapurna Conservation Area Permission, 安娜普尔纳保护区许可证) 2300rs.&emsp;&emsp;办理完证件后剩余的时间就是在加都闲逛,主要在杜巴广场附近的街区游览. (淡季游人稀少的泰米尔区) (雨后的加都泰米尔区显现了它毫无规划,拥挤脏乱的一面) (散落在街角的佛塔) (杜巴广场附近的Mahendreshwar Temple) 01/25 加德满都-&gt;Besisahar&emsp;&emsp;早上9:00从加都到Besisahar的locla bus,一路上不断的捡客,走走停停的.最后到达ACT徒步起始点Besisahar已经是16:30,只能在Besisahar找民宿住一晚,第二天再开始ACT的徒步行程. (远处的壮观的Lamjung himal雪山是安娜普尔纳山脉的余脉) 01/26 Besisahar(760米)-&gt;Chamche(1430米)&emsp;&emsp;ACT的第一天,低海拔的亚热带景观对追逐雪山的我来说是没有任何的吸引力的, 把体力耗费在灰尘漫天的土路上实在是件得不偿失的事. 我的选择就是坐车避开这段低海拔的路线,到达海拔1430米的Chamche之后才开始徒步. 当然坐车到更高海拔的Dharapani也是个不错的选择.&emsp;&emsp;花了1500rs坐吉普从Besisahar到Chamche,到达目的地时刚好中午12点半. Chamche是一个只有不到10家客栈组成的小村落, 但里面却有一个小学,今天整个村庄只有我一个徒步者,显得有点冷清. 我住的是Tibet Lhasha hotel &amp; restaurant, 我第一反应是藏人开的, 询问后果然得到肯定的问答, 依次用namaste和扎西德勒进行问好. 在海拔1430米的山区, 免费提供wifi和hot shower也是件再正常不过的事, 但如果海拔超过4000米后, 有wifi和热水澡那绝对是非常奢侈的. (我们的吉普进入ACA) (远处的Lamjung himal在召唤) (安静的Chamche村) (我住宿的Tibet Lhasha hotel) (在学校玩耍的孩子们) 01/27 Chamche(1430米) -&gt; Dharapani(1900米)-&gt;Timang(2750米)&emsp;&emsp;今天是正式徒步的第一天,从身体适应的角度考虑,定了个到达Dharapani的小目标, 如身体情况良好那就继续徒步到Timang. 7点吃早餐,然后750ml的保温瓶装满开水,8点不到开始出发,中午12点左右到达目的地. 这就是我每天徒步的正常行程安排,上午徒步4个小时左右,下午休息,特殊情况则例外.&emsp;&emsp;今天遇到的第一个徒步者是德国的大妞,聊天了解到她是刚从新西兰徒步后过来的,接着遇到的是一对爱尔兰的情侣,他们和德国大妞是一伙的.&emsp;&emsp;阳光灿烂的上午一路上是欣赏马斯扬迪河谷磅礴大气的风光,到达Dharapani时已经12点,在此处的Check Post登记完后顺便吃午饭.感觉身体情况良好,那下午接着就是徒步到Timang,之所以今天要徒步一天赶到Timang,是因为Timang是唯一正对着世界第八高峰-马纳斯鲁峰的点,想早点看到雪山.正常情况16点多就能到达Timang,接着就能美滋滋的看日落金山,碰碰运气吧,还有就是我接到了寒潮的预警,想马上找个景观好的点,万一天气不好,就在Timang呆一两天.&emsp;&emsp;午饭后下起了小雨,我一开始认为是低海拔的正常现象:河谷水雾导致的阴雨,很快就能停.我仍然执着的向Timang进发,谁知后面雨势逐渐变为中雨,爬上Danaque后面300米的坡后,天气变为了雨夹雪, 冒着雨雪,踏着泥泞,负重爬坡耗尽了我的体能. 刚说完身体适应良好,这下被打回了原形,身体还没进入状态,一下子的大强度攀登,最后身体感觉濒临崩溃.最终16:00到达Timang,而此时的Timang天气糟透了,四周一片雪花和雨雾,日落金山没戏了.我挑选了一家位置非常好的叫绿洲的客栈,这个季节大部分客栈都关闭了,其实选来选去就是那几家还在开的店.&emsp;&emsp;下午路上遇到了荷兰夫妇和他们有趣的尼泊尔向导, 接着我终于遇到中国同胞了,是两位自己负重的川妹子,和我一样也是无背夫向导自己负重,厉害的女汉纸们.最后在Timang又遇到了她们,于是把绿洲客栈介绍给她们入住,这让客栈稍微热闹了点. (路过漂亮的村庄Tal) (路过漂亮的村庄Tal) (马斯扬迪河谷) (马斯扬迪河谷) (前面就是Dharapani) (Dharapani村的Check post) (白雪覆盖的Timang村) (天气糟糕) 01/28 Timang(2750米) -&gt; Chame(2670米)&emsp;&emsp;今天是雪后的第一天,空气通透,阳光灿烂,踏着薄雪,迎着朝阳向马斯扬迪河谷最大最繁华的小镇-Chame出发.Timang到Chame的路况非常良好,路程也比较短,不到11点就到达了Chame.&emsp;&emsp;Timang位于马纳斯鲁山脉的西边,意味着日出时我们看到的是背光一侧,光照条件不理想,而日落相反会非常壮观.今天安娜普尔纳山脉的主山脊终于出现了,前方的雪峰是Lamjung himal和安娜普尔纳二号峰.而Chame就在它们的山脚下,但因为角度问题,Chame并不是欣赏安娜普尔纳雪山的好地点,但这里却能够回望马纳斯鲁山脉,傍晚刚好能欣赏马纳斯鲁的日落金山,但距离有点远,手机和gopro拍出来效果不理想,这时候真的好怀念强大的单反. (清晨在Timang欣赏背光的马纳斯鲁) (Timang西侧山峰的日照金山) (两条都能到达Chame,左边公路,右边徒步路) (前方安娜普尔纳二号峰) (Lamjung himal和安娜普尔纳二号峰) (Chame位于Lamjung himal山脚) (Chame) (远处的马纳斯鲁峰) (云雾中的马纳斯鲁) (马纳斯鲁日落金山) 01/29 Chame(2670米)-&gt;Dhikur Pokhari(3060米)-&gt;Upper Pisang(3300米)&emsp;&emsp;路过Bhratang后出现了一个壮观的大岩壁,正式名称是Swargadwari Danda和Pangdi Danda,海拔4895米和4666米.11点半到达Dhikur pokhari时正好又遇到爱尔兰情侣,他们正在路口的客栈吃午餐,他们这时候招呼我一起进餐.因为冬季走ACT的徒步者太稀少了,到目前为止我遇到的还不到10个,所以驴友之间碰面都会有惺惺相惜的感觉.&emsp;&emsp;午饭后继续向Upper Pisang进发,1点多的时候到达目的地,当爬上村庄最高点-藏传佛教寺庙正下方客栈的时候,我几乎累瘫了.但回报就是这里的视角非常棒,对面正对着安娜普尔纳二号峰,河谷对面下方的Lower Pisang也一览无余.Uppper Pisang的坡非常像上雨崩村前面的坡,短短的直线距离,坡度极陡,感觉很近,但爬起来特别费劲.像我这么偏执一定要找最高点的毕竟是少数,所以不例外的这家客栈只有我一个顾客.接着在村庄里转了一圈,然后到他们的精神中心-藏传佛教寺庙登高望远.之后的剩余时间就是对着雪山晒太阳上网休息.&emsp;&emsp;尽管Upper Pisang海拔要比Chame高不少,但位于半山腰的村庄一整天都能享受到阳光的照耀,所以Upper Pisang比在山谷中的受湿气侵蚀的Chame要暖和得多.Uppper Pisang里面的房子很多都是藏式风格的,里面的巷子曲折而陡峭,像极了欧洲中世纪的城堡.而从海拔3300米的Upper Pisang开始我们要告别免费的wifi了,但幸运的是这里有个Ncell运营的基站,它可以给我们的手机提供3G信号.&emsp;&emsp;从Dhikur pokhari到Manang有低海拔和高海拔两条路,低海拔入口是Lower Pisang,而高海拔入口Upper Pisang位于河谷对面的半山腰. 位于安娜普尔纳主山脊的山脚下的低海拔路线非常容易,但观看安娜普尔纳雪山的角度不佳,风景比高海拔路线逊色不少.高海拔路线除了比较艰苦外,其他全是优点:一是风景极好,对面就是安娜普尔纳雪山;二是获得高海拔适应能力,这让你从海拔3000米平缓过渡到5000米. (壮观的大岩壁) (连绵的雪峰一路伴随) (Lamjung Himal和安娜普尔纳二号峰在身后) (回望大岩壁) (通往Upper Pisang的吊桥) (优美的河谷风光) (到达Upper Pisang) (一个人独占大雪景房) (阳台对面就是安娜普尔纳二号峰) (村庄全景,河谷对面是Lower Pisang) (河谷北面就是我们明天要去的地方) (藏传佛教寺庙) (阳台上网晒太阳) (长曝光拍摄的安娜普尔纳二号峰夜景) 01/30 Upper Pisang(3300米)-&gt;Ghyaru(3670米)-&gt;Ngawal(3660米)&emsp;&emsp;欣赏完日照金山后开始出发,离开村庄没多久后我又遇到了德国大妞,看来她又被爱尔兰同伴抛在了后头,而今天到目的地Ngawal我们俩基本都是一路同行.&emsp;&emsp;最大的挑战是Ghyaru前面的400多米陡峭的坡,上坡的路是Z形的,这让我想起了EBC的Tenboche之前那个大坡.10点爬上海拔3670米的Ghyaru时,已经精疲力尽,而德国大妞还要20分钟才上来.虽然很累,但身体感觉很棒,随着徒步的进程,身体会慢慢适应高海拔,同时状态也越来越好,但我还是想把最好的状态留在翻坨龙垭口的时候.Ghyaru的风景非常壮观,因此在此停留了接近45分钟休息和拍照,之后才开始向Ngawal出发.后面2个小时的路程是坡度不大的起伏路,但还是挺累人的,中间还停下来吃士力架补充能量.&emsp;&emsp;12点半到达Ngawal,我和德国大妞选择路边一家还不错的客栈,13点左右猛烈的大风刮起的漫天的灰尘笼罩了整个村庄.我午餐吃完土豆momo后,特意尝试了mustang coffee,其实就是白酒加了糖,味道还行.但这酒后劲很足,喝完没多久就是头晕,胃也不是很舒服,下午只能躺床上休息.&emsp;&emsp;安娜普尔纳山脉在坨龙垭口之前的山体基本上是西北东南走向,因此日出时,从山脉东面观看到的雪山大体处于逆光的阴影中,加上这几天空气也不是很通透,日照金山效果非常不理想.还有从Ngawal开始直到坨龙垭口,马斯扬迪河谷每天中午准时刮起的狂风都会扬起漫天灰尘,徒步者最好选择上午徒步,下午休息,以避开这恶劣的气象.随着海拔越来越高,食宿条件越来越差,没有手机信号和wifi是件正常的事,但最恼火的还是供电非常不稳定,时不时的停电. (Ghyaru前面的玛尼墙) (挡在安娜普尔纳二号峰和四号峰之前的岩石山峰是海拔5106米的Longyodanda) (在Ghyaru仰望安娜普尔纳二号和三号峰) (Ghyaru寺庙前风光) (Ghyaru寺庙前风光) (Ghyaru佛塔和远处的安娜普尔纳二号和三号峰) (Ghyaru风光) (安娜普尔纳二号峰和远处的Lamjung Himal) (玛尼堆和远处的安娜普尔纳三号峰) (玛尼堆和风马旗) (下方是海拔3200米humde机场) (Ngawal住宿的客栈,左上方安娜普尔纳二号峰,右上方是安娜普尔纳三号峰) (Ngawal晚霞) 01/31 Ngawal(3660米)-&gt;Braka(3439米)-&gt;Manang(3540米)&emsp;&emsp;离开Ngwal后,德国大妞路上要去参观附近的寺庙,而我的选择是爬上附近的高山欣赏安娜普尔纳山脉,我们只能告别,有缘再聚吧.目的地Manang的海拔是3540米,比Ngawal还低,所以这一路其实是缓慢的下坡.快到Manang时还不到中午12点,但狂风已经提前刮起,狂风中走了半小时后终于到达Manang.赶到Check Post登记完后,马上打听Tilicho Base Camp的情况,很欣慰的了解到TBC里面还有一家open的客栈.而2周后这家客栈会也和其它客栈一样关闭,直到下一个徒步旺季的到来.&emsp;&emsp;傍晚时分,Manang的晚霞似乎预示未来几天将是难得的好天气,毕竟谚语有云“朝霞不出门,晚霞行千里”.我的心情是有点矛盾的,一方面希望过坨龙垭口那天风平浪静,但这样垭口的风景就会非常的平淡无奇;另一方面又希望看到狂风怒吼,雪花漫天的坨龙垭口,这将会是震撼无比的场景,但这往往意也味着艰苦和危险.&emsp;&emsp;我住宿的这家客栈的管家,是一位非常和善的古荣族姑娘.从她口中了解到几天前翻越坨龙垭口的尼泊尔背夫,急性高反后就是返回我们这家客栈,呼叫救援直升机后仍然抢救无效,最后去世,值得注意的是高反前一天他得了感冒(感冒发烧是大忌).这个悲剧也再次警示我们,高海拔登山徒步的危险性,要时刻注意身体情况,必要时可以在某个点多休息一两天,让身体慢慢适应当前海拔,因为从低海拔直接爬升到高海拔是有风险的.&emsp;&emsp;今天是农历十五,晚上有百年难得一见的超级月亮,但在Manang却是乌云密布看不到月亮.此刻Manang的尼泊尔山民们正依据他们的习俗举行特有的仪式,喇嘛们在寺庙诵经,人们在家里伴随着特有的乐器呐喊.晚上管家姑娘选了部印度电影《robot》,这电影半印地语半英语,我似懂非懂的看着,反正也是无聊.我和管家姑娘都用不是太好的英语聊天,了解到她之前有在斯里兰卡工作过,她觉得斯里兰卡地方很美,但人却并不友好,这让我对去锡兰国旅游的期望值有所降低. (Ngawal观看安娜普尔纳日照金山) (安娜普尔纳三号峰、Ganggapurna、Tilicho Peak) (登上Ngawal附近的山坡远眺安娜普尔纳山脉) (Humde机场和安娜普尔纳三号峰) (去Manang路上的风景) (去Manang路上的风景) (去Manang路上的风景) (去Manang路上的风景) (去Manang路上的风景) (到达Manang,回望安娜普尔纳二号峰) (到达Manang) (Manang位于安娜普尔纳三号峰和Ganggapurna山脚下) (Manang的佛塔和远处的安娜普尔纳二号和四号峰) (Manang日落) (Manang晚霞) 02/01 Manang(3540米)-&gt;Khangsar(3734米)-&gt;TBC(4150米)&emsp;&emsp;我对今天的徒步者早餐套餐(trekker breakfest set)非常满意, 它包括一碗燕麦粥、两片toast面包、两个鸡蛋和一杯奶茶,味道还行,一共600rs,这个价格在喜马拉雅山区还算正常,但在加都和博卡拉这样的早餐最多就300rs.&emsp;&emsp;Manang到Khangsar一路比较平坦,9点半已经到达目的地.Khangsar往西可以去Tilicho,往北可以到坨龙垭口,所以我选择在这个交叉点存放部分行李,这样就可以轻装走Tilicho支线,回程再取回行李,之后回到主线(即从Khangsar向坨龙垭口进发).但在这个徒步淡季,Khangsar几乎所有的客栈都已经关闭,村民告诉我唯一还在开的客栈,但听说老板娘5分钟后才回来,等候15分钟后已经消耗完我的耐心,老板娘还是没回来.热情的古荣族妇女自告奋勇表示可以先把我的包给她,由她再转交给客栈老板娘.看着她真诚的眼神,我接受了她的建议,然后先行离开Khangsar向Tilicho Base Camp进发.&emsp;&emsp;Tilicho支线是整个ACT最震撼最美的一段,最后的Tilicho平台更是距离雪山只有咫尺之遥,非常值得一走.但景色有多美,它就有多危险,去TBC有两条路,分别是高线(high trail)和低线(lower trail).其中高线坡度极陡,比低线还危险,目前已经封了,那么经过滑坡区的低线就成为唯一可走的路.滑坡区是有滑坠风险的,上方的砂石壁偶尔会有落石,在这个季节路也没有人维护,部分地段等于没有路,因为滑落的砂石已经把路覆盖了,而下面就是几百米深的峡谷,跌下去凶多吉少,如果有冰雪,这段路将极端危险.当砂石承受重量时会快速的向下方滑落,这时就有种向万丈深渊坠落的感觉,初次接触确实够骇人的.当第一个陡滑的下坡出现在眼前时,我被吓得够呛,幸亏带了冰爪,有惊无险的通过了滑坡区.尽管如此,火星地貌般的滑坡区本身也很壮观.之后再走1个小时,Tilicho大本营终于在我殷切的期盼中出现了.&emsp;&emsp;Tilicho大本营这时候只有一家客栈还在开,看店的是两位尼泊尔小伙,客栈有太阳能电池板和柴油发电,还提供了电视,wifi,当然想连接wifi必须支付200rs.而这里最贵的是住宿,这一路住过来基本都是200rs,而这里却要800rs一晚,简直就是坐地起价.大本营西面正对着壮观的Tare kang、Khangsar kang和Tilicho peak,Tilicho peak像一道连绵的雪墙,Tilicho lake就在它的下方,TBC真是一个与世隔绝的壮观之地. (Manang日照金山,点亮的山峰依次是安娜普尔纳三号峰、Ganggapurna、Tilicho peak) (Ganggapurna、Tilicho peak日照金山) (Ganggapurna) (日照金山后的群峰) (去Khangsar的路上,一路上有很多风蚀地貌) (Khangsar,基本都是藏式风格的房子) (Khangsar到滑坡区的风光,前方的冰雪城墙就是Tilicho Peak) (Khangsar到滑坡区的风光) (向Manang方向回望,中间最远处就是世界第八高峰-马纳斯鲁峰所在的马纳斯鲁山脉) (远处马纳斯鲁山脉,依次是马纳斯鲁峰、Ngadi chuli、Himal chuli) (前方的风蚀地貌斜坡就是危险的滑坡区) (Khangsar到滑坡区的风光) (Khangsar到滑坡区的风光) (Khangsar到滑坡区的风光,经过空无一人的村庄) (壮观而危险的滑坡区) (去Tilicho大本营的高线(high trail)和低线(lower trail)的分叉路口,高线坡度极陡,比低线危险,标志牌已经标识为无法走,低线为唯一可走的路) (壮观而危险的滑坡区) (滑坡区最前面一段还是非常好走的) (滑坡区下方是几百米深的河谷) (滑坡区有好几段路是被砂石覆盖的) (通过滑坡区最危险的地段,路已经完全被松滑的砂石覆盖,坡度也很陡) (滑坡区上方摇摇欲坠的岩壁) (Tilicho大本营,只有这家客栈还在开) 02/02 TBC(4150米)-&gt;Tilicho Lake(4920米)-&gt;TBC-&gt;Khangsar(3734米)&emsp;&emsp;今天让我不爽的是,没有自觉性的客栈伙计早上竟然睡过头了,必须我亲自敲门弄醒他们,才匆忙给我做早餐,导致我8点多才开始出发.上午爬完Tilicho平台后尽管中午还会回来吃午饭,但我出发前还是先结了账单,因为不想再在这多住一晚,就冲这800rs一晚的住宿费和他们的服务,今天再怎么累我都要赶回Khangsar.&emsp;&emsp;踏着积雪爬上大本营前面的一座小山后,视野一下开阔许多,接着是慢慢爬升的一段路.两个小时的辛苦跋涉之后,十几个非常陡峭的z形弯豁然出现在眼前,也就是网上说的夺命坡.依据之前EBC的攀登经验,我知道这时候一定不能停顿,要一小步一呼吸慢慢爬上去,而我也确实做到了,一口气的攻克这十几个z形弯.高海拔徒步就是这样,再累你都不能停下来,一停下来再启动就特别累,而且还会耗费额外能量,真的非常的考验意志力和忍耐力.精疲力尽的爬上Tilicho的平台时,我当时颇有历经千辛万苦,最后大功告成的感觉.但稍等,前面出现的指示牌赫然写着离Tilicho Lake还有35分钟,WTF,简直想死的心都有了.最后半小时的路程简直就是煎熬,毫无遮挡的平台,缺氧低压,寒风刺骨,拖着疲惫不堪的身体到达湖边时,我已经没有多余的心情欣赏美景,同时厚厚的云层和飘落的雪花似乎有不祥预兆.匆匆拍完照片后,我只能马上往回赶.我真的是回来后通过回味照片,才意识到这是一段多么荡气回肠的行程.&emsp;&emsp;从TBC到Tilicho Lake花了3个多小时,返回TBC是一路下坡,花了1个多小时.13点准时回到TBC,吃完午餐的汤面后,马上向Khangsar出发.返回走滑坡区时尽管没有使用冰爪但却异常的顺利的通过了.因为这两天的走类似地形积累的经验给了我一定的技巧和足够的信心.说到底我们就是对不了解的事物有所畏惧,一是不清楚砂石的性质,但我现在了解到它的摩擦力其实挺大的,我完全可以在它们滑落一段距离之时控制好身体平衡.二是下面几百米的悬崖带来的心理压迫,但我可以完全无视它,只注意看自己脚下即可,估计有恐高症的人会受不了.&emsp;&emsp;刚通过滑坡区后又碰到了德国大妞,我刚出来她就进去,我还记得她还说不走Tilicho支线的,这不打脸了,我只能提醒她通过滑坡区要注意安全.接着遇到另一位进去的是罗马尼亚大叔,两天后我们将在Thorung High Camp再次碰面,这是后话.我大概16:15回到Khangsar,没想到还没见过面的客栈老板娘竟然能认出我就是昨天寄存行李到她客栈的徒步者.一阵寒暄过后,我让她给我腾了个好点的房间并取回行李.这家客栈的食宿条件非常简陋,晚上竟然没有电,当然了wifi就更别想了.&emsp;&emsp;尼泊尔方面宣称Tilicho是世界最高的湖泊,但这个不大准确,西藏还有更高的湖泊,当然这个必须有个统一的标准才能决定谁才是第一,这个标准主要就是湖泊高度和湖泊大小.眼尖的小伙伴会问尼泊尔语中“cho”莫非对应的是藏语中的“措”?你猜对了,它就是藏语中的“措”,也就是湖的意思,所以我们可以直接翻译为“提里措”.Tilicho湖的水主要来源于它旁边的Tilicho Peak的冰雪融化后的雪水,而Tilicho湖是马斯扬迪河的源头之一.Tilicho湖水非常清澈,而近在迟尺的Tilicho Peak雪墙也非常震撼,没有结冰的季节可以看到雪山倒影.这里是我认为最震撼和最难忘的场景,完全可以媲美EBC的Kala Patthar,完爆ACT主线的其他风景. (TBC观看Tilicho Peak的日照金山) (爬上TBC前面的山脊之后是一片开阔的谷地) (一路上有几处比较简单的滑坡区,前面是无比壮观的Tilicho山脉) (一口气爬上夺命坡后回望Tilicho湖水冲刷出来的河谷) (纵横交错的雪纹和连绵的雪峰) (纵横交错的雪纹和连绵的雪峰) (爬上了平台后沿着长长的Tilicho山脉边缘向Tilicho湖进发,感觉雪山就在自己的跟前) (地上到处都是积雪和冰块) (爬上前面的山坡就到了Tilicho湖边) (已经冰封的Tilicho湖) (胜利到达Tilicho湖) (Tilicho湖) (Tilicho湖) (欣赏完风景后匆忙下山) (回程的路) (回程的路) (回程的路) (Tilicho大本营就在下方,远处还能看到马纳斯鲁峰) 02/03 Khangsar(3734米)-&gt;Yak Kharka(4050米)-&gt;Ledar(4200米)&emsp;&emsp;Khangsar的客栈老板娘估计是一位四五十岁以上的古荣族妇女,非常勤勉和守时,订了7点的早餐,还不到7点就开始敲门叫我准备吃早餐.结账时她叫我自己计算账单,没在乎数字是否准确,当然我也一分不少的付了1280rs,消费非常低廉.最后她非常执着的一遍遍叮嘱我,从这里到Yak Kharka要怎么走.其实我有详细的纸质版徒步地图和GPS定位的手机APP地图,对ACT路线已经了然如胸.&emsp;&emsp;前面一段路要爬升300多米到达山脊,接着是下降同样的高度到Thorung Khola河谷,接着再爬升一两百米,最后是一路平坦到达海拔4050米的Yak Kharka. 不过到达Yak Kharka还不到中午12点,所以我决定继续前行到海拔4200米的Ledar.今天行程看似艰苦,但对于昨天已经攀登过海拔4990米的Tilicho平台的我来说,这些都不是问题. 因为在高海拔地区徒步很重要一点是,如果你之前已经适应过更高海拔的攀登,接着进行低海拔的徒步就会显得轻松很多.&emsp;&emsp;在Ledar的客栈里刚吃完美味的午餐-番茄汁意大利面,这时狂风裹挟着砂石开始猛烈的吹袭着Thorung Khola河谷的每一个角落.呼啦啦直响的房顶,不断渗漏的灰尘,摇摇欲坠的客栈,外面一片昏暗,因为飞沙走石已经遮蔽了阳光,世界末日也不过如此吧.感觉强风随时会卷走我们的屋顶,我开始为客栈的安危而感到惴惴不安,好在1个多小时后风慢慢平息下来了.&emsp;&emsp;Ledar住宿的这家客栈没有wifi,但食物味道还不错,量也足.客栈的餐厅还有很大的窗户,可以非常惬意的坐在大厅里面晒太阳和欣赏正对面的安娜普尔纳三号峰和Ganggapurna. (爬上Khangsar后面的脊顶) (回望马斯扬迪河谷和远处的Manang) (回望安娜普尔纳主山脊,包括二三四号峰和Ganggapurna) (北面正对着的雪峰应该是Yakwakang) (Ledar南边正对着安娜普尔纳三号峰和Ganggapurna) 02/04 Ledar(4200米)-&gt;Thorung Phedi(4450米)-&gt;Thorung High Camp(4925米)&emsp;&emsp;从Ledar到Phedi,除了中间跨越Thorung河谷有100米左右的上下坡外,基本没有难度.9点多就到了Thorung Phedi,稍微休整后,开始冲击Phedi到High Camp之间400多米的陡坡.因为不赶时间,攀登节奏放的比较慢,同时有攀登4990米Tilicho平台适应能力的加成,所以一个多小时爬到顶后并不觉得很累.&emsp;&emsp;Thorung High Camp只有一家藏人经营的客栈,而且他们介绍说,不管大风大雪一年四季他们从不关闭.而从这里到坨龙垭口只有两个多小时的路程,而今天天气非常好,艳阳高照,风平浪静,客栈老板告诉我现在就是过垭口的好时机.但考虑到垭口到Muktinath落差有1700米,下降到Muktinath时估计已经天黑,从安全角度考虑我还是决定在High Camp先住一晚,明天再过垭口.13点左右还是刮起了狂风,不过好在High Camp四周有高山阻隔,影响不是很大.&emsp;&emsp;当我认为整个High Camp只有我一个徒步者的时候,16点左右,罗马尼亚大叔赶过来了,20分钟后上来的是两个马耳他妹子和她们的尼泊尔向导,最后是韩国大叔和他的尼泊尔向导.这下客栈热闹起来了,走了这么多天,第一次遇到这么多驴友在同一个客栈(ACT大部分时间我都是一个人徒步一个人住宿).傍晚我和罗马尼亚大叔看完日落金山后,回到客栈马上就吃上了晚餐.原因是为了避免客人一多造成的晚餐延误问题,我们不约而同的提前到17:30就餐.太阳一落山,气温骤热下降,大家都围着火炉烤火,好在人不是很多,十几个人刚好可以围坐一圈.19点多的时候,武汉小伙打着头灯走夜路赶过来了,他还带了帐篷睡袋炉子太阳能,前面几天他都是在野外露营,今天他走了十几个小时,简直太恐怖了.这个季节能碰到中国同胞太不容易了,而且还是比我还专业和牛掰的强驴.今晚来自不同国家和不同种族之间的围炉夜话是友好而愉快的,尽管明天我们将会各奔东西,但今晚的欢乐时光会是我们人生当中一段难忘的记忆.&emsp;&emsp;High Camp南边能看到安娜普尔纳主山脊,东南方能看到Chulu三峰(east,center,west),登上附近的小山,视野非常好,能完全看到Chulu山脉和安娜普尔纳二三四号峰和Ganggapurna. (回望南边的安娜普尔纳主山脊) (到达Thorung Phedi) (Thorung High Camp) (Thorung High Camp留念) (Thorung High Camp远眺安娜普尔纳主山脊) (Thorung High Camp和远处的安娜普尔纳山脉) (Thorung High Camp和远处的安娜普尔纳山脉) (Thorung High Camp欣赏安娜普尔纳日落) (Thorung High Camp欣赏安娜普尔纳日落金山) 02/05 Thorung High Camp(4925米)-&gt;Thorung La Pass(5416米)-&gt;Muktinath(3700米)&emsp;&emsp;今天,两个马耳他妹子和韩国大叔加上他们的向导一行5人组成的大部队4点半吃早餐,5点出发.而我们的武汉小伙早餐是吃自己带的干粮,5点多也随着大部队一起出发了.但我和罗马尼亚大叔都认为没有必要,因为看天气预报今天风不会太大,2个多小时就能够轻松到达垭口,要知道在海拔5000多米,凌晨是非常寒冷的.我们6点半才开始吃早餐,我45分开始出发,大叔随后出发.但我和罗马尼亚大叔的能力明显比大部队要高出一筹,很快就超过了一个多小时前就出发的大部队,最后还比大部队早半个多小时到达垭口.&emsp;&emsp;坨龙垭口非常的宽阔,后半段是非常平缓的上坡,没有强风的干扰,翻越坨龙垭口是非常容易的一件事.但风力太小造成了另一个问题,天空一直笼罩着厚厚的云层,欣赏风景和拍照很不利.在坨龙垭口拍了足够多的照片和视频后,我、武汉小伙和罗马尼亚大叔开始下山,向Muktinath进发.从海拔5416米的坨龙垭口到海拔3700米muktinath是1700米的疯狂下降,中间没有可供休整的客栈,一路就是看不到尽头的下坡,膝盖和脚踝经受了最严酷的考验.快到Muktinath时强悍的罗马尼亚大叔开始把我们远远甩在身后了.Muktinath是一个分布着好几个区的小镇,里面是纵横交错的道路,我和武汉小伙迷失在这里了,起码多走了5公里才最终走到主寺所在地Ranipauwa,找到住宿客栈的时候已经是13点多了.Muktinath的ACAP路标太不明显太坑了.&emsp;&emsp;武汉小伙明天要回博卡拉,所以他今天下午还要赶到Jomsom,明天一早再从Jomsom坐bus/吉普/飞机回博卡拉.问题是现在找不到人一起拼车从Muktinath到Jomsom,而一辆吉普4000rs太贵,所以他选择徒步到Jomsom,漫长的下坡已经把我们折磨的够呛,而武汉小伙还要继续徒步四五个小时,真的想死的心都有了.我们在客栈吃中饭后,武汉小伙就先行出发了,而我今晚要在这过夜,明天继续ACT的行程,所以下午可以好好的休整.幸运的是武汉小伙在车站拼到了去Jomsom的吉普,只花了1000rs.&emsp;&emsp;翻越坨龙垭口后,意味着我们离开了马南县所在的马斯扬迪河谷,进入了木斯塘县所在的卡利甘达基河谷.海拔高度低于4000米的Muktinath住宿条件好多了,免费的充电,wifi和热水澡.尤其是热水澡,自Besisahar洗澡之后我已经有10天没洗澡了,再次洗热水澡简直太享受了.下午就是去附近的Muktinath主寺瞻仰,然后休息.&emsp;&emsp;Muktinath是印度教中解脱之地的意思,主寺周围有108个泉眼,在印度教和佛教中,108都是非常神圣的数字.非常罕见的印度教和佛教共存于同一个院子,而且都是两者共同认为的圣地.Muktinath就是一个人与自然的和谐,人与人的宽容还有喜马拉雅的壮阔完美融合在一起的地方,而这也是我们来喜马拉雅真正要找寻的东西. (日出之前的High camp) (一路是乌云密布) (到达坨龙垭口) (坨龙垭口留念) (坨龙垭口合照) (南边的chulu山脉和远处的安娜普尔纳三号峰,下面是冰湖) (西边是Thorung peak) (垭口的东边,下面是垭口处的玛尼堆和风马旗经幡) (垭口的北边) (坨龙垭口东边) (到达Muktinath) (Muktinath主寺院子) (佛陀和远处被云层覆盖的道拉吉里山脉) 02/06 Muktinath(3700米)-&gt;Kagbeni(2810米)&emsp;&emsp;昨晚开始木斯塘地区开始急剧降温,海拔4000米以上已经漫天飞雪,冰雪覆盖的坨龙垭口将变得极度危险,这几天将很难翻越了.我们完美的避开了恶劣的天气,但另一方面雪山笼罩着阴云,这一路的风景大打折扣,尤其是我非常想看的道拉吉里山脉.受寒潮影响,今天气温接近0度,同时还有毛毛细雨.从Muktinath到Kagbeni只有两个多小时的路程,所以我9点多才开始出发,这一路是荒凉的风蚀地貌,苍茫的雪峰,藏式风格的建筑,居民也大部分是藏族,感觉像是进入了西藏阿里地区.后面走错路走到北面的小村庄Tiri,耗费了一个多小时,导致到达Kagbeni时已经14点多了.&emsp;&emsp;Kagbeni是一个非常典型的藏式风格的村庄,位于卡利甘达基河边,南面正对着Nilgiri山脉,它既是ACT线最北边的一个点,同时也是木斯塘线的入口点,进入上木斯塘都必须经过Kagbeni.这里面有很多客栈,但这时候正是徒步淡季,街道空空荡荡,整个村庄似乎只有我一个游客.天气原因导致这一路的雪山田园风光变成一片凄风苦雨的荒凉之景,失望的我只能在客栈休息. (远处冰雪漫天的坨龙垭口) (路过Jhong) (Jhong Gompa) (位于卡利甘达基河边的Tiri村) (跨过卡利甘达基河谷) 02/07 Kagbeni(2810米)-&gt;Jomsom(2720米)-&gt;Marpha(2670米)&emsp;&emsp;今天天气有所好转,云层开始消散.一路沿着卡利甘达基河谷往下走,随着海拔慢慢降低,气温也慢慢上升,开始出现越来越多的人烟.11点到达卡利甘达基河谷最大的小镇-Jomsom,它跨度是如此长,穿越它花了超过半小时,Jomsom非常繁华,有各种机构、商店、客栈、餐厅和娱乐措施,它是安娜普尔纳山脉西边最重要的一个交通枢纽,有吉普,汽车站,甚至还有飞机场,可以非常方便的与博卡拉沟通.安娜普尔纳山脉东边对应的交通枢纽则是Manang,它附近同样有机场.那么徒步ACT最节省时间的走法就是,坐飞机到Manang,翻越垭口,再从Jomsom坐飞机回来,当然这样只徒步了ACT最核心的路段.&emsp;&emsp;已经一个多星期没有登记ACAP了,在Jomsom总算遇到了登记的Check Post.Jomsom之后的路交通明显繁忙多了,土路经常灰尘漫天,阳光也越来越猛烈,从Kagbeni走到Marpha就像是从冬天走到了夏天.12点半终于到达了Marpha,住宿的是hotel tenpopo,乍看500rs的住宿费似乎有点贵,但我看了它的内部装饰和有独立卫浴后,觉得还是对得起这个价格的,博卡拉的住宿条件也不过如此.&emsp;&emsp;今天徒步主要的景观就是世界上最深的峡谷之一-卡利甘达基峡谷,它也是全世界唯一的两侧都是8000米级山峰的峡谷,分别是东侧的安娜普尔纳山脉和西侧的道拉吉里山脉.&emsp;&emsp;Marpha是苹果之乡,这时候苹果已经没有了,苹果酒倒可以喝.居民主要是塔卡利族,房子是藏式风格,这个季节街道空空荡荡的,我又成为了唯一的游客.洗漱完就在整个村子闲逛,在每一个稍微大点的村落,房子最豪华,位置最好的永远是他们的寺庙,Marpha也不例外.&emsp;&emsp;晚餐是塔卡利式羊肉Dal bhat加一小杯苹果白兰地,这是我在尼泊尔吃过的最好吃的饭,太美味了,白兰地也不错,喝完有点晕,但刚好可以帮助我舒服入睡.当我以为整个客栈只有我一个人的时候,来了3个欧美游客,聊天了解到他们一路顺时针坐车上来,昨天在Larjung看过道拉吉里ice fall,强烈推荐我去Larjung,顺时针走ACT的基本不大可能穿越坨龙垭口,因为坨龙垭口西坡确实太陡了.当我回房休息后,接着又来了一个亚洲团,不知是不是国人,吵吵闹闹到22点,太烦了. (远处的Nilgiri雪峰) (卡利甘达基河谷) (卡利甘达基河谷和远处的Nilgiri) (卡利甘达基河谷和远处的道拉吉里) (Nilgiri雪山和Jomsom机场) (Nilgiri雪山和Jomsom机场) (Hotel Tenpopo舒适的房间) (Marpha全景) (住宿的房间可以看到藏传佛教寺庙) (藏传佛教寺庙内景) (藏传佛教寺庙内景) (Marpha空荡的街道) (Marpha空荡的街道) (Marpha空荡的街道) (美味的塔卡利Dal Bhat) 02/08 Marpha(2670米)-&gt;Larjung(2550米)&emsp;&emsp;今天天气非常棒,阳光普照,但这个季节还是有些雾霾,看雪山还是有些朦胧.本来打算坐车到Larjung,但错过local bus后,我只能徒步过去,好在Marpha距离Larjung不远,徒步到Larjung的前一个点Khobang时,铺天盖地的道拉吉里山脉就出现在眼前了,它的东南山脊一直连绵到天际,真是摄人心魄.11点半到达Larjung,吃完午饭后花了半小时爬上前面的山坡近距离欣赏道拉吉里山脉和南边的Nilgiri山脉.&emsp;&emsp;Larjung是ACT线离道拉吉里山脉南坡最近的一个点,在这里欣赏道拉吉里日照金山再好不过了.它还有去道拉吉里ice fall的支线,但来回要花费五六个小时,如果要走这条支线最好在这里多停留一天.我虽然不赶时间,但连续徒步后积累的劳累让我只想在客栈休整,静静的欣赏道拉吉里峰和明早的日照金山.&emsp;&emsp;道拉吉里山脉非常的庞大,7000米以上的山脉就有6座,分别是一二三四五六峰.一号主峰道拉吉里峰海拔8172米,是世界第七高峰,从Larjung看到的是金字塔般的一号主峰和它旁边接近7000米的Tukuche peak. (卡利甘达基河谷远望前方的道拉吉里山脉东南山脊) (高耸入云的道拉吉里峰) (高悬在Khobang村上方的道拉吉里山脉) (Larjung村全景,上方的雪山是Nilgiri山脉) (道拉吉里峰) (连绵的道拉吉里山脉) (Nilgiri三峰和Annapurna Fang) 02/09 Larjung(2550米)-&gt;Kalopani(2530米)-&gt;Tatopani(1190米)-&gt;Ghara(1700米)&emsp;&emsp;非常不幸的是Larjung今天是多云的天气,道拉吉里的日照金山泡汤了.但我还是想看阳光照耀下的道拉吉里峰,直到8点还没等到阳光后,才向Kalopani进发,两个小时后到达能欣赏到安娜普尔纳一号峰的Kalopani,但此时安娜普尔纳一号峰被汹涌的云海包围着,只露出峰尖.之后顺便在Kalopani村尾拦了辆最终点为博卡拉的local bus到Tatopani,以车代步,避开这段尘土飞扬的低海拔山路.一路是难以置信的颠簸,感觉比徒步还累,不但外面尘土飞扬,颠簸的车厢里面一样灰尘漫天.能在狭窄崎岖的山路飞速穿梭,不得不佩服尼泊尔司机的技术.&emsp;&emsp;Kalopani是ACT唯一能看到安娜普尔纳一号峰西坡的点,同时还能看到道拉吉里峰,可以说是卡利甘达基峡谷与两侧山峰相对高度差最大的一个点,非常值得停留.&emsp;&emsp;12点多终于到达了海拔1190米绿意盎然的Tatopani,严格来说,ACT主线已经完成,从Tatopani到Ghorepani是属于Poon Hill线.但一般徒步ACT线都会包含Poon Hill线,所以大体上还是把Poon Hill作为ACT线的最终点.也许是习惯了干净整洁的高海拔村庄,回到低海拔嘈杂的Tatopani有种不适感.所以我决定下午继续徒步,上升到海拔高一点的村庄住宿.从Tatopani到Ghara尽管绝对海拔不高,但高度差超过500米,天气炎热同时一路又是陡峭的山路,负重攀登非常的累.15点多到达Ghara,已经精疲力尽,从运动量和疲劳程度来讲不输于攀登Tilicho,只是低海拔山区没有高反的风险,你可以尽情的挥霍体能.在Ghara客栈很少,大部分都是马嘉人的民房,没有选择的我只能选择村庄最高处的一家民宿.这是走ACT线迄今为止住宿条件最差的客栈了,也没有热水澡和wifi,在这么低海拔没有wifi我表示不可理解.&emsp;&emsp;Tatopani到Ghorepani是ACT最后的挑战,1700多米的高度差绝对是一道鬼门关,一路上有好几段非常陡峭的山路,体能消耗非常大.本来我大可以在Tatopani休息,然后用两天时间慢慢爬到最终点Ghorepani,这样会轻松很多,但我渴望早点到博卡拉休息,所以时间赶的有点紧.而Ghara也不是一个好的休息点,这里客栈很少,条件也比较差,更好的选择是到比它高一些的Chitre住宿,客栈多条件好,风景同时也更棒. (告别Larjung) (左边是Nilgiri山脉,右边是安娜普尔纳主山脉) (右边汹涌澎拜的云海包围着的安娜普尔纳一号峰) (坐local bus到Tatopani) (到Ghara村的途中风景) (Ghara村) (Ghara村) 02/10 Ghara(1700米)-&gt;Chitre(2390米)-&gt;Ghorepani(2860米)&emsp;&emsp;Ghara能看到Nilgiri的日出,但遗憾的是道拉吉里山脉和安娜普尔纳山脉被前面的山峰挡住了大部分.看完日出和吃完早餐后,立即出发,今天目标就是到达海拔2860米的ACT最终点Ghorepani.半个小时后到达客栈众多和视野开阔的Chitre,后悔昨天没有继续坚持半小时到这里住宿.之后就是一段接着一段的上坡,中间经过不少的小村落,最后一个小时的路程是最难熬的,眼冒金星,又累又饿又渴,从来没有这么累过.到达Ghorepani后,赶紧找了家有热水澡和wifi的客栈,首先点了份咖喱鸡肉Dal bhat,乘客栈做饭的空隙,赶紧冲了个舒服的热水澡.Dal bhat做得非常美味,加上饥饿感刺激,我虎吞狼咽的吃了两盘饭,老板娘也挺吃惊的.&emsp;&emsp;补充能量和洗漱休整后,接着花了半小时爬到海拔3200米的Poon Hill观景台踩点,此时雪山都被厚厚的云雾怀抱,我只能祈祷明天阳光普照,让我能欣赏到震撼的日照金山.回客栈后遇到三四个中老年日本游客和他们会说日语的尼泊尔向导,我有些意外,因为遇到日本人几率太低了.东亚三国当中,在尼泊尔人数最多的是我们中国同胞,韩国人次之,日本人是最少的.自八九十年代日本经济衰退以来,昔日走遍全世界的日本人就越发稀少,现在他们更多的是以老年团的面目出现,似乎当今的日本年轻人都已经没有了走出去的朝气和勇气. (尽管Ghara海拔才1700米,但夜晚的星空一样很灿烂) (清晨中的Ghara) (Nilgiri日照金山) (从这里观看道拉吉里山脉,比在Larjung看到的更完整) (道拉吉里峰顶飘扬着几公里长的汹涌旗云) (美味的Dal Bhat被我一扫而空) (安娜普尔纳一号峰和南峰汹涌的旗云) (Poon Hill) (还是安娜普尔纳一号峰和安娜普尔纳南峰) (安娜普尔纳日落,燃烧的云海) 02/11 Ghorepani(2860米)-&gt;Tadapani(2630米)-&gt;Chhomrong(2170米)&emsp;&emsp;凌晨5:40就被隔壁早早起床收拾行李的日本人吵醒,等我收拾完毕后已经6点,马上向Poon Hill出发.从客栈到Poon Hill一路上灯光点点,那是打着手电和头灯上山的游客们.我戴着头灯迅速超越前面一群群游客,6:25到达最终点,日出前的Poon Hill寒风刺骨,赶紧在旁边小店点了杯姜茶暖和身体.接下来日出前的半个小时只能不停的踱步让身体保持温度.今天天气还不错,7点左右,Poon Hill壮观的日出开始了,ACA(安娜普尔纳保护区)群峰峰顶依次被点燃,道拉吉里I, 安娜普尔纳I, 道拉吉里II、III、IV、V, Ganggapurna,安娜普尔纳南,鱼尾峰…, 直至道拉吉里山脉和安娜普尔纳山脉都沐浴在阳光普照下.但我的心情却非常平静,因为从EBC到ACT我已经经历过太多震撼场景.在Poon Hill平台遇到一群几十个人的台湾团,又是唱歌又是发表感言,还轮流端着杯葡萄酒拍装逼照,太作了,真是受不了.&emsp;&emsp;看完日出回客栈吃完早餐已经快9点了,结账后马上出发,因为今天的计划是这样的,在Tadapani吃午餐,傍晚到达Chhomrong,徒步一天会非常艰苦.在Tadapani之前有一段陡下坡接着陡上坡的路,到达Tadapani后真的是又热又累又饿.午餐吃完Dal Bhat后,又立即向Chhomrong进发.首先看地图等高线,Tadapani到Chhomrong路况还比较好,但实际情况和我想象的不一样,跨越komrong khala的一段路非常难走,前面是非常伤膝盖的陡峭的下坡台阶,跨过河谷后又是很耗体力的陡上坡,对已经徒步了一个上午的我来说,简直就是折磨.但熬过这一段艰苦的路段后,后面一路到Chhomrong好走了很多,16:40终于到达了Chhomrong.我在chhomrong住的是在Excellent view top的旁边的International guest house,因为上次ABC徒步住的就是excellent view top,感觉他们家做的饭不好吃,所以这次尝试一下其他店的厨艺.International guest house房费是200rs,wifi是200rs,充电免费.同时我将在这里寄存的部分行李,明天轻装进入ABC,回程再取回行李.&emsp;&emsp;早上去Poon Hill看日出是需要收取50rs的门票,其他时间是免费的,在Poon Hill能看到大部分ACA著名山峰,同时这里是欣赏道拉吉里山脉最好的位置之一,安娜普尔纳山脉的一号主峰,南峰,鱼尾峰也依次出现,尽管安娜普尔纳山脉距离要近很多,但由于前面山峰的阻挡,反而没有道拉吉里山脉那么突出.&emsp;&emsp;Chhomrong是ABC最大的点,因为它处于一个非常关键的交汇点,它是往北进入MBC和ABC的门户,往西连接Poon Hill,往南可到达Ghandruk,东南则连接Landruk.从这里进去的地区被称为安娜普尔纳圣地(Annapurna Sanctuary),里面有尼泊尔的圣山-鱼尾峰(Machhapuchhre),同时里面是禁荤的,但羊肉和蛋除外.&emsp;&emsp;这已经是我第二次走ABC了,但2016年路线是Nayapul-&gt;Ghandruk-&gt;Chhomrong-&gt;ABC,没去Poon Hill,而这次是ACT-&gt;Ghorepani-&gt;Chhomrong-&gt;ABC,前半程路线是不一样.这次不但填补了没去Poon Hill观景台的遗憾,同时再次进入ABC,体验冬天白雪皑皑的安娜普尔纳大本营. (Poon Hill日出前的曙光和路上的点点灯光) (Poon Hill日出全景) (安娜普尔纳一号峰和安娜普尔纳南峰日照金山) (道拉吉里日照金山,最高的为道拉吉里一号峰) (日出后阳光照耀下的ACA群峰) (远眺道拉吉里山脉) (远眺安娜普尔纳山脉) (道拉吉里山脉) (Poon Hill下山风景) (在Chhomrong旅馆空荡的大厅吃晚餐) 02/12 Chhomrong(2170米)-&gt;Bamboo(2310米)-&gt;Himalaya(2920米)&emsp;&emsp;今天又是多云的天气,没法看日照金山,不过没关系,回程还会再住一晚的.ABC线还是一如既往的热闹非凡,尽管现在已经是徒步淡季-冬季了.这会正好是春节小长假,一路随处可见中国同胞,而其中十有八九都是广东人,到处都能听到白话.和一个广州团一起聊天走了一段路,不过他们很快就落在我后头了,我12点不到就到达Bamboo,吃完Dal Bhat休息了一会,他们才赶过来.&emsp;&emsp;我13点多到达Doven,本来准备在此过夜,但Doven唯一还在开的客栈条件也不好,而下午剩余的时间也还足够我去到下一个住宿点-Himalaya.于是决定继续徒步到Himalaya,这样明天行程就会更加轻松.真是莫愁前路无知己,天下谁人不识君.半路上竟然碰到了尼泊尔朋友,2016年ABC徒步时朋友的向导-拉杜,他还是一样喜欢带领中国游客,这次带的是一个5人的中国同胞的团.我们寒暄聊天之后告别,因为他们刚从ABC下来,而我正要上去ABC.下午14:50我率先到达了Himalaya,赶天气还不是很冷,马上洗了个热水澡.很快来了个四五个人的韩国团,接着是昨天在Chhomrong住宿同一间客栈的广州小伙,还有几个独立徒步的国人同胞,最后之前的广州团17点多才到达. 走ABC线的中国同胞是如此的多,以致于ABC路上很多尼泊尔山民都会几句普通话就见怪不怪了,往后几天甚至可以说百分之九十的徒步者都是中国人.&emsp;&emsp;下午四五点开始下雨,接着就是雨夹雪,最后毫无例外变成了纷纷扬扬的雪花, 雪下了一个晚上. 我们的心情是喜忧参半,因为下雪意味着ABC的景色更加壮丽,但同时也意味着危险. (从Sinuwa回望Chhomrong,山坡上一路分布着众多的旅馆) (Himalaya) 02/13 Himalaya(2920米)-&gt;MBC(3700米)-&gt;ABC(4130米)&emsp;&emsp;今天是ABC徒步的Big Day,因为下午就能到达最终点-安娜普尔纳大本营.一夜的飘雪,外面早已经是银装素裹, 今天我们几个独立徒步的中国人组成一个团队率先出发,同时没有准备冰爪的同伴出发前都在客栈里花了几百rs购买冰爪.随着海拔越高,积雪会越来越厚,一些陡峭的路段将会变得越来越危险,而冰爪则会大大降低风险.海拔3000米以上的ABC变成了一个晶莹剔透的童话世界,两边的山谷就像是两条盘旋的银色巨龙,我们一路上就是拍拍停停.&emsp;&emsp;我在12点率先到达了MBC(鱼尾峰大本营 Machhapuchhre Base Camp),团队其他成员之后陆续赶了过来.遇到一位在这住宿的塔吉克斯坦小伙,我吃完午餐和他聊天打发时间,然后交流怎么用GoPro拍出更好的效果.我们休息到13:30,才开始向最终点A.B.C出发,这时候乌云越来越厚,又纷纷扬扬的下起了雪,越接近大本营,雪就越厚,而路也越来越不明显.除了偶尔几个从ABC下撤的驴友,已经没有多少人在如此恶劣的天气在外面行走,不知不觉我已经把大部队抛在了后面,不过到大本营的路没什么危险性,他们跟着我的脚印走就行了,只是踩着厚厚的积雪徒步极其耗费体力.15:20终于到达了安娜普尔纳大本营,大本营是ABC海拔最高的点,雪也下得最大,能见度不超过15米,天地一片灰白,而大本营里面的积雪厚度已经超过了1米.不小心踏空,掉进客栈抬高的路基边沿,我的下半身竟然完全陷进雪层.&emsp;&emsp;第一次冒着这么大踩着这么厚的雪徒步,我那5cm齿的冰爪在后面完全不够用,因为粘着冰爪的积雪结成冰后把齿都覆盖了,最后整个鞋底就变成了一块冰底.看来在高海拔大雪天气,冰爪必须要升级了.冬季大雪纷飞的大本营,异常的寒冷,凌晨和晚上是最难受的,因为所有的客栈都没有供暖设施,周围又是一片荒凉,完全没有柴火可烤,唯一的设备就是餐厅里点火时间有限的气炉.只能靠自己的体温硬扛着,吃完晚饭马上钻被窝,四肢确实太冷了. (雪后的Himalaya) (在积雪覆盖的道路中行进) (Hinko cave观看银色的山谷) (银装素裹,云雾缭绕的山谷) (银装素裹,云雾缭绕的山谷) (穿行在云雾缭绕山谷的一大队尼泊尔户外团) (远处是MBC上方的Ganggapurna) (玛尼堆上方窗口露出的鱼尾峰) (到达鱼尾峰大本营-MBC) (Ganggapuran view lodage) (鱼尾峰已经被云雾覆盖) (MBC) (向ABC进发) (风雪中的安娜普尔纳大本营-ABC) 02/14 ABC(4130米)&emsp;&emsp;凌晨5点多就被收拾东西的韩国人吵醒,我只能6点多起床,准备看安娜普尔纳的日照金山.冒着严寒待到接近7点,日照金山终于开始,驴友们纷纷走出客栈,涌向安娜普尔纳一号峰的边缘.高海拔有没有太阳完全是两码事,没有阳光是一片天寒地冻的荒凉;阳光普照则是温暖宜人的胜地.冬季雪后的大本营,能见度极佳,加上明媚的阳光,三百六十度的雪峰,整个大本营也是银装素裹,真是无与伦比. 在A.B.C除了能看到最著名的安娜普尔纳一号峰和鱼尾峰,还有安娜普尔纳南峰,安娜普尔纳三号峰,khangsar kang, ganggapurna等.&emsp;&emsp;今天天气极佳,我决定在大本营多呆一天,等待傍晚鱼尾峰的日落,白天就是戴着雪镜晒太阳.我今天顺便退了昨天的客栈,换到另一家客栈,而今天明显游客特别多,客栈的床位似乎供不应求.而我刚好和MBC上来的塔吉克斯坦小伙住宿在同一间卧室,还有一对特别健谈和友好的智利夫妇.今天有很多游客从博卡拉坐直升机来到大本营,当然在这个春节小长假期间,大部分都是中国同胞们,而我们就用直升机做拍照背景.今天是西方的情人节,有对来自加都的尼泊尔夫妇坐直升机上来,女的不适应高海拔,似乎有高反的症状,其实更多的是心理因素导致的,经过智利小伙的心理辅导,才最终克服.&emsp;&emsp;下午的云雾让我们又一次无缘鱼尾峰的日落,但2016年我已经看过一次壮观的鱼尾峰日落了.最难熬的还是晚上了,由于人多只有一床潮湿的被子,一个晚上都没有睡好,比2016年那次难受得多了.&emsp;&emsp;安娜普尔纳山脉就像是一道连绵50公里,海拔7000米以上的超级冰雪城墙,一个个山峰就是这道城墙上高耸的垛口,ACT线就是围绕这道巨墙走了接近一圈.它被称为尼泊尔的丰收女神,它和西边的道拉吉里山脉一起将印度洋的湿润水汽无情的留在了喜马拉雅的南坡,滋润出了尼泊尔第二大城市-博卡拉.而它的身后一直到西藏的仲巴县则留下一片干涸和荒漠,丰收女神的另一面就是死亡女神. (安娜普尔纳日照金山) (安娜普尔纳日照金山) (安娜普尔纳一号峰和前面的安娜普尔纳南冰川) (北面是安娜普尔纳南峰和一号主峰) (南面是Ganggapurna、安娜普尔纳三号峰和鱼尾峰) (西面是安娜普尔纳南峰和HiunChuli) (直升机和后面的鱼尾峰) (从博卡拉坐直升机上来的一堆游客) (直升机和安娜普尔纳一号峰) (和直升机的合影) (在ABC标志牌前再次留念,右下方有只从大本营跑下来的🐶) (下午云雾中的ABC) (傍晚云雾中的鱼尾峰) (ABC全景照) 02/15 ABC(4130米)-&gt;MBC(3700米)-&gt;Bamboo(2310米)-&gt;Chhomrong(2170米)&emsp;&emsp;熬到凌晨6点,我迫不及待的起床,安娜普尔纳正在日照金山的时候,我就离开了ABC.因为大本营客栈人太多,吃早餐要等待很长时间,所以我选择下撤到MBC再吃早餐.在MBC吃了最贵的一顿早餐790rs,其实也就是很普通的套餐,在博卡拉和加都,最多就200-300rs.想想今天艰苦的行程需要足够的能量,我也是忍了,反正这是最后一天,明天我就到达物美价廉的博卡拉.在MBC遇到了一对大连夫妇,妻子有高反症状,他们这会等待救援直升机下撤.&emsp;&emsp;8点再次出发,从MBC到Himalaya依然覆盖着冰雪,一路伴随着冰爪砸碎冰雪的悦耳嘎叽声,同时冰雪还有效减缓了对膝盖的冲击,所以冰雪段走起来特别舒坦.而Himalaya之后,景色很快就变成了绿水青山,和后面的冰天雪地真是天壤之别.而这副在2016年EBC南池市场购买的到今天已损坏严重的冰爪终于寿终正寝,我只能把它丢弃.今天天气特别好,阳光也格外猛烈,后面这段路走起来非常酷热,一路下坡非常磨损膝盖和脚踝,最后脚掌和脚趾都摩擦出水泡了.&emsp;&emsp;徒步ABC我最讨厌的点就是Bamboo了,因为它是后面这段路上位置最低的一个低点,不管上山还是下山经过它,你都要上下很陡的台阶,第二个原因Bamboo刚好在Chhomrong和Doven之间,前不着村后不着店的位置,徒步者走到这里已经是中午时分,体能已经消耗到极限,还要再走陡峭的台阶路想想就绝望啊.12点在Bamboo吃了份蔬菜蛋炒饭,休息到12点半继续出发,迎着酷热,一路超过一群群徒步者,这时候迎面走来一群群向ABC开进的中国徒步团,在中国春节小长假的推动下,可以说本处于淡季的ABC又迎来了一个小的徒步高峰期.15:30终于到达了Chhomrong,回到之前存放行李的客栈后,马上洗了个热水澡,真是享受啊.有热水澡,wifi,食物更好吃,气温宜人的Chhomrong相比ABC已经像天堂一样舒服.还买到了本地新鲜甜美的橘子,对20几天没吃到水果的我来说就是人间极品.下午剩余时间就是欣赏安娜普尔纳南峰和鱼尾峰的日落金山.&emsp;&emsp;今天是除夕,但我只能在ABC的Chhomrong度过,这是我唯一一次没在家度过的春节.客栈的中国人只有我一个,其他是在ABC遇到的一群尼泊尔徒步者.我的年夜饭是850rs的蘑菇蔬菜牛扒,可以说非常简单,但这已经是我徒步期间吃的最贵最豪华的一餐了. (在安娜普尔纳日照金山中离开ABC) (再次经过玛尼堆,上方的鱼尾峰) (Deurali,积雪明显比前两天薄了许多) (回到Chhomrong的检查站) (International Guest House阳台前准备欣赏日落金山) (Chhomrong和上方的雪山,三座山峰分别是安娜普尔纳南峰、HiunChuli和鱼尾峰,鱼尾峰左下方是安娜普尔纳三号峰) (Chhomrong的雪山日落) (安娜普尔纳南峰和HiunChuli) (Chhomrong和日落金山) (ACA欣赏最后的日落金山) 02/16 Chhomrong(2170米)-&gt;Matkyu-&gt;Nayapul(1070米)-&gt;Pokhara(900米)&emsp;&emsp;今天同样天气不错,我欣赏完最后一次的安娜普尔纳的日照金山后开始出发.离开Chhomrong没多久,就遇到一位尼泊尔妹子和她的向导,他们和我一样要到博卡拉,那我今天就跟定你们了.接着又遇到了两个回程的英国妹纸,之前在ABC就相遇到过,我们几个人刚好可以拼一辆吉普.虽说这一路大部分是下坡,但中间跨过河谷的一段路的上下坡也是挺累人的.大概10:15到达了Matkyu,这里只比New Bridge远一点,比之前的坐车点Siwai近多了.休息到11:30,我们6人加上另两个尼泊尔山民共8人就一起挤进吉普向博卡拉出发了,我和英国妹纸们每人花了1000rs,其他尼泊尔人估计价格要低一些.&emsp;&emsp;就这样一路颠簸到ACA的出入口点NayaPul,在最后的检查站进行登记,ACT徒步之旅终于圆满完成了.有点意外的是,检查站的工作人员竟然以为我是尼泊尔人,两天前安娜普尔纳大本营的客栈一个伙计也说我像尼泊尔人.&emsp;&emsp;我当时是这么一副惨兮兮的模样:粗糙干裂的双手,脏兮兮的衣服和背包,带着各种徒步装备,这确实像是古荣族的户外向导.哎,只呆了接近一个月,就已经变得这么像当地的尼泊尔山民了.&emsp;&emsp;接近15点,终于到达了我日思夜想的博卡拉,还是住宿在上次的Mandap Hotel,还是之前的203房,还是800rs的价格.首先就是把一大堆脏衣服给旅馆干洗了,接着就是舒舒服服的洗个热水澡,旅馆的淋浴非常给力,水又热又猛,洗了接近半个小时,别提有多爽,下午就是躺在舒服的床上一边吃零食一边悠闲的上网.这个时候的念头就是去喜马拉雅山区登山徒步的人都是花钱买罪受的傻逼😂.&emsp;&emsp;傍晚去网上非常好评的Godfather‘s Pizzeria吃了个两人份的大Pizza,我吃pizza比较少,吃不出它比其他的pizza好在哪,但以不到600rs的价格就吃到这么大的pizza,就是非常满足.吃完顺便逛街,主要逛书店买我喜欢的地图和一些ACT和博卡拉相关的纪念品,然后完成给几个朋友寄明信片的任务.&emsp;&emsp;徒步完超级大环线后,整个人都不想动.感觉就像完成了一件大事后,最想的是休息,用“休息”来奖励自己就是最好的方式.接下来一段时间的节奏就是休息和美食,现在最想吃的就是奶制品和肉类了,尼泊尔的水果奶昔非常鲜美,牛羊肉性价比也非常高,同时准备了一堆零食以便随时补充能量. (日照金山中的Chhomrong) (ACA最后的日照金山) (博卡拉街景一,很多商店有中文标志) (博卡拉街景二) 02/17-02/18 博卡拉&emsp;&emsp;博卡拉(Pokhara),位于费瓦湖之畔,背靠8000米级雪山,天气晴朗时节,抬眼遥看雪山就如同仰望天堂,这在全世界是独一无二的.它还是户外运动之都,登山,徒步,攀岩,漂流,滑翔机,滑翔伞,动力伞,应有尽有.如果评选我心目中最喜欢的城市,博卡拉一定是其中之一.&emsp;&emsp;这两天在博卡拉主要行程就是参观国际山峰博物馆(International moutain museum),游览博卡拉老城,攀登萨朗科,剩余时间主要就是吃喝睡和上网.因为这段时间博卡拉天气并不好,雾霾很大,就算是天气晴朗,天空仍然是灰蒙蒙的,所以在博卡拉看不到雪山,就算登上最棒的观景台-萨朗科一样无济于事.&emsp;&emsp;自下山以来,睡眠质量很不好,似乎和醉氧有关,多适应几天就没问题了.而一直折磨我的冻疮来到博卡拉之后很快就有好转的趋势.在ABC是我冻疮发作最严重的时候,我经常要脱手套的右手已经开始化脓了,这简直就是我小时候在老家双手因受冻严重到化脓的噩梦再现, 但这次回到湿润温暖的低海拔之后两个星期就神奇的痊愈了. (国际山峰博物馆) (博卡拉居民区,明显比加都满都干净和整洁得多) (博卡拉老城区) (萨朗科观景台) (这段时间博卡拉雾霾天气,在萨朗科看不到雪山) (丰盛美味的塔卡利Dal Bhat) (费瓦湖畔,远处是一朵朵的滑翔伞) 02/19 博卡拉-&gt;加德满都&emsp;&emsp;昨天旅馆管家已经帮我订好了回加都的tourist bus,7:30分出发.匆忙吃完早餐到达车站已经25分.博卡拉坐车到加都正常情况需要8个小时,只要不是周六出发的话(尼泊尔周五下午和周六是休息日),很少会遇到堵车的情况.一路上没多少风景可看,听音乐打发时间.同排的美国妹纸倒是对我ACT的行程非常感兴趣,正愁无处打发无聊时光呢,于是给她欣赏我拍的照片,同时给她安利ACT的人文风景和徒步的注意事项.两眼放光的妹纸表示有时机一定要来徒步ACT.&emsp;&emsp;16点左右到达加德满都,我这次住宿的是类似青旅的背包客客栈-WanderThirst hotel,接近一个月后回到加都泰米尔区,感觉街景有一些变化.凤凰宾馆附近的街道新开了好多店铺,泰米尔区的街道干净很多,风马旗也更加鲜艳.因为几天前就是藏历新年,在加德满都还是有一定比例的藏传佛教信徒的.&emsp;&emsp;傍晚特意去知名的珠峰牛扒吃了份他们家的特色牛扒,890rs,真贵.还远比不上我们在国内吃的牛扒,他们家提供的是水牛肉,肉质太差了,好在份量还比较大.接着到超市买水和零食,然后回客栈休息. (回到加都泰米尔区) 02/20 加德满都&emsp;&emsp;一大早我就跑去泰米尔区最高的餐厅-Helenna‘s restaurant 吃早餐,必须爬六七层的楼梯到楼顶.泰米尔区大部分建筑都是几层楼高,所以在楼顶小半个泰米尔区都能看到.这个餐厅我2016年的时候已经来过一次了,helenna的食物还行,来这里就餐更多是冲着它的餐厅高度来的.&emsp;&emsp;接着在谷歌地图的导航下,从泰米尔区走了一个小时到斯瓦扬布纳寺(Swayambhunath)参观,自2015年地震损坏后,它一直还在修复,尼泊尔办事效率确实够低的.斯瓦扬布纳寺有很多猴子,所以又俗称猴庙,它是印度教和佛教共同的寺庙.猴庙佛塔上的佛陀之眼(buddha‘s eyes)是尼泊尔非常著名的标志.&emsp;&emsp;傍晚时分又特意打的去参观博达哈大佛塔(Boudhanath Stupa),它是全世界最大的圆佛塔,尼泊尔藏传佛教的圣地.白色巨大的塔身,飘扬的经幡,外围是一大圈绕着它转圈的信众和游客,场景非常壮观,不愧是尼泊尔的象征. (斯瓦扬布纳寺) (斯瓦扬布纳寺) (斯瓦扬布纳寺佛塔) (中午在Thakali kitchen吃的招牌塔卡利Dal Bhat,配菜太丰盛了,中间的是糌粑) (博达哈大佛塔) (博达哈大佛塔) 02/21 加德满都-&gt;昆明&emsp;&emsp;今天是在尼泊尔的最后一天,我坐的是下午4点多飞往昆明的航班.所以还有大半天的时间,在泰米尔区买了一些纪念品和零食之后,13点才打车到特里布万国际机场.飞机晚点到接近17点才起飞,这段时间尼泊尔的天气确实不好,整个喜马拉雅山脉都是云雾缭绕,只有加都北面的Langtang Himal和珠峰所在的Khumbu region还能看到部分山峰.最后北京时间22点左右到达昆明长水机场,2018年一个月的尼泊尔之旅圆满结束. (再见尼泊尔,飞机掠过下方的博达哈大佛塔) (再见喜马拉雅) 后记&emsp;&emsp;这二十几天的徒步给我感受最深的就是多到无处挥霍的空闲时间.为了轻量化,我连纸质版的书都没带上来.因为我这次带了便携式太阳能电池,觉得它提供的电量足够维持手机,但人算不如天算,这次徒步大部分时候天气并不好,下午有太阳的日子更是寥寥无几.不徒步的下午就成了我最无聊的时光,也许你会说干嘛不看风景呢?关键不是每个住宿点都有很好的风光,加上没有阳光,通常情况是这样的:乌云密布,雪山被遮盖,天寒地冻,这时候你连出门的念头都不会有.有阳光的时候,选择就多了,可以晒太阳,可以去周围走走拍拍.尽管现在的喜马拉雅山区早已经不是刀耕火种,但在工业化时代成长起来的我们一旦离开现代文明的产物仍然很容易就会茫然无措.&emsp;&emsp;再一个就是饥饿感,原因是长期高强度的运动需要足够的能量,而山区的食物往往比较简陋,还有尼泊尔的饮食习惯又有不放油的传统,导致每天徒步一段时间就饥肠辘辘,胃口真是出奇的好,随身带的巧克力早早就被我吃光了.我吃的最多的就是尼泊尔的国民食物-Dal Bhat(豆汤饭),因为其他食物像炒面炒饭意面之类,我必须吃两份才能填满肚子,而Dal Bhat则没有这个问题,可以免费加饭菜吃到饱为止.加上山里面食物价格昂贵,吃两份的钱明显消费太高了,Dal Bhat才是更划算的选择. 徒步之旅后续&emsp;&emsp;ABC,ACT和EBC是尼泊尔最著名最热门的徒步路线.这几条路线之所以这么热门:一是费用低廉,门票许可证一起最多就几十美元,保护区里面的消费也不贵,加上尼泊尔远落后于中国的事实,因此物价非常低廉.二是交通便利,飞机汽车非常方便到达徒步点,ACT几乎全线通车了.三是设施完善,道路通行条件好,徒步路线清晰,一路上有提供补给和休整的旅馆,你不用担心后勤,也就是所谓的闲庭信步的茶歇式徒步(tea house trek).这几条路线提供了这样一种可能:自主规划行程,用相对最小的代价欣赏到世界级的风景.&emsp;&emsp;这次ACT之旅后,标志着我已经徒步完了这三条tea house trek路线.那么问题来了,下一站去哪?其实尼泊尔徒步路线数不胜数,综合考虑后有几条路线可供选择: 朗塘地区徒步(Langtang Region Trekking),有好几条路线,但风景不够壮观; 上木斯塘线(Upper Mustang Trek),费用要昂贵很多,风景接近于西藏阿里,但壮观的雪山比较少; 干城章嘉大本营(Kanchenjunga base camp trek,KBC),世界第三高峰的大本营,基础设施差,部分路段需要扎营; 马卡鲁大本营(Makalu Base Camp Trek,MBC),世界第五高峰的大本营,基础设施差,部分路段需要扎营; 马纳斯鲁环线(Manaslu Circuit Trek,MCT),围绕马纳斯鲁山脉的环线,在ACA旁边,基础设施略差,非常接近ACT和EBC的一条路线; &emsp;&emsp;上面这些路线都必须雇佣户外向导,两人以上同行,同时基础设施要差很多,徒步者基本上是不可能独自完成的.只能参加尼泊尔户外公司组织的徒步团,这也意味着昂贵的消费,尤其是木斯塘线,干城章嘉大本营和马卡鲁大本营.&emsp;&emsp;喀喇昆仑山脉是另一个选择,比如巴基斯坦的K2BC,这个一样必须参加巴基斯坦户外公司的徒步团.&emsp;&emsp;当然我们也可以换另一种方式徒步之前的路线,比如我非常想尝试的EBC三垭口穿越.或者徒步EBC加攀登6000米级初级的山峰, 尼泊尔户外公司提供的攀登(Island Peak/Taboche/Mera Peak)+EBC徒步是个值得尝试和有一定挑战的项目.","tags":[{"name":"旅游","slug":"旅游","permalink":"https://edwardzhong.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"尼泊尔","slug":"尼泊尔","permalink":"https://edwardzhong.github.io/tags/%E5%B0%BC%E6%B3%8A%E5%B0%94/"},{"name":"加德满都","slug":"加德满都","permalink":"https://edwardzhong.github.io/tags/%E5%8A%A0%E5%BE%B7%E6%BB%A1%E9%83%BD/"},{"name":"博卡拉","slug":"博卡拉","permalink":"https://edwardzhong.github.io/tags/%E5%8D%9A%E5%8D%A1%E6%8B%89/"},{"name":"abc","slug":"abc","permalink":"https://edwardzhong.github.io/tags/abc/"},{"name":"act","slug":"act","permalink":"https://edwardzhong.github.io/tags/act/"},{"name":"poonhill","slug":"poonhill","permalink":"https://edwardzhong.github.io/tags/poonhill/"}]},{"title":"WebGL光照阴影映射","date":"2018-01-19T05:27:47.000Z","path":"2018/01/19/webglshadow/","text":"经过前面的学习,webgl的基本功能都已经掌握了,我们不仅掌握了着色器的编写,图形的绘制,矩阵的变换,添加光照,还通过对webgl的基础api封装,编写出了便利的工具库. 是时候进一步深入学习webgl的高级功能了,我认为要做逼真的3D特效,阴影绝对是一个必不可少的环节.现在我们就在之前光照的基础上添加阴影效果吧. 首先看一下阴影效果的实例：阴影综合(多物体高精度PCF)点光源聚光灯阴影 内容大纲我们以阴影综合(多物体高精度PCF)为例, 开始学习阴影相关知识. 帧缓冲 阴影映射(shadow mapping) 提高阴影精度 抗锯齿(PCF) 帧缓冲我们实现阴影效果使用的是叫阴影映射的技术, 而实现阴影映射需要用到帧缓冲区。默认情况下，WebGL 在颜色缓冲区绘图，使用隐藏面消除的话，还会用到深度缓冲区。即正常绘制的情况下包含： 颜色缓冲区 深度缓冲区 帧缓冲区对象 framebuffer object可以用来代替颜色缓冲区或深度缓冲区。绘制在帧缓冲区中的对象并不会直接显示canvas上，可以先对帧缓冲区中的内容进行一些处理再显示，或者直接用其中的内容作为纹理图像。在帧缓冲区中进行绘制的过程又称为离屏绘制 offscreen drawing。 绘制操作并不是直接发生在帧缓冲区中，而是发生在帧缓冲区所关联的对象 attachment上，一个帧缓冲区有3个关联对象： 颜色关联对象 color attachment，对应颜色缓冲区 深度关联对象 depth attachment，对应深度缓冲区 模板关联对象 stencil attachment，对应模板缓冲区。 而我们现在先有这个概念,来看看帧缓冲区的创建和配置: 创建帧缓冲区对象 gl.createFramebffer(). 创建文理对象并设置其尺寸和参数 gl.createTexture()、gl.bindTexture()、gl.texImage2D()、gl.Parameteri(). 创建渲染缓冲区对象 gl.createRenderbuffer(). 绑定渲染缓冲区对象并设置其尺寸 gl.bindRenderBuffer()、gl.renderbufferStorage(). 将帧缓冲区的颜色关联对象指定为一个文理对象 gl.frambufferTexture2D(). 将帧缓冲区的深度关联对象指定为一个渲染缓冲区对象 gl.framebufferRenderbuffer(). 检查帧缓冲区是否正确配置 gl.checkFramebufferStatus(). 在帧缓冲区中进行绘制 gl.bindFramebuffer(). 它的创建和配置是一个非常繁琐的过程,我们先熟悉了怎么使用,再慢慢研究它内部的原理,所以先把上面的步骤封装成一个黑盒子,我这里就是createFramebuffer这个函数. 阴影映射(shadow mapping)阴影映射的原理很简单，首先从光的角度渲染场景，从光的角度看到的所有东西都被点亮了，而看不见的部分一定是在阴影里.。想象有一个盒子和它的光源照射下的地板,由于光源会看到这个盒子而它后面的地板部分是看不到的.那么当视线角度变化的时候，从光源角度照不到的那部分地板就渲染为阴影，原理如下图 接着我们使用阴影映射的算法实现, 它要使用到前面介绍的帧缓冲区. 阴影映射要渲染两遍: 从光源的角度渲染场景,同时把场景的深度值当成纹理渲染到帧缓冲区,也就是把它当作数据容器. 从眼睛的角度渲染场景,把物体真正渲染到画布中,同时对比纹理的深度值,将阴影部分也渲染出来. 左边的图像是第一遍渲染的原理, 一个方向光源（所有的光线都是平行的）在立方体下面的表面投下阴影.我们通过用光源的视图投影矩阵渲染场景(从光线的角度)来创建景深图然后把它存储到帧缓冲区中. 右边的图形是第二遍渲染的原理, 从眼睛的视图投影矩阵渲染场景(从眼睛的角度), 光源角度下的xy坐标相同的c点和p点,p深度值比c要大, 那么它一定处于阴影当中,那么p点就渲染为阴影.来看实现以上功能的着色器代码,因为要渲染两遍,所以也就要建立两对的着色器(顶点/片段),顶点着色器比较简单,基本不涉及阴影映射,在此省略: 阴影片段着色器#ifdef GL_ES precision mediump float; #endifvoid main() &#123; gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0); //将深度值z存放到第一个分量r中&#125; 正常片段着色器深度值后面加了0.005,稍微大于1/256,即8位的表示范围(因为一个分量就是8位),这个是消除马赫带用的,不加这个值,画面会产生难看的条纹,具体的原理可查找马赫带,在此不细讲. precision mediump float;uniform sampler2D u_ShadowMap;varying vec4 v_PositionFromLight;varying vec4 v_color;void main() &#123; // 获取纹理的坐标 vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5; // 根据阴影xy坐标,获取纹理中对应的点,z值已经被之前的阴影着色器存放在该点的r分量中了,直接使用即可 vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);// 获取指定纹理坐标处的像素颜色rgba float visibility = (shadowCoord.z &gt; rgbaDepth.r + 0.005) ? 0.6 : 1.0;//大于阴影的z轴,说明在阴影中并显示为阴影*0.6,否则为正常颜色*1.0 gl_FragColor = vec4(v_color.rgb * visibility, v_color.a);&#125; 提高精度完成了最简单的阴影效果,但是当你把光源与物体的距离拉远,问题出来了,怎么看不到阴影了?这是距离超过了8位的存储范围,溢出的缘故.之前我们只使用了一个分量来存储,现在我们把其他的分量也利用起来吧,rgba一共32位. 阴影片段着色器这中间进行复杂的分解运算,并同时去除异常值,请看如下代码 /*** 分解保存深度值*/vec4 pack (float depth) &#123; // 使用rgba 4字节共32位来存储z值,1个字节精度为1/256 const vec4 bitShift = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0); const vec4 bitMask = vec4(1.0/256.0, 1.0/256.0, 1.0/256.0, 0.0); // gl_FragCoord:片元的坐标,fract():返回数值的小数部分 vec4 rgbaDepth = fract(depth * bitShift); //计算每个点的z值 rgbaDepth -= rgbaDepth.gbaa * bitMask; // Cut off the value which do not fit in 8 bits return rgbaDepth;&#125;void main() &#123; gl_FragColor = pack(gl_FragCoord.z);// 将z值分开存储到rgba分量中,阴影颜色的同时也是深度值z&#125; 正常片段着色器这里对应就要解码出深度值 /*** 释出深度值z*/float unpack(const in vec4 rgbaDepth) &#123; const vec4 bitShift = vec4(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0)); return dot(rgbaDepth, bitShift);&#125; 抗锯齿(PCF)解决了精度的问题,接着继续优化. 运行起来吧,阴影很粗糙有木有? 你看看下面左图,很严重的锯齿, 抗锯齿有很多种解决方案,我这里使用PCF, 也就是百分比渐近式过滤算法,因为它基于代码实现的,所以也叫软阴影. PCF的原理也很简单, 采集当前点周围像素的阴影值，并将其深度与所有采集的样本进行比较，最后对结果进行平均，这样就得到光线和阴影之间更平滑的过渡效果.下面右图是经过PCF处理之后的阴影,效果要自然得多了.我们看正常着色器的实现代码 vec3 shadowCoord = (v_positionFromLight.xyz/v_positionFromLight.w)/2.0 + 0.5;float shadows =0.0;float opacity=0.6;// 阴影alpha值, 值越小暗度越深float texelSize=1.0/1024.0;// 阴影像素尺寸,值越小阴影越逼真vec4 rgbaDepth;// 消除阴影边缘的锯齿for(float y=-1.5; y &lt;= 1.5; y += 1.0)&#123; for(float x=-1.5; x &lt;=1.5; x += 1.0)&#123; rgbaDepth = texture2D(u_shadowMap, shadowCoord.xy+vec2(x,y)*texelSize); shadows += shadowCoord.z-bias &gt; unpack(rgbaDepth) ? 1.0 : 0.0; &#125;&#125;shadows/=16.0;// 4*4的样本float visibility=min(opacity+(1.0-shadows),1.0);specular=visibility &lt; 1.0 ? vec3(0.0,0.0,0.0): specular;// 阴影处没有高光gl_FragColor = vec4((diffuse + ambient + specular) * visibility, v_color.a); 总结WebGL的阴影部分,涉及到了很多opengGL的底层,计算机图形学算法. 为了深入理解它,可真是花费了很多脑力,是到目前为止学习webgl的第一道坎,它里面的水很深.比如光是反锯齿部分就涉及到很多低层细节，算法的实现，显卡的性能问题等都是需要考虑的, 阴影部分后续还要慢慢查资料继续优化. 越是深入学习WebGL，就越觉得它相关的资料真是少，必须看openGL ES相关的东西才能解决,伤不起啊.","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL多模型光照综合实例","date":"2018-01-12T08:08:51.000Z","path":"2018/01/12/webglpolygons/","text":"WebGL是一个非常的接近硬件底层的光栅化API, 从非常类似C/C++风格的API调用方式就可以看出来, 习惯了高级语言的我们会觉得很不友好,觉得特别繁琐. 这个也是很多人觉得WebGL难的原因之一. 如果我们要使用WebGL做一些项目,毫无疑问要么使用Three.js之类的3D库, 要么需要对原生的API进行封装. 这段时间查看了一些WebGL工具库的源代码, 参考封装出了一个简单的工具库,这样往后用WebGL做小项目就方便多了. 经过前面章节的学习, WebGL的知识点掌握的差不多了, 终于到了做特效和Demo的阶段了,来看一下这节实现的特效：WebGL多物体多光源场景 内容大纲 实现图形绕坐标原点旋转, 同时给所有的物体增加环境光, 漫反射, 高光. 其中旋转功能使用矩阵复合变换实现; 光照部分比较复杂,实现了多个光源照射. 着色器 模型变换 着色器顶点着色器代码很简单,逐顶点传入坐标,法向量矩阵,模型矩阵,mvp矩阵. attribute vec4 a_position;attribute vec4 a_normal;uniform mat4 u_modelMatrix;uniform mat4 u_normalMatrix;uniform mat4 u_mvpMatrix;varying vec3 v_normal;varying vec3 v_position;void main() &#123; gl_Position = u_mvpMatrix * a_position; v_normal=vec3(u_normalMatrix * a_normal); v_position= vec3(u_modelMatrix * a_position);&#125; 片元着色器分别在左前方和右后方添加了平行光源和点光源, 平行光源的高光使用的是宾氏模型, 它的高光过渡效果比较平滑; 点光源的高光使用的是冯氏模型, 它的高光部分比较明亮, 反射的效果比较好.最后将两个光源照射产生的漫反射,高光亮度相加,就得到它们的综合光照效果了. precision mediump float;uniform vec3 u_lightColor;uniform vec3 u_lightPosition;uniform vec3 u_lightPosition2;uniform vec3 u_ambientColor;uniform vec3 u_viewPosition;uniform vec4 u_color;varying vec3 v_normal;varying vec3 v_position;void main() &#123; // 法向量归一化 vec3 normal = normalize(v_normal); // 计算环境光反射颜色 vec3 ambient = u_ambientColor * u_color.rgb; // 第一个光源:平行光 vec3 lightDirection = normalize(u_lightPosition); // 计算法向量和光线的点积 float cosTheta = max(dot(lightDirection, normal), 0.0); // 计算漫反射光的颜色 vec3 diffuse = u_lightColor * u_color.rgb * cosTheta; // 宾氏模型高光 float shininess =100.0; vec3 specularColor =vec3(1.0,1.0,1.0); vec3 viewDirection = normalize(u_viewPosition-v_position); vec3 halfwayDir = normalize(lightDirection + viewDirection); float specularWeighting = pow(max(dot(normal, halfwayDir), 0.0), shininess); vec3 specular = specularColor.rgb * specularWeighting * step(cosTheta,0.0); // 第二个光源:点光源 vec3 lightDirection2 = normalize(u_lightPosition2 - v_position.xyz); // 计算法向量和光线的点积 float cosTheta2 = max(dot(lightDirection2, normal), 0.0); // 计算漫反射光的颜色 vec3 diffuse2 = u_lightColor * u_color.rgb * cosTheta2; // 冯氏模型高光 float shininess2 =30.0; vec3 specularColor2 =vec3(1.0,1.0,1.0); vec3 reflectionDirection = reflect(-lightDirection2, normal); float specularWeighting2 = pow(max(dot(reflectionDirection, viewDirection), 0.0), shininess2); vec3 specular2 = specularColor2.rgb * specularWeighting2 * step(cosTheta,0.0); // 两个光源亮度相加 gl_FragColor = vec4(diffuse+diffuse2+ambient+specular+specular2,u_color.a); &#125; 模型变换js代码部分使用工具库封装了原生WebGL的很多细节, 现在写起代码来要愉快得多了, 感觉和写canvas差不了太多😂. 这里重点介绍模型变换部分, 其他部分代码的细节之前章节已经介绍过了,所以不再详述.首先初始化着色器,并创建program对象; 这里使用了多种图形(圆球,立方体,圆柱体,圆锥体), 所以分别为它们创建缓冲区, 缓冲区数据主要包括顶点,法向量,索引.接着创建200个图形对象, 给每个对象赋予 随机x/y轴角速度, 随机初始点, 随机颜色.最后终于到了动画的环节了, 绕原点旋转可以分解为x轴旋转, y轴旋转和位移. 要注意的是矩阵复合变换相乘的顺序, 也就是左乘和右乘是有区别的, 学过线性代数的应该都有印象. 这里要实现图形先位移z,然后再旋转, 那么对应的复合变换矩阵就是这样 &lt;模型矩阵&gt; &#x3D; &lt;绕x轴旋转矩阵&gt; * &lt;绕y轴旋转矩阵&gt; * &lt;位移矩阵&gt; 模型矩阵与视图投影矩阵相乘得出mvp矩阵, 对模型矩阵逆转置后还可以求出逆转置矩阵.将矩阵和变量的值传递给着色器, 输出对应的图形缓冲区,然后根据图形对象依次绘制图形, 最后调用requestAnimationFrame递归执行动画函数. var canvas = document.getElementById(\"canvas\"), gl = get3DContext(canvas, true);function main() &#123; if (!gl) &#123; console.log(\"Failed to get the rendering context for WebGL\"); return; &#125; var program = createProgramInfo(gl, [\"vs\", \"fs\"]), sphereBuffer = createBufferInfoFromArrays(gl, Sphere(50)), cubeBuffer = createBufferInfoFromArrays(gl, Cube()), cylinderBuffer = createBufferInfoFromArrays(gl, Cylinder(1, 3, 40)), coneBuffer = createBufferInfoFromArrays(gl, Cone(1, 3, 40)), buffers = [sphereBuffer, cubeBuffer, cylinderBuffer, coneBuffer]; for (var i = 0; i &lt; NUM; i++) &#123; Polygons.push(&#123; xRotation: Random(-60, 60), yRotation: Random(-60, 60), xAngle: 0, yAngle: 0, x: Random(-15, 15), y: Random(-15, 15), z: Random(3, 20), color: Color.rgbToWebgl(Color.hslToRgb(RandomHsl())) &#125;); &#125; gl.clearColor(0.1, 0.1, 0.1, 1); gl.enable(gl.DEPTH_TEST); gl.viewport(0, 0, canvas.width, canvas.height); //设置绘图区域 gl.useProgram(program.program); var modelMatrix = new Matrix4(), normalMatrix = new Matrix4(), mvpMatrix = new Matrix4(), last = Date.now(); (function animate() &#123; var now = new Date(), elapsed = now - last; last = now; // ... gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); setUniforms(program, &#123; u_lightColor: [1, 1, 1], u_lightPosition: LIGHT_POS, u_lightPosition2: LIGHT_POS2, u_ambientColor: [0.4, 0.4, 0.4], u_viewPosition: [eyeX, eyeY, eyeZ] &#125;); var buffer; Polygons.forEach((polygon, i) =&gt; &#123; polygon.xAngle += (polygon.xRotation * elapsed) / 1000; polygon.yAngle += (polygon.yRotation * elapsed) / 1000; polygon.xAngle %= 360; polygon.yAngle %= 360; // 模型矩阵 modelMatrix.setRotate(polygon.xAngle, 1, 0, 0); modelMatrix.rotate(polygon.yAngle, 0, 1, 0); modelMatrix.translate(0, 0, polygon.z); // modelMatrix.translate(polygon.x,polygon.y,polygon.z); // 每次重置mvp矩阵 mvpMatrix.setPerspective( 45, canvas.width / canvas.height, 1.0, 200.0 ); mvpMatrix.lookAt(eyeX, eyeY, eyeZ, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); mvpMatrix.multiply(modelMatrix); // 逆转置矩阵 normalMatrix.setInverseOf(modelMatrix); normalMatrix.transpose(); buffer = buffers[i % buffers.length]; setBuffersAndAttributes(gl, program, buffer); setUniforms(program, &#123; u_color: polygon.color, u_modelMatrix: modelMatrix.elements, u_normalMatrix: normalMatrix.elements, u_mvpMatrix: mvpMatrix.elements &#125;); gl.drawElements( gl.TRIANGLES, buffer.numElements, buffer.indexType, 0 ); &#125;); requestAnimationFrame(animate); &#125;)();&#125; 总结使用工具类省略了很多繁琐无聊的部分,不用再去扣语法细节.比如获取变量地址, 赋值, 创建缓冲区. 我们可以把精力都集中到业务逻辑方面.","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"WebGL学习(3) - 3D模型","date":"2017-12-25T19:19:36.000Z","path":"2017/12/26/webglspitfire/","text":"相信很多人是以创建逼真酷炫的三维效果为目标而学习webGL的吧，首先我就是😂。我掌握了足够的webGL技巧后，正准备大展身手时，遇到了一种尴尬的情况：还是做不出想要的东西😭。为啥呢，因为没有3D模型可供操作啊，纯粹用代码构建复杂的3D模型完全不可想象。 必须使用3dMax，maya，以及开源的blender等建模软件进行构建。既然已经入了webGL的坑了，那也只能硬着头皮继续学习3D建模，断断续续学了一个多月的blender教程，总算入门了。 这节主要学习如何导入模型文件，然后用代码应用效果，操作模型。首先展示下我的大作，喷火战斗机的3D模型：webGL 喷火战斗机 内容大纲 模型文件 着色器 光照 模型变换 事件处理 模型文件blender导出的模型文件plane.obj, 同时还包括材质文件plane.mtl。模型包括2800多个顶点，2200多个面，共200多k的体积，内容比较大，所以只能将文件加载入html文件比较方便。 怎么加载呢？一般会使用ajax获取，但我这里有更方便的办法。那就是将模型文件内容预编译直出到html中，这样不但提高了加载性能，开发也更方便。具体可参考我之前的文章：前端快速开发模版 这里使用我之前的开发模版, 将模型(obj、mtl)文件以字符串的形式写入text/template模版中，同时将GLSL语言写的着色器也预编译到html中。到时用gulp的命令构建页面，所有内容就会自动生成到页面中，html部分的代码如下所示： &#123;% extends '../layout/layout.html' %&#125;&#123;% block title %&#125;spitfire fighter&#123;% endblock %&#125;&#123;% block js %&#125;&lt;script src=\"./lib/webgl.js\"&gt;&lt;/script&gt;&lt;script src=\"./lib/objParse.js\"&gt;&lt;/script&gt;&lt;script src=\"./lib/matrix.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/index.js\"&gt;&lt;/script&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class=\"content\"&gt;&lt;p&gt;上下左右方向键 调整视角，W/S/A/D键 旋转模型， +/-键 放大缩小&lt;/p&gt;&lt;canvas id=\"canvas\" width=\"800\" height=\"600\"&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;!-- obj文件 --&gt;&lt;script type=\"text/template\" id=\"tplObj\"&gt;&#123;% include '../model/plane.obj' %&#125;&lt;/script&gt;&lt;!-- mtl文件 --&gt;&lt;script type=\"text/template\" id=\"tplMtl\"&gt;&#123;% include '../model/plane.mtl' %&#125;&lt;/script&gt;&lt;!-- 顶点着色器 --&gt;&lt;script type=\"x-shader/x-vertex\" id=\"vs\"&gt;&#123;% include '../glsl/vs.glsl' %&#125;&lt;/script&gt;&lt;!-- 片元着色器 --&gt;&lt;script type=\"x-shader/x-fragment\" id=\"fs\"&gt;&#123;% include '../glsl/fs.glsl' %&#125; &lt;/script&gt;&#123;% endblock %&#125; obj文件obj文件包含的是模型的顶点法线索引等信息。这里以最简单的立方体为例。 v 几何体顶点 vt 贴图坐标点 vn 顶点法线 f 面：顶点索引 / 纹理坐标索引 / 法线索引 usemtl 使用的材质名称 # Blender v2.79 (sub 0) OBJ File: &#39;&#39;# www.blender.orgmtllib cube.mtlo Cubev -0.442946 -1.000000 -1.000000v -0.442946 -1.000000 1.000000v -2.442946 -1.000000 1.000000v -2.442945 -1.000000 -1.000000v -0.442945 1.000000 -0.999999v -0.442946 1.000000 1.000001v -2.442946 1.000000 1.000000v -2.442945 1.000000 -1.000000vn 0.0000 -1.0000 0.0000vn 0.0000 1.0000 0.0000vn 1.0000 0.0000 0.0000vn -0.0000 -0.0000 1.0000vn -1.0000 -0.0000 -0.0000vn 0.0000 0.0000 -1.0000usemtl Materials offf 1&#x2F;&#x2F;1 2&#x2F;&#x2F;1 3&#x2F;&#x2F;1 4&#x2F;&#x2F;1f 5&#x2F;&#x2F;2 8&#x2F;&#x2F;2 7&#x2F;&#x2F;2 6&#x2F;&#x2F;2f 1&#x2F;&#x2F;3 5&#x2F;&#x2F;3 6&#x2F;&#x2F;3 2&#x2F;&#x2F;3f 2&#x2F;&#x2F;4 6&#x2F;&#x2F;4 7&#x2F;&#x2F;4 3&#x2F;&#x2F;4f 3&#x2F;&#x2F;5 7&#x2F;&#x2F;5 8&#x2F;&#x2F;5 4&#x2F;&#x2F;5f 5&#x2F;&#x2F;6 1&#x2F;&#x2F;6 4&#x2F;&#x2F;6 8&#x2F;&#x2F;6 mtl文件mtl文件包含的是模型的材质信息 Ka 环境色 rgb Kd 漫反射色,材质颜色 rgb Ks 高光色，材质高光颜色 rgb Ns 反射高光度 指定材质的反射指数 Ni 折射值 指定材质表面的光密度 d 透明度 # Blender MTL File: &#39;None&#39;# Material Count: 1newmtl MaterialNs 96.078431Ka 1.000000 1.000000 1.000000Kd 0.640000 0.640000 0.640000Ks 0.500000 0.500000 0.500000Ke 0.000000 0.000000 0.000000Ni 1.000000d 1.000000illum 2 知道了obj和mtl文件的格式，我们需要做的就是读取它们，逐行分析，这里使用的objParse读取解析，想知道内部原理，可以查看源代码，这里不详述。 提取出需要的信息后，就可将模型信息写入缓冲区，然后渲染出来。 var canvas = document.getElementById('canvas'), gl = get3DContext(canvas, true), objElem = document.getElementById('tplObj'), mtlElem = document.getElementById('tplMtl');function main() &#123; //... //获取变量地址 var program = gl.program; program.a_Position = gl.getAttribLocation(gl.program, 'a_Position'); //... // 创建空数据缓冲 var vertexBuffer = createEmptyArrayBuffer(gl, program.a_Position, 3, gl.FLOAT); //... // 分析模型字符串 var objDoc = new OBJDoc('plane',objElem.text,mtlElem.text); if(!objDoc.parse(1, false))&#123;return;&#125; var drawingInfo = objDoc.getDrawingInfo(); // 将数据写入缓冲区 gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, drawingInfo.vertices, gl.STATIC_DRAW); //...&#125; 着色器顶点着色器顶点着色器比较简单，和之前的区别比较大的是，把计算颜色光照部分移到了片元着色器，这样可以实现逐片元光照，效果会更加逼真和自然。 attribute vec4 a_Position;//顶点位置attribute vec4 a_Color;//顶点颜色attribute vec4 a_Scolor;//顶点高光颜色attribute vec4 a_Normal;//法向量uniform mat4 u_MvpMatrix;//mvp矩阵uniform mat4 u_ModelMatrix;//模型矩阵uniform mat4 u_NormalMatrix;varying vec4 v_Color;varying vec3 v_Normal;varying vec3 v_Position;void main() &#123; gl_Position = u_MvpMatrix * a_Position; // 计算顶点在世界坐标系的位置 v_Position = vec3(u_ModelMatrix * a_Position); // 计算变换后的法向量并归一化 v_Normal = normalize(vec3(u_NormalMatrix * a_Normal)); v_Color = a_Color;&#125; 光照光照相关的计算主要在片元着色器中，首先科普一下光照的相关信息。 物体呈现出颜色亮度就是表面的反射光导致，计算反射光公式如下：&lt;表面的反射光颜色&gt; &#x3D; &lt;漫反射光颜色&gt; + &lt;环境反射光颜色&gt; + &lt;镜面反射光颜色&gt;1. 其中漫反射公式如下：&lt;漫反射光颜色&gt; &#x3D; &lt;入射光颜色&gt; * &lt;表面基底色&gt; * &lt;光线入射角度&gt;光线入射角度可以由光线方向和表面的法线进行点积求得：&lt;光线入射角度&gt; &#x3D; &lt;光线方向&gt; * &lt;法线方向&gt;最后的漫反射公式如下：&lt;漫反射光颜色&gt; &#x3D; &lt;入射光颜色&gt; * &lt;表面基底色&gt; * (&lt;光线方向&gt; * &lt;法线方向&gt;)2. 环境反射光颜色根据如下公式得到：&lt;环境反射光颜色&gt; &#x3D; &lt;入射光颜色&gt; * &lt;表面基底色&gt;3. 镜面（高光）反射光颜色公式，这里使用的是冯氏反射原理&lt;镜面反射光颜色&gt; &#x3D; &lt;高光颜色&gt; * &lt;镜面反射亮度权重&gt; 其中镜面反射亮度权重又如下&lt;镜面反射亮度权重&gt; &#x3D; (&lt;观察方向的单位向量&gt; * &lt;入射光反射方向&gt;) ^ 光泽度 片元着色器着色器代码就是对上面公式内容的演绎 precision mediump float;uniform vec3 u_LightPosition;//光源位置uniform vec3 u_diffuseColor;//漫反射光颜色uniform vec3 u_AmbientColor;//环境光颜色uniform vec3 u_specularColor;//镜面反射光颜色uniform float u_MaterialShininess;// 镜面反射光泽度varying vec3 v_Normal;//法向量varying vec3 v_Position;//顶点位置varying vec4 v_Color;//顶点颜色void main() &#123; // 对法线归一化 vec3 normal = normalize(v_Normal); // 计算光线方向(光源位置-顶点位置)并归一化 vec3 lightDirection = normalize(u_LightPosition - v_Position); // 计算光线方向和法向量点积 float nDotL = max(dot(lightDirection, normal), 0.0); // 漫反射光亮度 vec3 diffuse = u_diffuseColor * nDotL * v_Color.rgb; // 环境光亮度 vec3 ambient = u_AmbientColor * v_Color.rgb; // 观察方向的单位向量V vec3 eyeDirection = normalize(-v_Position); // 反射方向 vec3 reflectionDirection = reflect(-lightDirection, normal); // 镜面反射亮度权重 float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), u_MaterialShininess); // 镜面高光亮度 vec3 specular = lightColor.rgb * specularLightWeighting ; gl_FragColor = vec4(ambient + diffuse + specular, v_Color.a);&#125; 模型变换这里先设置光照相关的初始条件，然后是mvp矩阵变换和法向量矩阵相关的计算，具体知识点可参考之前的文章WebGL学习(2) - 3D场景 要注意的是逆转置矩阵，主要用于计算模型变换之后的法向量，有了变换后的法向量才能正确计算光照。 求逆转置矩阵步骤1.求原模型矩阵的逆矩阵2.将逆矩阵转置&lt;变换后法向量&gt; &#x3D; &lt;逆转置矩阵&gt; * &lt;变换前法向量&gt; 给着色器变量赋值然后绘制出模型，最后调用requestAnimationFrame不断执行动画。矩阵的旋转部分可结合下面的keydown事件进行查看。 function main() &#123; //... // 光线方向 gl.uniform3f(u_LightPosition, 0.0, 2.0, 12.0); // 漫反射光照颜色 gl.uniform3f(u_diffuseColor, 1.0, 1.0, 1.0); // 设置环境光颜色 gl.uniform3f(u_AmbientColor, 0.5, 0.5, 0.5); // 镜面反射光泽度 gl.uniform1f(u_MaterialShininess, 30.0); var modelMatrix = new Matrix4(); var mvpMatrix = new Matrix4(); var normalMatrix = new Matrix4(); var n = drawingInfo.indices.length; (function animate() &#123; // 模型矩阵 if (notMan) &#123; angleY += 0.5; &#125; modelMatrix.setRotate(angleY % 360, 0, 1, 0); // 绕y轴旋转 modelMatrix.rotate(angleX % 360, 1, 0, 0); // 绕x轴旋转 var eyeY = viewLEN * Math.sin((viewAngleY * Math.PI) / 180), len = viewLEN * Math.cos((viewAngleY * Math.PI) / 180), eyeX = len * Math.sin((viewAngleX * Math.PI) / 180), eyeZ = len * Math.cos((viewAngleX * Math.PI) / 180); // 视点投影 mvpMatrix.setPerspective(30, canvas.width / canvas.height, 1, 300); mvpMatrix.lookAt( eyeX, eyeY, eyeZ, 0, 0, 0, 0, viewAngleY &gt; 90 || viewAngleY &lt; -90 ? -1 : 1, 0 ); mvpMatrix.multiply(modelMatrix); // 根据模型矩阵计算用来变换法向量的矩阵 normalMatrix.setInverseOf(modelMatrix); normalMatrix.transpose(); // 模型矩阵 gl.uniformMatrix4fv(u_ModelMatrix, false, modelMatrix.elements); // mvp矩阵 gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); // 法向量矩阵 gl.uniformMatrix4fv(u_NormalMatrix, false, normalMatrix.elements); // 清屏|清深度缓冲 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 根据顶点索引绘制图形(图形类型，绘制顶点个数，顶点索引数据类型，顶点索引中开始绘制的位置) gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_SHORT, 0); requestAnimationFrame(animate); &#125;)();&#125; 事件处理+/- 键实现放大/缩小场景的功能；WSAD键实现模型的旋转，也就是实现绕x轴和y轴旋转；上下左右方向键实现的是视点的旋转。矩阵变换的相关实现参考上面代码的动画部分。 模型旋转和视点旋转看着很相似，其实又有不同的。视点的旋转是整个场景比如光照模型等都是跟着变化的，如果以场景做参照物，它就相当于人改变观察位置观看物体。而模型旋转呢，它只旋转模型自身，外部的光照和场景都是不变的，以场景做参照物，相当于人在同一位置观看模型在运动。从demo的光照可以看出两种方式的区别。 document.addEventListener( \"keydown\", function(e) &#123; if ([37, 38, 39, 65, 58, 83, 87, 40].indexOf(e.keyCode) &gt; -1) notMan = false; switch (e.keyCode) &#123; case 38: //up viewAngleY -= 2; if (viewAngleY &lt; -270) viewAngleY += 360; break; case 40: //down viewAngleY += 2; if (viewAngleY &gt; 270) viewAngleY -= 360; break; case 37: //left viewAngleX += 2; break; case 39: //right viewAngleX -= 2; break; case 87: //w angleX -= 2; break; case 83: //s angleX += 2; break; case 65: //a angleY += 2; break; case 68: //d angleY -= 2; break; case 187: //zoom in if (viewLEN &gt; 6) viewLEN--; break; case 189: //zoom out if (viewLEN &lt; 30) viewLEN++; break; default: break; &#125;&#125;, false ); 总结最后，个人感觉建立3D模型还是挺费时间，需要花心机慢慢调整，才能做出比较完美的模型。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"NodeJS网络爬虫","date":"2017-12-01T09:10:02.000Z","path":"2017/12/01/netgrab/","text":"网上有很多其他语言平台版本的网络爬虫，比如Python，Java。那怎么能少得了我们无所不能的javascript呢😂？这个和之前给产品狗开发的批量图片下载配置工具，原理很相似，核心就是调用Node的http模块。 网络爬虫基本就由如下部分组成： 程序入口 请求模块 数据解释 程序入口可以用web页面实现，还可以在网页上显示抓取的数据和分析结果；但是这个我只想把精力花在核心模块，页面和样式不想花太多精力去弄。所以呢，我就开发个node的命令行工具，这个比较成熟的就是commander了。 请求模块方面，我只想抓取百度的页面，还有知乎的页面，它们的请求都是https协议的，好在Node的https和http模块功能几乎是一样的，这里需要做的就是熟悉它的api就好了，也是easy。 数据解释模块，因为抓取出来的页面内容是字符串，所以可以用正则表达式去匹配，但是这样太麻烦了。有没有更好的方式？抓取回来可都是html内容，用jQuery以操作dom的方式去解析数据不是很方便嘛，恰好有个服务端的jquery库cheerio。 页面抓取完，数据也分析出来了，那就非常简单了，你可以选择存入数据库或者写入文件保存。接下来就开始实现上面的功能模块。 程序入口开始配置和初始化commander，具体的使用方式参考官方的文档：*https://www.npmjs.com/package/commander*，这里不再详细解释用法了,下面开始配置commander。首先要在package.json添加如下节点，表示注册了一个命令行 “grab”。 \"bin\": &#123; \"grab\": \"bin/grab.js\"&#125;, 接着在grab.js开始定义commander，最后我们就可以这样执行命令行：”grab baidu &lt;内容&gt;”，当然可以用bd简写代替baidu，知乎的定义和百度是一样，这里不再重复介绍了。 program // .allowUnknownOption()//不报错误 .version('0.0.1') .usage('这是我的网络爬虫程序😎' +'\\n grap [option]' +'\\n bd baidu: baidu search' +'\\n zh zhihu: zhihu search');program .command('baidu &lt;cmd&gt;') .alias('bd') .description('baidu search baidu') .option(\"-t, --tieba\", \"baidu tieba\") .action(function(cmd, options)&#123; console.log('baidu search \"%s\":', cmd); request.baiduSearch(cmd); &#125;).on('--help', function() &#123; console.log(' Examples:'); console.log(); console.log(' grab bd &lt;cmd&gt;'); console.log(' grab baidu &lt;cmd&gt;'); console.log(); &#125;);program.parse(process.argv); 请求模块https模块发起请求主要有两种方式，这里稍微封装了下： get方式，主要针对的是简单的请求，只需要传递url发起get请求。知乎的调用这个就可以了。 function get(url,callback) &#123; return https.get(url,function(response) &#123; var body = ''; response.on('data', function(data) &#123; body += data; &#125;); response.on('end', function() &#123; callback(body); &#125;); &#125;);&#125; requerst方式，不但可以发起get请求，也可以发起post请求，还可以修改端口，请求header。这个主要是针对限制比较多的百度爬虫。百度必须设置header，同时百度请求参数也比较复杂，需要专门配置，具体可参考网上的资料。 function request(options,callback)&#123; // var postData = qs.stringify(&#123;&#125;); var body, req = https.request(options, (res) =&gt; &#123; console.log('STATUS: ' + res.statusCode); // console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8'); res.on('data', function (chunk) &#123; body+=chunk; &#125;); res.on('end',function()&#123; callback(body) &#125;); &#125;); req.on('error', function(e) &#123; console.log('problem with request: ' + e.message); &#125;); // write data to request body // req.write(postData); req.end();&#125;function baiduRequset(pageNo,pageSize,keyword)&#123; var path='/s?'+qs.stringify(&#123; ie:'utf-8', f:8, rsv_bp:1, tn:'baidu', rn:pageSize, pn:pageNo*pageSize, wd:keyword &#125;), options = &#123; hostname: 'www.baidu.com', port: 443, path: path, method: 'GET', headers: &#123; 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36' &#125; &#125;; request(options,function(body)&#123; saveFile(pageNo,keyword,body); showBaiduResult(pageNo,body); &#125;);&#125; 数据解释抓取数据之后，我们需要做的就是调用cheerio，以jquery获取dom内容的方式获取结果，并显示出来，当然也可以保存文件或数据库。 /** * 显示结果 * @param &#123;[type]&#125; pageNo [description] * @param &#123;[type]&#125; body [description] * @return &#123;[type]&#125; [description] */function showBaiduResult(pageNo,body)&#123; var title,summary,link, reg=/&lt;[^&lt;&gt;]+&gt;/g, $ = cheerio.load(body,&#123;decodeEntities: false&#125;); $('#content_left .result').each(function(i,item)&#123; var $a = $(item).find('h3 a'); title = $a.html(); link = $a.attr('href'); summary=$(item).find('.c-abstract').html(); if(title)&#123; console.log(`第$&#123;pageNo+1&#125;页 第$&#123;i+1&#125;条`); console.log(`link: $&#123;link&#125;`.green); // console.log(`title: $&#123;title&#125;`); console.log('title: '); ouputColor(title); if(summary)&#123; // console.log(`summary: $&#123;summary&#125;`); console.log('summary: '); ouputColor(summary); &#125; &#125; console.log('------------------------------'); console.log(''); &#125;);&#125;// 知乎exports.zhihuSearch=function(keyword,cb)&#123; get('https://www.zhihu.com/search?type=content&amp;q='+keyword,function(content)&#123; var title,summary; var $ = cheerio.load(content,&#123;decodeEntities: false&#125;); saveFile(0,keyword,content); $('.list .item').each(function(i,item)&#123; title=$(item).find('.js-title-link').html(); summary=$(item).find('.summary').html(); if(title)&#123; // title=(''+title).replace(/&lt;[^&lt;&gt;]+&gt;/g,''); // summary=(''+summary).replace(/&lt;.+&gt;/g,''); console.log('title: '); ouputColor(title); if(summary)&#123; console.log('summary: '); ouputColor(summary); &#125; &#125; console.log('------------------------------'); console.log(''); &#125;); &#125;);&#125;; 执行爬虫功能完成后，先试验一下抓取知乎的内容 grab zh webgl 抓取到的html文件保存在download文件夹，同时在命令行显示抓取结果。 如果要执行百度的爬虫，运行如下命令行即可 grab bd webgl 总结这里完成的是最基本的爬虫功能，代码请看net_grab","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"node","slug":"node","permalink":"https://edwardzhong.github.io/tags/node/"},{"name":"cheerio","slug":"cheerio","permalink":"https://edwardzhong.github.io/tags/cheerio/"},{"name":"commander","slug":"commander","permalink":"https://edwardzhong.github.io/tags/commander/"}]},{"title":"简洁后台管理模版","date":"2017-11-30T08:45:48.000Z","path":"2017/11/30/managedemo/","text":"之前给客户开发一个简单的后台管理系统，本来准备套用AdminLTE的，但客户嫌弃太臃肿，而且又需要有多tab页面切换，于是从我代码库中找到好久前就写过的管理后台，根据需求重写。这是基于jQuery，加上自己编写基础样式，从零搭建起来的框架，在这个轻量级模版的基础上进行开发vue项目。现在顺便将这个模版搭建成我的前端demo的管理系统，而这篇文章就讲述下如何实现简单的后台管理系统。 效果请看: manage-demo:https://edwardzhong.github.io/sites/manage-demo/ 项目架构基于gulp自动化工具，使用less预编译，使用swig模版引擎编译html。 基础样式base.css，字体库raleway，图标库fontello，js基础库jQuery。 同时使用webpack为vue.js配置好开发环境，在src文件夹里面可以直接开发vue项目，里面有简单的vue样例。当然想用react的也可以更改为react库。 文件目录 dist 文件生成目录 src 源文件目录，里面为vue项目的文件 img 图片文件夹 lib 类库文件夹 less less文件 pages 页面文件夹 index.html 首页(母板页) gulpfile.js webpack.config.js package.json &emsp;&emsp;而我们现在要做的就是最外层的框架页，也就是母板页，为了使其更加轻便，同时适应更多类型的项目，只使用了最基础的jquery来实现功能。 基础样式库每个前端开发者做过大量项目后，基本都会有自己的样式库吧。我的base-css是参考了部分bootstrap和pure的样式库，精简了很多组件，非常的轻量级。详细代码请看*https://github.com/edwardzhong/base-csss*，less预编译，gulp自动化，可以自由选择所需要的组件后再打包，经过这样定制打包后的样式体积就更加的小了。该样式库主要包括如下组件： normalize：html5标签修复 grid：响应式网格 alert button breadcrumb dialog form menu pager pagination panel tab table 有了基础样式之后，我们搭建系统就方便很多了。 实现母板页后台管理系统最重要的就是母板页(index.html)，我们一步步来实现它。 布局基本就是左右布局：左边导航部分固定宽度，右边内容部分宽度自适应。实现这个布局有很多种方式，这里不详叙，从实现动画和自适应方面考虑，我采用的是绝对定位的方式。左边的导航栏隐藏显示动画是通过设置margin-left和transition属性实现的。 /*左边导航栏*/.menu-wrap &#123; position: absolute; transition: margin-left .3s ease-in-out; top: 50px;left: 0; width: 200px; height: calc(100% - 50px); overflow-y: scroll;&#125;/*右边内容部分*/.main &#123; height: calc(100% - 50px); overflow: hidden; margin-left: 200px; transition: margin-left .3s ease-in-out;&#125; 导航栏导航栏就是使用ul列表布局，如果要实现多级的子菜单就在相应li下再嵌套一个ul列表即可，然后添加样式，添加css3动画等。布局示例请看如下的代码： &lt;ul id=\"menuList\" class=\"side-menu\"&gt; &lt;li class=\"children\"&gt; &lt;a data-type=\"tab\" title=\"Html Component\" href=\"javascript:;\"&gt;&lt;i class=\"icon-doc-text\"&gt;&lt;/i&gt;&lt;span&gt;Html Component&lt;/span&gt;&lt;/a&gt; &lt;ul style=\"height: 0px;\"&gt; &lt;li&gt;&lt;a data-type=\"tab\" title=\"Alert\" href=\"./pages/alert.html\"&gt;&lt;span&gt; Alert&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a data-type=\"tab\" title=\"Page\" href=\"./pages/page.html\"&gt;&lt;span&gt; Page&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a data-type=\"tab\" title=\"Panel\" href=\"./pages/panel.html\"&gt;&lt;span&gt; Panel&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a title=\"My Blog\" href=\"/\"&gt;&lt;i class=\"icon-bookmark\"&gt;&lt;/i&gt;&lt;span&gt;My Blog&lt;/span&gt;&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 实现多tab内容面很多后台管理模版都是通过模版引擎编译页面内容，这样生成的每个页面都会包含导航栏和内容块，这样的好处就是编写比较简单。但是点击导航栏里的链接就回重新加载整个页面，在网速不佳的情况，就会看到整个页面在跳动。 另一种方式是使用frameset或iframe，嵌套页面。这样内容页和母版页是分离的，分别加载的。这样会体验比较好，编写的代码也是隔离的。但也是隔离了作用域，所以要专门处理框架内外层通信的问题，同时编写也会稍麻烦。 我这里选用的是iframe方案，因为使用多iframe实现母板页多tab显示比较方便。这样左边导航栏点击后就会创建新的iframe并填入链接，然后再将该iframe插入内容块。同时tab栏也对应插入一一对应的tab标签，这样点击tab标签就隐藏显示对应iframe块。请看如下的html代码结构： &lt;div id=\"main\" class=\"main\"&gt; &lt;nav class=\"nav\"&gt; &lt;!-- tab标签 --&gt; &lt;ul id=\"nav\" class=\"menu-tabs\"&gt; &lt;li&gt;&lt;a&gt;...&lt;/a&gt;&lt;li&gt; &lt;li&gt;&lt;a&gt;...&lt;/a&gt;&lt;li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;!-- 页面iframe --&gt; &lt;div class=\"page-con\"&gt; &lt;div class=\"page\"&gt;&lt;iframe src=\"...\"&gt;&lt;/iframe&gt;&lt;/div&gt; &lt;div class=\"page\"&gt;&lt;iframe src=\"...\"&gt;&lt;/iframe&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 母板页的添加iframe和添加tab标签的代码 //添加页面function appendPage(url)&#123; $('.page-con .page').removeClass('active'); $('.page-con').append('&lt;div class=\"page active\"&gt;&lt;iframe src=\"'+url+'\" frameborder=\"0\" width=\"100%\" height=\"100%\"&gt;&lt;/iframe&gt;&lt;/div&gt;');&#125;//添加tabfunction appendTab(txt)&#123; $nav.find('li').removeClass('active'); $nav.append('&lt;li data-txt=\"'+txt+'\" class=\"active\"&gt;&lt;a href=\"javascript:;\"&gt;'+txt+'&lt;i class=\"close\"&gt;×&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;'); var w=setTabWidth(); //移动到新增tab $navParent.animate(&#123;'scrollLeft':w+'px'&#125;,600); &#125; 当然这中间有很多细节，比如添加，删除，选择，滚动页面，tab栏的选择关闭，tab栏内容超出页面宽度的处理，当前tab如何滚动到当前显示区等，具体实现可以查看github代码。 内容页完成母板页之后，接下来就是添加内容页了。首先就是定义导航链接，添加了自定义属性data-type=”tab”的链接就是要在右边内容iframe打开的页面，否则就是打开外部链接了。每个在iframe打开的a标签要配置title属性，因为我是通过title来区分页面是否已经打开过，tab中已经存在就不再打开。 内容页既可以是静态页面，也可以用vue，react构造页面，demo里面有部分页面使用了vue来实现逻辑功能。 &lt;ul id=\"menuList\" class=\"side-menu\"&gt; &lt;!-- 要添加到iframe中的链接 --&gt; &lt;li&gt;&lt;a data-type=\"tab\" title=\"Alert\" href=\"./pages/alert.html\"&gt;&lt;span&gt; Alert&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;!-- 外部链接跳转 --&gt; &lt;li&gt;&lt;a title=\"My Blog\" href=\"/\"&gt;&lt;i class=\"icon-bookmark\"&gt;&lt;/i&gt;&lt;span&gt;My Blog&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 总结这个模版还有很多地方需要完善，可以在此基础上修改添加相应功能，也可以在此基础上使用vue，react实现内容页的功能。 具体细节请查看代码：https://github.com/edwardzhong/manage-demo","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://edwardzhong.github.io/tags/vue/"},{"name":"gulp","slug":"gulp","permalink":"https://edwardzhong.github.io/tags/gulp/"}]},{"title":"前端快速开发模版","date":"2017-11-27T11:50:57.000Z","path":"2017/11/27/projecttemplate/","text":"之前一直在开发移动端的单页面应用，而移动web对性能和效果要求是比较苛刻的，所以用的都是轻量级的框架体系。基本上是Zepto加自己开发的单页面框架，再加上若干简单的库。这样前端要加载的文件很小，修改起来也非常方便，同时这样的轻量级的体系使用gulp进行自动化管理也是非常合适的。 自从开发react项目后，对它的工程化和开发模式也是开了眼界，标准的框架体系就是重量级的react+redux+webpack。开发大型项目和后台管理系统用react，vue确实是不错的。但是开发一些小项目，比如前端h5之类的又有杀鸡用牛刀的感觉。 于是借鉴webpack工程化思想动手写了个前端快速开发模版，用于开发快速简洁的项目，比如之前的单页面应用。而这个项目模版就是类似前端开发的脚手架了，基本的思路就是自动化和前端编译，主要达到以下目的： 使用less预编译css，使用autoprefixer进行样式兼容 js代码用babel编译，因此可基于es6，es7编写代码 类库文件使用npm包，js文件使用browserify组织和打包，不再使用sea，require之类的加载器 html代码使用swig模版引擎进行组织和预编译 静态资源版本使用rev管理，当css或js文件内容有变化，打包时自动更新版本 前端开发基础样式，框架的整合。 工具链 构建工具gulp 编译打包工具browserify 代码编译babel css兼容autoprefixer css预编译less html代码预编译模版swig 前端代码版本更新rev 公共类库 jQuery Zepto 自己开发的简洁单页面框架app.js 图标fontello 字体reboto 基础样式base.css 文件目录结构 css: css文件 less: less文件 js: js文件 dist: 打包生成的项目文件 layout: html母板 lib: 公共类库 template: html页面 项目自动化没有使用重量级的webpack，而是使用轻量级的gulp和browserify 公共类库公共类库的文件，主要有基础样式base.css，图标样式reboto，字体样式fontello，单页面框架app，直接拷贝到dist文件就ok。其他npm包跟nodejs项目一样在node_modules中，不需要处理。 //复制公共库目录下的所有内容gulp.task('copy',function()&#123; return gulp.src('./lib/**') .pipe(gulp.dest('./dist/lib/'));&#125;); css文件首先将less文件转为css，用autoprefixer添加兼容性前缀，合并压缩，放到dist目录，最后用rev插件生成版本信息，这个后面用于替换更新链接用。 //编译css，添加兼容后缀，压缩gulp.task('css', function() &#123; return gulp.src('./less/*.less') .pipe(less()) // .pipe(concatCss(\"index.css\")) .pipe(postcss([ autoprefixer(&#123; \"browsers\": [\"last 2 version\", \"&gt; 0.5%\", \"ie 6-8\",\"Firefox &lt; 20\"] // \"browsers\": [\"last 2 version\", \"&gt; 0.1%\"] &#125;) ])) .pipe(cleanCSS()) // .pipe(rename(&#123;suffix: '.min'&#125;)) // .pipe(gulp.dest('./dist/css')); .pipe(rev()) .pipe(gulp.dest('./dist/css')) .pipe(rev.manifest()) .pipe(gulp.dest('./rev/css'));&#125;); js文件我这里有两个入口文件，可以随时将新入口文件添加到scripts数组中，这里做的就是使用babel转换代码，然后将外部文件，npm包打包进来，生成sourcemap，输出到dist文件夹，最后一样用rev插件生成版本信息。 var scripts=['app','index'];scripts.map(name=&gt;&#123; gulp.task(name,function()&#123; return browserify(&#123; entries:'./js/'+name+'.js', //entries file name debug:true // set true so the bundle file can generate sourcemap &#125;) .transform(babelify,&#123; plugins: [\"transform-runtime\"], presets: [ 'es2015', //convert to es5 'stage-0' //es7 ] &#125;) .bundle() //merge .pipe(source(name+'.js')) .pipe(buffer()) // .pipe(uglify()) .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) //External sourcemap file .pipe(sourcemaps.write('./')) .pipe(rev()) .pipe(gulp.dest('./dist/js/')) .pipe(rev.manifest(name+'.json')) .pipe(gulp.dest('./rev/js/')); &#125;);&#125;); html文件html编译我使用的是模版引擎是swig，这里用的是gulp-swig插件，当然也可以用ejs或jade的引擎。但我个人比较习惯用swig，因为它更灵活，支持各种文件格式，可以直接使用html文件，也支持ejs不支持的layout等。gulp-swig插件的使用也非常简单。 //swig编译输出htmlgulp.task('html', function() &#123; return gulp.src('./template/*.html') .pipe(swig(&#123; defaults: &#123;cache: false &#125; &#125;)) .pipe(gulp.dest('./'))&#125;); 文件版本控制之前编译css和js的时候已经调用rev生成了记录了版本信息的json文件，如果内容有变化它会生成新的md5文件名。这里就是用rev-collector替换html文件中除md5部分外相同文件名的链接，这样就就实现了版本更新功能，用这个插件可以更新css，js，图片等的版本。 //更新css和js版本，同时替换html中的链接标签gulp.task('rev', scripts.concat([\"css\",\"html\"]),function () &#123; return gulp.src(['./rev/**/*.json', './*.html'])//add md5 suffix to js and css file, replace the link of html as well .pipe( revCollector(&#123; replaceReved: true, dirReplacements: &#123; '/css': '/css', '/js': '/js' &#125; &#125;)) .pipe( gulp.dest('./dist') );&#125;); html里面替换后的链接格式如下 &lt;link rel=\"stylesheet\" href=\"./css/app-d333f590b0.css\"&gt;&lt;script src=\"./js/app-62bad8e549.js\"&gt;&lt;/script&gt; 项目模版项目自动化配置完后，接着就是配置项目模版了，这里分两种类型的模版：1.移动端优先的单页面；2.pc端优先的普通页面。swig标签语法 extends 继承父模板，必须在文件最前 block 定义一个块，使之可以被继承的模板重写，或者重写父模板的同名块 parent 将父模板中同名块注入当前块中 include 包含一个模板到当前位置 移动端单页面模版在layout文件夹新建移动端的单页面模版app-layout.html，然后再建立子目录partial，用于存放公共代码块。 我们知道加载页面时再去加载外部文件是需要耗费加载时间，而页面直出可以大大提高加载速度，同时预先加载部分样式也可以避免加载时的白屏问题。这也是我们这里将公共部分的js和css以代码块的形式嵌入到html文件中，达到页面直出的效果。 swig支持将html文件嵌入，同时也可以将css文件嵌入，我这里就是把单页面样式文件app.css和基础样式文件app-base.css的内容直接输出到style标签中。主要的代码块有： meta.html: 头部meta标签 header-script.html: 主要是动态设置fontsize大小的脚本 footer-script.html: 主要是页面加载过程的动画脚本 当然了图标样式，好看的字体文件，单页面的css，基础的样式css都有， 同时母版还挖出了几个block给继承的页面进行重写，比如block title，block css，block js，内容block content。css块和js块既可以写外部链接也可以直接写代码。 我们可以根据自己的需求进行修改和配置文件，具体内容看如下代码。 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include './partial/meta.html' %&#125; &lt;!-- 页面内加载的头部js --&gt; &#123;% include './partial/header-script.html' %&#125; &lt;!-- 页面内加载的css --&gt; &lt;style&gt;&#123;% include '../lib/app/app.css' %&#125;&#123;% include '../lib/app-base.css' %&#125;&lt;/style&gt; &lt;!-- 图标 --&gt; &lt;link rel=\"stylesheet\" href=\"./lib/fontello/fontello.css\"&gt; &lt;!-- 字体 --&gt; &lt;link rel=\"stylesheet\" href=\"./lib/reboto/roboto.css\"&gt; &lt;!-- 项目css --&gt; &lt;link rel=\"stylesheet\" href=\"./css/app.css\"&gt; &lt;!-- 外部css块 --&gt; &#123;% block css %&#125;&#123;% endblock %&#125; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\" class=\"view-wrap\"&gt;&lt;/div&gt; &lt;div id=\"loading\" class=\"loading-wrap\"&gt; &lt;div class=\"loading\"&gt; &lt;div class=\"round\"&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt;0%&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=\"freshing\" class=\"fresh-wrap\"&gt; &lt;div class=\"loading\"&gt; &lt;div class=\"round\"&gt;&lt;/div&gt; &lt;p class=\"txt\"&gt;loading...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 内容填充块 --&gt; &#123;% autoescape false %&#125; &#123;% block content %&#125;&#123;% endblock %&#125; &#123;% endautoescape %&#125; &lt;!-- 页面内加载的尾部js --&gt; &#123;% include './partial/footer-script.html' %&#125; &lt;!-- 外部js块 --&gt; &#123;% block js %&#125;&#123;% endblock %&#125; &lt;/body&gt;&lt;/html&gt; PC端优先模版接着就是建立PC端优先的模版layout.html，这个和单页面模版相似，主要区别就是基础样式，同时不用嵌入移动端的代码，页面模版请看如下代码： &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include './partial/meta.html' %&#125; &lt;link rel=\"stylesheet\" href=\"./lib/fontello/fontello.css\"&gt; &lt;link rel=\"stylesheet\" href=\"./lib/reboto/roboto.css\"&gt; &lt;style&gt;&#123;% include '../lib/base.css' %&#125;&lt;/style&gt; &lt;link rel=\"stylesheet\" href=\"./css/index.css\"&gt; &#123;% block css %&#125;&#123;% endblock %&#125; &lt;/head&gt; &lt;body&gt; &#123;% autoescape false %&#125; &#123;% block content %&#125;&#123;% endblock %&#125; &#123;% endautoescape %&#125; &#123;% include './partial/copyright.html' %&#125; &#123;% block js %&#125;&#123;% endblock %&#125; &lt;/body&gt;&lt;/html&gt; 使用方式项目模板完成了，我以建立单页面项目为例演示使用的步骤 首先从github clone模版到文件夹webapp-project,安装相关npm包。 git clone https://github.com/edwardzhong/project-template.git webapp-projectnpm install 在less文件夹内建立app.less,并编写代码 @lightBlue:hsl(198, 73%, 53%);// basehtml,body&#123; font-family: \"Roboto\", \"Helvetica Neue\", Helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei\", Arial, sans-serif; font-size: 0.25rem; color: #555; width: 100%; height: 100%;&#125;body,p,h1,h2,h3,h4,h5,h6&#123;margin:0;&#125;ul,ol&#123;list-type:none; margin:0; padding:0;&#125;// todo more ... 在js文件夹建立app.js并编写代码, 使用es6写代码就是舒服😊 require('../lib/zepto.js');// zepto没有使用CommonJs规范，修改后使用require引入 import &#123; webApp &#125; from '../lib/app/app.js'var App=webApp(&#123; container:'app', animate:&#123; effects:['slideInRight', 'slideOutLeft'],delay:600&#125;, preLoad:function()&#123; &#125;, aftLoad:function()&#123; loadPercent(100); &#125;&#125;).other('/index',&#123;temId:'tempIndex',create:createIndex&#125;).when('/button',&#123;temId:'tempButton'&#125;).when('/form',&#123;temId:'tempForm'&#125;).when('/dialog',&#123;temId:'tempDialog',create:createDialog&#125;).init();// todo: more ... 在template文件夹建立app.html,引用单页面模板app-layout.html,并编写内容,我这里把单页面的各个视图代码也以代码块的方式引入。 &#123;% extends '../layout/app-layout.html' %&#125;&#123;% block title %&#125;Web App&#123;% endblock %&#125;&#123;% block js %&#125;&lt;script src=\"./js/app.js\"&gt;&lt;/script&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&#123;% include './partial/index.html' %&#125;&#123;% include './partial/button.html' %&#125;&#123;% include './partial/dialog.html' %&#125;&#123;% include './partial/form.html' %&#125;&#123;% endblock %&#125; 运行自动化命令，进行编译，合并，压缩，打包 npm run build 最后项目文件都输出到dist文件夹，找到app.html运行即可。 最后代码请看https://github.com/edwardzhong/project-template.git","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"gulp","slug":"gulp","permalink":"https://edwardzhong.github.io/tags/gulp/"},{"name":"browserify","slug":"browserify","permalink":"https://edwardzhong.github.io/tags/browserify/"}]},{"title":"canvas图表(4) - 散点图","date":"2017-11-23T19:53:56.000Z","path":"2017/11/24/chartpoint/","text":"今天开始完成散点图，做完这一节，我的canvas图表系列就算是完成了，毕竟平时最频繁用到的就是这几类图表了：柱状，折线，饼图，散点。经过编写canvas图表项目的实践，我对canvas也做到了比较深入的理解，也是越来越喜欢计算机图形相关的知识了。接下来canvas的学习会告一段落，我会继续接着学习webGL，同时学习使用blender建立简单的3D模型。 本节效果请看：散点气泡图https://edwardzhong.github.io/sites/demo/dist/chartpoint.html 经过学习之前的*其他图表*后，就会发现很多地方都是相似的，只是具体的细节有些区别，所以这次主要就是讲解散点图不同的部分，功能点包括： 组织数据； 画面绘制； 数据动画的实现； 位移坐标绘制 鼠标事件的处理。 使用方式用法基本跟柱状图和折线图类似，数据使用的是Echart的样例上的，但是它的数据格式太反人道了，我重新组织了数据格式，这样更符合我们的使用习惯。 var con=document.getElementById('container');var point =new Point(con);point.init(&#123; title:'1990 与 2015 年各国家人均寿命与 GDP', xAxis:&#123; name:'GDP', data:[10000,20000,30000,40000,50000,60000,70000], formatter:'$ &#123;value&#125;' &#125;, yAxis:&#123; name:'AGE' &#125;, desc:&#123; xVal:'gdp', yVal:'age', num:'number' &#125;, series:[&#123; name:'1990', data:[ &#123;xVal:28604,yVal:77,num:17096869,name:'Australia'&#125;, &#123;xVal:31163,yVal:77.4,num:27662440,name:'Canada'&#125;, &#123;xVal:1516,yVal:68,num:1154605773,name:'China'&#125;, &#123;xVal:13670,yVal:74.7,num:10582082,name:'Cuba'&#125;, &#123;xVal:28599,yVal:75,num:4986705,name:'Finland'&#125;, &#123;xVal:29476,yVal:77.1,num:56943299,name:'France'&#125;, &#123;xVal:31476,yVal:75.4,num:78958237,name:'Germany'&#125;, &#123;xVal:28666,yVal:78.1,num:254830,name:'Iceland'&#125;, &#123;xVal:1777,yVal:57.7,num:870601776,name:'India'&#125;, &#123;xVal:29550,yVal:79.1,num:122249285,name:'Japan'&#125;, &#123;xVal:2076,yVal:67.9,num:20194354,name:'North Korea'&#125;, &#123;xVal:12087,yVal:72,num:42972254,name:'South Korea'&#125;, &#123;xVal:24021,yVal:75.4,num:3397534,name:'New Zealand'&#125;, &#123;xVal:43296,yVal:76.8,num:4240375,name:'Norway'&#125;, &#123;xVal:10088,yVal:70.8,num:38195258,name:'Poland'&#125;, &#123;xVal:19349,yVal:69.6,num:147568552,name:'Russia'&#125;, &#123;xVal:10670,yVal:67.3,num:53994605,name:'Turkey'&#125;, &#123;xVal:26424,yVal:75.7,num:57110117,name:'United Kingdom'&#125;, &#123;xVal:37062,yVal:75.4,num:252847810,name:'United States'&#125;] &#125;, &#123; name:'2015', data:[ &#123;xVal:44056,yVal:81.8,num:23968973,name:'Australia'&#125;, &#123;xVal:43294,yVal:81.7,num:35939927,name:'Canada'&#125;, &#123;xVal:13334,yVal:76.9,num:1376048943,name:'China'&#125;, &#123;xVal:21291,yVal:78.5,num:11389562,name:'Cuba'&#125;, &#123;xVal:38923,yVal:80.8,num:5503457,name:'Finland'&#125;, &#123;xVal:37599,yVal:81.9,num:64395345,name:'France'&#125;, &#123;xVal:44053,yVal:81.1,num:80688545,name:'Germany'&#125;, &#123;xVal:42182,yVal:82.8,num:329425,name:'Iceland'&#125;, &#123;xVal:5903,yVal:66.8,num:1311050527,name:'India'&#125;, &#123;xVal:36162,yVal:83.5,num:126573481,name:'Japan'&#125;, &#123;xVal:1390,yVal:71.4,num:25155317,name:'North Korea'&#125;, &#123;xVal:34644,yVal:80.7,num:50293439,name:'South Korea'&#125;, &#123;xVal:34186,yVal:80.6,num:4528526,name:'New Zealand'&#125;, &#123;xVal:64304,yVal:81.6,num:5210967,name:'Norway'&#125;, &#123;xVal:24787,yVal:77.3,num:38611794,name:'Poland'&#125;, &#123;xVal:23038,yVal:73.13,num:143456918,name:'Russia'&#125;, &#123;xVal:19360,yVal:76.5,num:78665830,name:'Turkey'&#125;, &#123;xVal:38225,yVal:81.4,num:64715810,name:'United Kingdom'&#125;, &#123;xVal:53354,yVal:79.1,num:321773631,name:'United States'&#125;] &#125;]&#125;); 数据动画清除屏幕，然后重绘，实现动画效果。实现了气泡半径的缩放和气泡的位移动画，为了更加的美观，气泡使用了径向渐变createRadialGradient和阴影shadow，之前已经介绍过，不再详述。要注意的是，要谨慎使用阴影特性，因为它挺消耗性能，数据量一大，会卡的不要不要的😅 animate()&#123; var that=this, ctx=this.ctx, item,obj,h,r,isStop=true; (function run()&#123; ctx.save(); //清屏 ctx.clearRect(0,0,that.W,that.H); // 画坐标系 that.drawAxis(); // 画标签 that.drawTag(); // 画y轴刻度 that.drawY(); ctx.translate(that.padding,that.H-that.padding); ctx.shadowBlur=1; isStop=true; for(var i=0,l=that.animateArr.length;i&lt;l;i++)&#123; item=that.animateArr[i]; if(item.hide)continue; item.isStop=true; ctx.strokeStyle=item.color; ctx.shadowColor=item.color; for(var j=0,jl=item.data.length;j&lt;jl;j++)&#123; obj=item.data[j]; var gradient=ctx.createRadialGradient(obj.x,-obj.h,0,obj.x,-obj.h,obj.radius); gradient.addColorStop(0,'hsla('+item.hsl+',70%,80%,0.7)'); gradient.addColorStop(1,'hsla('+item.hsl+',70%,60%,0.7)'); ctx.fillStyle=gradient; ctx.beginPath(); if(obj.r&gt;obj.radius)&#123; r=obj.r-obj.v; if(r&lt;obj.radius)&#123; obj.r=obj.radius; &#125; &#125; else &#123; r=obj.r+obj.v; if(r&gt;obj.radius)&#123; obj.r=obj.radius; &#125; &#125; if(obj.r!=obj.radius)&#123; obj.r=r; item.isStop=false; &#125; if(obj.p&gt;obj.h)&#123; h=obj.y-4; if(h&lt;obj.h)&#123; obj.y=obj.p=obj.h; &#125; &#125; else &#123; h=obj.y+4; if(h&gt;obj.h)&#123; obj.y=obj.p=obj.h; &#125; &#125; if(obj.y!=obj.h)&#123; obj.y=h; item.isStop=false; &#125; ctx.arc(obj.x,-obj.y,obj.r,0,Math.PI*2,false); ctx.fill(); ctx.stroke(); &#125; if(!item.isStop)&#123;isStop=false; &#125; &#125; ctx.restore(); if(isStop)&#123;return;&#125; requestAnimationFrame(run); &#125;());&#125; 位移坐标绘制比较有特色和有意思的是，根据鼠标位置在画板中实时绘制虚线十字架，同时在x轴y轴显示该点对应的数值信息。 我首先设置了8像素的间隔，然后间隔使用moveTo和lineTo绘制坐标，分别绘制了y轴和x轴的虚线，同时根据坐标点计算出该位置对应的数值，并将它们绘制到x轴和y轴上面。 drawLine(pos)&#123; var that=this, ctx=that.ctx, padding=this.padding, xmax=this.xAxis.data.slice(-1)[0], xdis=this.W-padding*2, ymin=this.info.min, ymax=this.info.max, ydis=this.H-padding*2-this.paddingTop, yNum,xNum,space=8; ctx.save(); ctx.lineWidth=0.5; ctx.strokeStyle='hsla(0,0%,30%,1)'; // 绘制虚线十字坐标 ctx.beginPath(); for(var i=0;i*space&lt;=xdis;i++)&#123; ctx[i%2?'lineTo':'moveTo'](padding+i*space,pos.y*2); &#125; for(var i=0;i*space&lt;=ydis;i++)&#123; ctx[i%2?'lineTo':'moveTo'](pos.x*2,padding+that.paddingTop+i*space); &#125; ctx.stroke(); // 绘制在xy轴对应的数值 ctx.fillStyle='hsla(0,0%,30%,1)'; ctx.fillRect(padding-75,pos.y*2-20,70,36); ctx.fillRect(pos.x*2-55,that.H-padding+10,110,40); yNum=Math.round((ymin+(that.H-padding-pos.y*2)/ydis*(ymax-ymin))*100)/100; xNum=Math.round((pos.x*2-padding)/xdis*xmax*100)/100; ctx.font='22px arial'; ctx.textAlign='center'; ctx.textBaseLine='middle'; ctx.fillStyle='hsla(0,0%,100%,1)'; ctx.fillText(yNum,padding-40,pos.y*2+5); ctx.fillText(xNum,pos.x*2,that.H-padding+40); ctx.restore();&#125; 事件处理mousemove的时候，如果位置在标签上和在图表画面上时，变为手形图标。滑过画板内容的时候，还要判断是否在某个气泡上面，如果是则用浮层显示该气泡对应的内容，同时前置该气泡并用scale放大。接着还要绘制该点的虚线十字架并在xy轴绘制对应数值。 mousedown某个击标签就会显示隐藏对应分类，每次触发就会看到气泡的半径变化和位移的动画效果。 事件相关内容具体实现可参考canvas图表(3) - 饼图 最后所有图表代码请看chart.js","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"canvas图表(3) - 饼图","date":"2017-11-23T02:23:10.000Z","path":"2017/11/23/chartpie/","text":"这几天把canvas图表都优化了下，动画效果更加出色了，可以说很逼近Echart了。刚刚写完的饼图，非常好的实现了既定的功能，交互的动画效果也是很棒的。 效果请看：饼图https://edwardzhong.github.io/sites/demo/dist/chartpie.html 功能点包括： 组织数据； 画面绘制； 数据动画的实现； 鼠标事件的处理。 使用方式饼图的数据方面要简单很多，因为不用多个分组的数据。把所有的数据相加得出总数，然后每个数据分别求出百分比，有了百分比再相乘360度的弧度得出每个数据在圆盘中对应的要显示的角度。 var con=document.getElementById('container');var pie=new Pie(con);pie.init(&#123; title:'网站用户访问来源', toolTip:'访问来源', data:[ &#123;value:435, name:'直接访问'&#125;, &#123;value:310, name:'邮件营销'&#125;, &#123;value:234, name:'联盟广告'&#125;, &#123;value:135, name:'视频广告'&#125;, &#123;value:1548, name:'搜索引擎'&#125; ]&#125;); 代码结构因为为了同时实现新增动画和更新动画，这次的代码结构经过了重构和优化，跟之前的有比较大的区别。 class Line extends Chart&#123; constructor(container)&#123; super(container); &#125; // 初始化 init(opt)&#123; &#125; // 绑定事件 bindEvent()&#123; &#125; // 显示信息 showInfo(pos,arr)&#123; &#125; // 清除内容再绘制 clearGrid(index)&#123; &#125; // 执行数据动画 animate()&#123; &#125; // 执行 create()&#123; &#125; // 组织数据 initData()&#123; &#125; // 绘制 draw()&#123; &#125;&#125; 组织数据这次把组织数据的功能单独拎了出来，这样方便重用和修改。然后还要给动画对象增加是否创建的属性create和上次最后更新的度数last，为什么呢？因为我们要同时实现创建和更新图形的动画效果。 initData()&#123; var that=this, item, total=0; if(!this.data||!this.data.length)&#123;return;&#125; this.legend.length=0; for(var i=0;i&lt;this.data.length;i++)&#123; item=this.data[i]; // 赋予没有颜色的项 if(!item.color)&#123; var hsl=i%2?180+20*i/2:20*(i-1); item.color='hsla('+hsl+',70%,60%,1)'; &#125; item.name=item.name||'unnamed'; this.legend.push(&#123; hide:!!item.hide, name:item.name, color:item.color, x:50, y:that.paddingTop+40+i*50, w:80, h:30, r:5 &#125;); if(item.hide)continue; total+=item.value; &#125; for(var i=0;i&lt;this.data.length;i++)&#123; item=this.data[i]; if(!this.animateArr[i])&#123;//创建 this.animateArr.push(&#123; i:i, create:true, hide:!!item.hide, name:item.name, color:item.color, num:item.value, percent:Math.round(item.value/total*10000)/100, ang:Math.round(item.value/total*Math.PI*2*100)/100, last:0, cur:0 &#125;); &#125; else &#123;//更新 if(that.animateArr[i].hide&amp;&amp;!item.hide)&#123; that.animateArr[i].create=true; that.animateArr[i].cur=0; &#125; else &#123; that.animateArr[i].create=false; &#125; that.animateArr[i].hide=item.hide; that.animateArr[i].percent=Math.round(item.value/total*10000)/100; that.animateArr[i].ang=Math.round(item.value/total*Math.PI*2*100)/100; &#125; &#125;&#125; 绘制饼图的绘制功能很简单，因为不用坐标系，只需要绘制标题和标签列表。 draw()&#123; var item,ctx=this.ctx; ctx.fillStyle='hsla(0,0%,30%,1)'; ctx.strokeStyle='hsla(0,0%,20%,1)'; ctx.textBaseLine='middle'; ctx.font='24px arial'; ctx.clearRect(0,0,this.W,this.H); if(this.title)&#123; ctx.save(); ctx.textAlign='center'; ctx.font='bold 40px arial'; ctx.fillText(this.title,this.W/2,70); ctx.restore(); &#125; ctx.save(); for(var i=0;i&lt;this.legend.length;i++)&#123; item=this.legend[i]; // 画分类标签 ctx.textAlign='left'; ctx.fillStyle=item.color; ctx.strokeStyle=item.color; roundRect(ctx,item.x,item.y,item.w,item.h,item.r); ctx.globalAlpha=item.hide?0.3:1; ctx.fill(); ctx.fillText(item.name,item.x+item.w+20,item.y+item.h-5); &#125; ctx.restore();&#125; 执行绘制饼图动画动画区分了创建和更新，这样用户很容易就能看出数据的比例关系变化，也就更加的直观。创建就是从0弧度到指定的弧度，只有数值的增加；而更新动画就要区分增加和减少的情况，因为当用户点击某个标签的时候，会隐藏显示某个分类的数据，于是需要重新计算每个分类的比例，那么相应的分类百分比就会增加或减少。我们根据当前最新要达到的比例ang和已经执行完的当前比例last的进行对比，相应执行增加和减少比例，动画原理就是这样。 canvas绘制圆形context.arc(x,y,r,sAngle,eAngle,counterclockwise);只要我们指定开始角度和结束角度就会画出披萨饼一样的效果，所有的披萨饼加起来就是一个圆。 animate()&#123; var that=this, ctx=that.ctx, canvas=that.canvas, item,startAng,ang, isStop=true; (function run()&#123; isStop=true; ctx.save(); ctx.translate(that.W/2,that.H/2); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,that.H/3+30,0,Math.PI*2,false); ctx.fill(); for(var i=0,l=that.animateArr.length;i&lt;l;i++)&#123; item=that.animateArr[i]; if(item.hide)continue; startAng=-Math.PI/2; that.animateArr.forEach((obj,j)=&gt;&#123; if(j&lt;i&amp;&amp;!obj.hide)&#123;startAng+=obj.cur;&#125; &#125;); ctx.fillStyle=item.color; if(item.create)&#123;//创建动画 if(item.cur&gt;=item.ang)&#123; item.cur=item.last=item.ang; &#125; else &#123; item.cur+=0.05; isStop=false; &#125; &#125; else &#123;//更新动画 if(item.last&gt;item.ang)&#123; ang=item.cur-0.05; if(ang&lt;item.ang)&#123; item.cur=item.last=item.ang; &#125; &#125; else &#123; ang=item.cur+0.05; if(ang&gt;item.ang)&#123; item.cur=item.last=item.ang; &#125; &#125; if(item.cur!=item.ang)&#123; item.cur=ang; isStop=false; &#125; &#125; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,that.H/3,startAng,startAng+item.cur,false); ctx.closePath(); ctx.fill(); &#125; ctx.restore(); if(isStop) &#123; that.clearGrid(); return; &#125; requestAnimationFrame(run); &#125;());&#125; 交互处理执行完动画后，我这里再执行了一遍清除绘制，这个也是鼠标触摸标签和饼图时的对应动画方法，会绘制每个分类的名称描述，更方便用户查看。 clearGrid(index)&#123; var that=this, ctx=that.ctx, canvas=that.canvas, item,startAng=-Math.PI/2, len=that.animateArr.filter(item=&gt;!item.hide).length, j=0,angle=0, r=that.H/3; ctx.clearRect(0,0,that.W,that.H); that.draw(); ctx.save(); ctx.translate(that.W/2,that.H/2); for(var i=0,l=that.animateArr.length;i&lt;l;i++)&#123; item=that.animateArr[i]; if(item.hide)continue; ctx.strokeStyle=item.color; ctx.fillStyle=item.color; angle=j&gt;=len-1?Math.PI*2-Math.PI/2:startAng+item.ang; ctx.beginPath(); ctx.moveTo(0,0); if(index===i)&#123; ctx.save(); // ctx.shadowColor='hsla(0,0%,50%,1)'; ctx.shadowColor=item.color; ctx.shadowBlur=5; ctx.arc(0,0,r+20,startAng,angle,false); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); &#125; else &#123; ctx.arc(0,0,r,startAng,angle,false); ctx.closePath(); ctx.fill(); &#125; //画分类描述 var tr=r+40,tw=0, tAng=startAng+item.ang/2, x=tr*Math.cos(tAng), y=tr*Math.sin(tAng); ctx.lineWidth=2; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(x,y); if(tAng&gt;=-Math.PI/2&amp;&amp;tAng&lt;=Math.PI/2)&#123; ctx.lineTo(x+30,y); ctx.fillText(item.name,x+40,y+10); &#125; else &#123; tw=ctx.measureText(item.name).width;//计算字符长度 ctx.lineTo(x-30,y); ctx.fillText(item.name,x-40-tw,y+10); &#125; ctx.stroke(); startAng+=item.ang; j++; &#125; ctx.restore();&#125; 事件处理mousemove的时候，触摸标签和触摸饼图都是基本相同的效果，选中的分类扩大半径，同时增加阴影，以达到凸出来的动画效果，具体实现请看上面的clearGrid方法。判断是否点中都是使用isPointInPath这个api，之前已经介绍过，不再细讲。 mousedown某个击标签就会显示隐藏对应分类，每次触发就会看到饼图的比例变化的动画效果，这个和之前的柱状图和折线图的功能一致。 bindEvent()&#123; var that=this, canvas=that.canvas, ctx=that.ctx; if(!this.data.length) return; this.canvas.addEventListener('mousemove',function(e)&#123; var isLegend=false; var box=canvas.getBoundingClientRect(), pos = &#123; x:e.clientX-box.left, y:e.clientY-box.top &#125;; // 标签 for(var i=0,item,len=that.legend.length;i&lt;len;i++)&#123; item=that.legend[i]; roundRect(ctx,item.x,item.y,item.w,item.h,item.r); if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; canvas.style.cursor='pointer'; if(!item.hide)&#123; that.clearGrid(i); &#125; isLegend=true; break; &#125; canvas.style.cursor='default'; that.tip.style.display='none'; &#125; if(isLegend) return; // 图表 var startAng=-Math.PI/2; for(var i=0,l=that.animateArr.length;i&lt;l;i++)&#123; item=that.animateArr[i]; if(item.hide)continue; ctx.beginPath(); ctx.moveTo(that.W/2,that.H/2); ctx.arc(that.W/2,that.H/2,that.H/3,startAng,startAng+item.ang,false); ctx.closePath(); startAng+=item.ang; if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; canvas.style.cursor='pointer'; that.clearGrid(i); that.showInfo(pos,that.toolTip,[&#123;name:item.name,num:item.num+' ('+item.percent+'%)'&#125;]); break; &#125; canvas.style.cursor='default'; that.clearGrid(); &#125; &#125;,false); this.canvas.addEventListener('mousedown',function(e)&#123; e.preventDefault(); var box=that.canvas.getBoundingClientRect(); var pos = &#123; x:e.clientX-box.left, y:e.clientY-box.top &#125;; for(var i=0,item,len=that.legend.length;i&lt;len;i++)&#123; item=that.legend[i]; roundRect(ctx,item.x,item.y,item.w,item.h,item.r); if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; that.data[i].hide=!that.data[i].hide; that.create(); break; &#125; &#125; &#125;,false);&#125; 最后所有图表代码请看chart.js","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"canvas图表(2) - 折线图","date":"2017-11-21T04:42:34.000Z","path":"2017/11/21/chartline/","text":"话说这天气一冷啊, 就患懒癌, 就不想码代码, 就想着在床上舒舒服服看视频. 那顺便就看blender视频, 学习下3D建模, 如果学会了建3D模型, 那我的webGL技术就大有用处啊,可以独立开发小游戏了😂, 当然是玩笑了。但首先还是把canvas图表系列先弄完吧, 今天就弄折线图。 效果请看：折线图https://edwardzhong.github.io/sites/demo/dist/chartline.html 主要功能点包括： 组织数据； 绘制； 数据动画的实现； 清屏并重绘画面； 鼠标事件的处理。 大部分的技术在上一节的*canvas图表(1) - 柱状图*实现了, 所以这节内容其实是比较简单的。比较麻烦一点的就是折线图的动画了，所以重点就看一下这部分的代码。 使用方式使用方式，和柱状图基本是一样的，我们这里表示的是气温变化图。 var con=document.getElementById('container');var line = new Line(con);line.init(&#123; title:'未来一周气温变化', xAxis:&#123; data:['周一','周二','周三','周四','周五','周六','周日'] &#125;, yAxis:&#123; name:'温度', formatter:'&#123;value&#125; °C' &#125;, series:[ &#123; name:'最高气温', data:[11, 11, 15, 13, 12, 13, 10] &#125;, &#123; name:'最低气温', data:[1, -2, 2, 5, 3, 2, 0] &#125; ]&#125;) 代码结构折线图对象大体和柱状图一致，只是部分方法经过重构。 class Line extends Chart&#123; constructor(container)&#123; super(container); &#125; // 初始化 init(opt)&#123; &#125; // 绑定事件 bindEvent()&#123; &#125; // 显示信息 showInfo(pos,arr)&#123; &#125; // 清除内容再绘制 clearGrid(index)&#123; &#125; // 执行数据动画 animate()&#123; &#125; // 执行 create()&#123; &#125; // 组织数据 initData()&#123; &#125; // 绘制 draw()&#123; &#125;&#125; 数据动画折线图动画实现的是路径绘制特效，懂canvas的基本都知道原理，就是用lineTo绘制路径，最后stroke出来。但这个折线图是分段的，所以要分情况处理，主要难点就是获取两个点之间的坐标。 仔细思考下如何实现绘制路径动画，因为我们知道x轴总长度，所以可以让x依次递增，再求出x对应的y坐标即可。既然知道了两个点的坐标，还知道了x坐标，根据同角度等比例三角形原理，很容易求出y坐标。 还有就是更新状态的位移动画了，这个就更加简单了，根据当前位置和要将要移动到的位置对比，进行对应的增减即可。 animate()&#123; var that=this, ctx=this.ctx, obj,h=0, isStop=true; (function run()&#123; ctx.clearRect(0,that.padding+that.paddingTop-5,that.W,that.H-2*that.padding-that.paddingTop+4); that.drawY(); ctx.save(); ctx.translate(that.padding,that.H-that.padding); isStop=true; for(var i=0,item;i&lt;that.animateArr.length;i++)&#123; item=that.animateArr[i]; if(item.hide) continue; ctx.strokeStyle=item.color; ctx.lineWidth=item.data[0].w; item.isStop=true; if(item.create)&#123;//新增绘制路径动画 for(var j=0,jl=item.data.length;j&lt;jl;j++)&#123; obj=item.data[j]; if(obj.y&gt;=obj.h)&#123; obj.y=obj.p=obj.h; &#125; else &#123; obj.y+=obj.vy; item.isStop=false; &#125; ctx.beginPath(); ctx.moveTo(obj.x+obj.w/2,-obj.y); ctx.lineTo(obj.x+obj.w/2,-1); ctx.stroke(); &#125; &#125; else &#123; //更新位移动画 for(var j=0,jl=item.data.length;j&lt;jl;j++)&#123; obj=item.data[j]; if(obj.p&gt;obj.h)&#123; h=obj.y-4; if(h&lt;obj.h)&#123; obj.y=obj.p=obj.h; &#125; &#125; else &#123; h=obj.y+4; if(h&gt;obj.h)&#123; obj.y=obj.p=obj.h; &#125; &#125; if(obj.p!=obj.h)&#123; obj.y=h; item.isStop=false; &#125; ctx.beginPath(); ctx.moveTo(obj.x+obj.w/2,-obj.y); ctx.lineTo(obj.x+obj.w/2,-1); ctx.stroke(); &#125; &#125; if(!item.isStop)&#123;isStop=false; &#125; &#125; ctx.restore(); if(isStop)return; requestAnimationFrame(run); &#125;())&#125; 清屏并重绘画面在画面上要实现动态效果的时候，需要清屏，重新绘制画面，如果指定了某个区间，就在该区间上画标志线，同时该区间的圆心放大。 clearGrid(index)&#123; var that=this, obj, r=5, ctx=this.ctx; ctx.clearRect(0,0,that.W,that.H); // 画坐标系 this.drawAxis(); // 画标签 this.drawTag(); // 画y轴刻度 this.drawY(); ctx.save(); ctx.translate(that.padding,that.H-that.padding); // 画标志线 if(typeof index== 'number')&#123; obj=that.animateArr[0].data[index]; ctx.lineWidth=1; ctx.strokeStyle='hsla(0,0%,70%,1)'; ctx.moveTo(obj.x,-that.H+that.paddingTop+2*that.padding); ctx.lineTo(obj.x,0); ctx.stroke(); &#125; for(var i=0,item,il=that.animateArr.length;i&lt;il;i++)&#123; item=that.animateArr[i]; if(item.hide)continue; ctx.lineWidth=4; ctx.strokeStyle=item.color; ctx.fillStyle='#fff'; ctx.beginPath(); for(var j=0,obj,jl=item.data.length;j&lt;jl;j++)&#123; obj=item.data[j]; if(j==0)&#123; ctx.moveTo(obj.x,-obj.h); &#125; else &#123; ctx.lineTo(obj.x,-obj.h); &#125; &#125; ctx.stroke(); //画完曲线后再画圆球 for(var j=0,jl=item.data.length;j&lt;jl;j++)&#123; obj=item.data[j]; ctx.strokeStyle=item.color; ctx.lineWidth=index===j?6:4; r=index===j?10:5; ctx.beginPath(); ctx.arc(obj.x,-obj.h,r,0,Math.PI*2,false); ctx.stroke(); ctx.fill(); &#125; &#125; ctx.restore();&#125; 事件处理mousemove 一是触摸标签显示手形，二是滑过画面区域的时候擦除并重绘画面，选中的折线的圆形扩大，同时绘制指示线，具体看clearGrid方法。 mousedown某个击标签就会显示隐藏对应分组，创建状态执行路径绘制动画，而更新状态这是执行位移动画。 bindEvent()&#123; var that=this, ctx=that.ctx, canvas=that.canvas, xl=this.xAxis.data.length, xs=(that.W-2*that.padding)/(xl-1), index=0; this.canvas.addEventListener('mousemove',function(e)&#123; var isLegend=false; // todo ... if(isLegend) return; // 鼠标位置在图表中时 if(pos.y*2&gt;that.padding+that.paddingTop &amp;&amp; pos.y*2&lt;that.H-that.padding &amp;&amp; pos.x*2&gt;that.padding &amp;&amp; pos.x*2&lt;that.W-that.padding)&#123; canvas.style.cursor='pointer'; for(var i=0;i&lt;xl;i++)&#123; if(pos.x*2&gt;i*xs)&#123; index=i; &#125; &#125; // 重绘并标志选中信息 that.clearGrid(index); // 获取处于当前位置的信息 var arr=[]; for(var j=0,item,l=that.animateArr.length;j&lt;l;j++)&#123; item=that.animateArr[j]; if(item.hide)continue; arr.push(&#123;name:item.name, num:item.data[index].num&#125;) &#125; that.showInfo(pos,arr); ctx.restore(); &#125; else &#123; that.tip.style.display='none'; that.clearGrid(); &#125; &#125;,false); this.canvas.addEventListener('mousedown',function(e)&#123; e.preventDefault(); var box=that.canvas.getBoundingClientRect(); var pos = &#123; x:e.clientX-box.left, y:e.clientY-box.top &#125;; for(var i=0,item,len=that.legend.length;i&lt;len;i++)&#123; item=that.legend[i]; roundRect(ctx,item.x,item.y,item.w,item.h,item.r); if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; that.series[i].hide=!that.series[i].hide; that.create(); break; &#125; &#125; &#125;,false);&#125; 最后所有图表代码请看chart.js","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"WebGL学习(2) - 3D场景","date":"2017-11-14T06:30:21.000Z","path":"2017/11/14/webgl3d/","text":"经过前面WebGL学习(1) - 三角形*的学习，我们已经掌握了webGL的基础知识，也已经能够画出最基本的图形，比如点，线，三角形，矩形等。有了2D绘图的基础，现在终于可以进入精彩的3D世界了，来看一下这一节要实现的3D的效果吧。实际效果：webGL3D场景* webGL渲染流程重温一下webGL的渲染流程，这一节在第3、4、5、6步骤需要学习新的内容。其中写入数据交叉存放缓冲区，设置隐藏面消除，清空深度缓冲都是比较简单的部分。重点和难点是在3D变换的环节，在理解了矩阵的原理基础上，这次使用了《WebGL编程指南》提供的矩阵操作库。 获取webGL绘图上下文 初始化着色器 创建、绑定缓冲区对象 3D变换 向顶点着色器和片元着色器写入数据(数据交叉存放缓冲区) 设置canvas背景色，设置隐藏面消除 清空canvas|清空深度缓冲 绘制 着色器着色器代码修改为下面，我们现在需要为每个顶点都使用不同的颜色，所以使用到了varying限定符的变量，这个变量目的就是连接顶点和片元着色器，把顶点信息和颜色信息结合起来。看到顶点着色器和片元着色器都有的v_color变量了吗？其实就是通过全局变量传递。顶点着色器 &lt;script type=\"x-shader/x-vertex\" id=\"vs\"&gt;attribute vec4 a_Position; //顶点uniform mat4 u_MvpMatrix;//模型视点投影矩阵attribute vec4 a_Color;varying vec4 v_color;// 连接片元着色器void main() &#123; gl_Position = u_MvpMatrix * a_Position; v_color=a_Color;//传递给片元着色器变量&#125; &lt;/script&gt; 片元着色器 &lt;script type=\"x-shader/x-fragment\" id=\"fs\"&gt;precision mediump float; // 精度限定varying vec4 v_color; //从顶点着色器接收void main() &#123; gl_FragColor = v_color;&#125;&lt;/script&gt; 3D坐标系第1、2、3步骤前面文章已经介绍，现在我们直接进入3D的环节。3D比2D主要就是多了深度信息，用坐标系来描述就是，除xy轴外，还多了z轴。webGL的坐标系跟我们web的坐标系是不一样的，首先它原点不是在左上角而是位于中间，xyz方向也不同。 视点和视线接着引入一个概念，视点，也就是定义观察者的位置，观察者能看多远，观察者的方向，直接看图吧 上方向就是观测者从哪个方向看，(0,1,0)是正常的Y轴正方向，(1,0,0)就相当于物体向左旋90度，等于我们把头打横看物体。通过定义视点矩阵，我们看到的图形的形状会产生变化的，就和我们实际环境不同的角度位置观察同一物体是一样一样的。我们调用矩阵库中的方法，会产生出一个4X4的矩阵，具体中间的产生过程，可以看源代码。 // (视点，观察目标点，上方向)setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) 投影可视空间只有指定了可视空间，webGL才会去绘制图形，有两种类型：一是盒状可视空间，由正射投影产生，它产生的图形，前后物体没有大小区别，都是一样高宽。 调用矩阵库的setOrtho方法，产生矩阵 // 正视投影 (left,right,bottom,top,near,far), 组成一个正方体的可视空间 setOrtho(left, right, bottom, top, near, far); 二是四棱锥可视空间，由透视投影产生，透视投影产生的3D场景更加真实自然，它产生的图形具有近大远小的透视效果，当然性能消耗相对正射投影高一些。 调用setPerspective方法，同理生成矩阵 // 投影矩阵(fov可视空间底面和顶面夹角&lt;大于0&gt;,近裁截面宽高比,近裁截面位置&lt;大于0&gt;,远裁截面位置&lt;大于0&gt; )setPerspective(fovy, aspect, near, far) 数据交叉存放缓冲区我们既可以给不同的信息分别创建单独缓冲区，也可以给不同的信息创建同一块合用的缓冲区，前者适合数据量小的情况，我们现在实现第二种情况：给不同的信息创建一块缓冲区，并交叉存放。首先用一个数组同时存放顶点信息和顶点对应的颜色信息，接着创建缓冲区后调用gl.vertexAttribPointer()，该方法有定义每个分量的个数，每一行的个数以及偏移数，当然相邻顶点数和偏移量要乘以单位字节，具体看代码的注释。 /** * 混合缓冲区(包括顶点，颜色)，每一行前3个是顶点信息，后3个是颜色信息 */var verticeColors=new Float32Array([ 0.0, 1.0, -2.0, 0.3, 1.0, 0.4, -0.5, -1.0, -2.0, 0.3, 1.0, 0.4, 0.5, -1.0, -2.0, 1.0, 0.4, 0.4, 0.0, 1.0, -1.0, 1.0, 1.0, 0.4, -0.5, -1.0, -1.0, 1.0, 1.0, 0.4, 0.5, -1.0, -1.0, 1.0, 0.4, 0.4, 0.0, 1.0, 0.0, 0.4, 0.4, 1.0, -0.5, -1.0, 0.0, 0.4, 0.4, 1.0, 0.5, -1.0, 0.0, 1.0, 0.4, 0.4, ]);// 创建缓冲区if(!createBuffer(verticeColors))&#123; console.log('Failed to create the buffer object'); return;&#125;// 每个元素的字节var FSIZE = verticeColors.BYTES_PER_ELEMENT;// 获取顶点位置var a_Position = gl.getAttribLocation(gl.program, 'a_Position');// (地址,每个顶点分量的个数&lt;1-4&gt;,数据类型&lt;整形，符点等&gt;,是否归一化,指定相邻两个顶点间字节数&lt;默认0&gt;,指定缓冲区对象偏移字节数量&lt;默认0&gt;)gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6*FSIZE, 0);// Enable the assignment to a_Position variablegl.enableVertexAttribArray(a_Position);// 获取a_Color变量的存储地址并赋值var a_Color = gl.getAttribLocation(gl.program, 'a_Color');gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6*FSIZE, 2*FSIZE);gl.enableVertexAttribArray(a_Color); 3D相关的其他设置开启隐藏面消除可以减少渲染量，提高性能，同时还可以避免顺序不一致时，后面的图形盖住前面的图形。而多边形偏移，可以避免深度很接近的两个图形产生冲突。当然每次重新渲染的时候，在清屏的同时清除深度缓冲，具体实现请看代码。 // 开启隐藏面消除gl.enable(gl.DEPTH_TEST);//清屏|清深度缓冲gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);// 启用多边形偏移，避免深度冲突gl.enable(gl.POLYGON_OFFSET_FILL);//设置偏移量gl.polygonOffset(1.0, 1.0); 执行动画来看一下我们执行动画的部分，首先设置好用于位移旋转的模型矩阵，然后依次产生视点矩阵，投影矩阵，接着把它们相乘产生出mvp矩阵，然后传入变量，最后绘图。在绘制完第一组图形的时候，将前面的mvp矩阵再左移2个单位，再绘制一遍，于是就产生出了第二组图形。具体的逻辑情况代码注释。 var angle=0;// 执行动画(function animate()&#123; // 旋转位移 等于绕原点Y旋转 modelMatrix.setRotate((angle++)%360,0,1,0); modelMatrix.translate(1, 0, 1); // (视点，观察目标点，上方向) viewMatrix.setLookAt(-0.25, -0.25, 5, 0, 0, -100, 0, 1, 0); // 投影矩阵(fov可视空间底面和顶面夹角&lt;大于0&gt;,近裁截面宽高比,近裁截面位置&lt;大于0&gt;,远裁截面位置&lt;大于0&gt; ) projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100); // 矩阵相乘 mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix); // 赋值 gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); //清屏|清深度缓冲 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 启用多边形偏移，避免深度冲突 gl.enable(gl.POLYGON_OFFSET_FILL); // (基本图形，第几个顶点，执行几次)，修改基本图形项可以生成点，线，三角形，矩形，扇形等 gl.drawArrays(gl.TRIANGLES, 0, 9); //位移后，再将前面3个三角形重新绘制 modelMatrix.translate(-2, 0, 0); mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); //设置偏移量 gl.polygonOffset(1.0, 1.0); gl.drawArrays(gl.TRIANGLES, 0, 9); requestAnimationFrame(animate);&#125;()); 总结学习完3D场景后，我们又再一次领略到了线性代数中矩阵在图形学中的重要作用。3D的矩阵转换才是需要空间思维和深入理解的部分，其他地方说实话就是学习如何调用api。最后，献上主体的全部代码 var canvas=document.getElementById('canvas'), gl=get3DContext(canvas,true);function main() &#123; if (!gl) &#123; console.log('Failed to get the rendering context for WebGL'); return; &#125; if (!createShaders(gl, 'fs', 'vs')) &#123; console.log('Failed to intialize shaders.'); return; &#125; /** * 混合缓冲区(包括顶点，颜色) */ var verticeColors=new Float32Array([ 0.0, 1.0, -2.0, 0.3, 1.0, 0.4, -0.5, -1.0, -2.0, 0.3, 1.0, 0.4, 0.5, -1.0, -2.0, 1.0, 0.4, 0.4, 0.0, 1.0, -1.0, 1.0, 1.0, 0.4, -0.5, -1.0, -1.0, 1.0, 1.0, 0.4, 0.5, -1.0, -1.0, 1.0, 0.4, 0.4, 0.0, 1.0, 0.0, 0.4, 0.4, 1.0, -0.5, -1.0, 0.0, 0.4, 0.4, 1.0, 0.5, -1.0, 0.0, 1.0, 0.4, 0.4, ]); // 创建缓冲区 if(!createBuffer(verticeColors))&#123; console.log('Failed to create the buffer object'); return; &#125; // 每个元素的字节 var FSIZE = verticeColors.BYTES_PER_ELEMENT; // 获取顶点位置 var a_Position = gl.getAttribLocation(gl.program, 'a_Position'); // (地址,每个顶点分量的个数&lt;1-4&gt;,数据类型&lt;整形，符点等&gt;,是否归一化,指定相邻两个顶点间字节数&lt;默认0&gt;,指定缓冲区对象偏移字节数量&lt;默认0&gt;) gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, 6*FSIZE, 0); // Enable the assignment to a_Position variable gl.enableVertexAttribArray(a_Position); // 获取a_Color变量的存储地址并赋值 var a_Color = gl.getAttribLocation(gl.program, 'a_Color'); gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, 6*FSIZE, 2*FSIZE); gl.enableVertexAttribArray(a_Color); var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix'); if(!u_MvpMatrix) &#123; console.log('Failed to get the storage location of u_MvpMatrix'); return; &#125; // 设置背景颜色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 开启隐藏面消除 gl.enable(gl.DEPTH_TEST); var modelMatrix = new Matrix4(); // 模型矩阵 var viewMatrix = new Matrix4(); // 视点矩阵 var projMatrix = new Matrix4(); // 投影矩阵 var mvpMatrix = new Matrix4(); // 用于相乘用 var angle=0; // 执行动画 (function animate()&#123; // 旋转位移 等于绕原点Y旋转 modelMatrix.setRotate((angle++)%360,0,1,0); modelMatrix.translate(1, 0, 1); // (视点，观察目标点，上方向) viewMatrix.setLookAt(-0.25, -0.25, 5, 0, 0, -100, 0, 1, 0); // 投影矩阵(fov可视空间底面和顶面夹角&lt;大于0&gt;,近裁截面宽高比,近裁截面位置&lt;大于0&gt;,远裁截面位置&lt;大于0&gt; ) projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100); // 矩阵相乘 mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix); // 赋值 gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); //清屏|清深度缓冲 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 启用多边形偏移，避免深度冲突 gl.enable(gl.POLYGON_OFFSET_FILL); // (基本图形，第几个顶点，执行几次)，修改基本图形项可以生成点，线，三角形，矩形，扇形等 gl.drawArrays(gl.TRIANGLES, 0, 9); //位移后，再将前面3个三角形重新绘制 modelMatrix.translate(-2, 0, 0); mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix); gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements); //设置偏移量 gl.polygonOffset(1.0, 1.0); gl.drawArrays(gl.TRIANGLES, 0, 9); requestAnimationFrame(animate); &#125;());&#125;main();","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"canvas图表(1) - 柱状图","date":"2017-11-12T10:45:09.000Z","path":"2017/11/12/chartbar/","text":"前几天用到了图表库，其中百度的ECharts，感觉做得最好，看它默认用的是canvas，canvas图表在处理大数据方面比svg要好。那我也用canvas来实现一个图表库吧，感觉不会太难，先实现个简单的柱状图。 效果请看：柱状图https://edwardzhong.github.io/sites/demo/dist/bar.html 主要功能点包括： 文本的绘制 XY轴的绘制； 数据分组绘制； 数据动画的实现； 鼠标事件的处理。 使用方式首先我们看一下使用方式，参考了部分ECharts的使用方式，先传入要显示图表的html标签，接着调用init，初始化的同时传入数据。 var con=document.getElementById('container');var chart=new Bar(con);chart.init(&#123; title:'全年降雨量柱状图', xAxis:&#123;// x轴 data:['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月'] &#125;, yAxis:&#123;//y轴 name:'水量', formatter:'&#123;value&#125; ml' &#125;, series:[//分组数据 &#123; name:'东部降水量', data:[62,20,17,45,100,56,19,38,50,120,56,130] &#125;, &#123; name:'西部降水量', data:[52,10,17,25,60,39,19,48,70,30,56,8] &#125;, &#123; name:'南部降水量', data:[12,10,17,25,27,39,50,38,100,30,56,90] &#125;, &#123; color:'hsla(270,80%,60%,1)', name:'北部降水量', data:[12,30,17,25,7,39,49,38,60,30,56,10] &#125; ]&#125;); 图表基类，我们后面还要写饼图，折线图，所以把公共的部分抽出来。注意canvas.style.width与canvas.width是不一样的，前者会拉伸图形，后者才是我们正常用的，不会拉伸图形。在这里这样写先扩大再缩小是为了解决canvas绘制文字时模糊的问题。 class Chart&#123; constructor(container)&#123; this.container=container; this.canvas=document.createElement('canvas'); this.ctx=this.canvas.getContext('2d'); this.W=1000*2; this.H=600*2; this.padding=120; this.paddingTop=50; this.title=''; this.legend=[]; this.series=[]; //通过缩小一倍，解决字体模糊问题 this.canvas.width=this.W; this.canvas.height=this.H; this.canvas.style.width = this.W/2 + 'px'; this.canvas.style.height = this.H/2 + 'px'; &#125;&#125; 柱状图初始化，调用es6中的Object.assign(this,opt)，这个相当于JQ中的extend方法，把属性复制到当前实例。同时还建了个tip属性，这是个html标签，后面显示数据信息用。接着绘制图形，然后绑定鼠标事件。 class Bar extends Chart&#123; constructor(container)&#123; super(container); this.xAxis=&#123;&#125;; this.yAxis=[]; this.animateArr=[]; &#125; init(opt)&#123; Object.assign(this,opt); if(!this.container)return; this.container.style.position='relative'; this.tip=document.createElement('div'); this.tip.style.cssText='display: none; position: absolute; opacity: 0.5; background: #000; color: #fff; border-radius: 5px; padding: 5px; font-size: 8px; z-index: 99;'; this.container.appendChild(this.canvas); this.container.appendChild(this.tip); this.draw(); this.bindEvent(); &#125; draw()&#123;//绘制 &#125; showInfo()&#123;//显示信息 &#125; animate()&#123;//执行动画 &#125; showData()&#123;//显示数据 &#125;&#125; 绘制XY轴首先绘制标题，接着XY轴，然后遍历分组数据series，里面有复杂的计算，然后绘制XY轴的刻度，绘制分组标签，最后是绘制数据。数据项series中是分组数据，它跟X轴的xAxis.data一一对应。每个项可以自定义名称和颜色，没有指定的话，名称赋予nunamed和自动生成颜色。这里还用legend属性记录下了标签列表信息，因为后续鼠标点击判断是否点中用的上。canvas主要知识点： 分组标签使用了arcTo方法，这样就能绘制出圆角的效果。 绘制文本使用了measureText方法，可以用来测量文字所占宽度，这样就可以调整下一次绘制的位置，避免位置冲突。 translate位移方法，可以放在绘制上下文(save和restore的中间)中，这样可以避免复杂的位置运算。draw()&#123; var that=this, ctx=this.ctx, canvas=this.canvas, W=this.W, H=this.H, padding=this.padding, paddingTop=this.paddingTop, xl=0,xs=0,xdis=W-padding*2,//x轴单位数，每个单位长度，x轴总长度 yl=0,ys=0,ydis=H-padding*2-paddingTop;//y轴单位数，每个单位长度，y轴总长度 ctx.fillStyle='hsla(0,0%,20%,1)'; ctx.strokeStyle='hsla(0,0%,10%,1)'; ctx.lineWidth=1; ctx.textAlign='center'; ctx.textBaseLine='middle'; ctx.font='24px arial'; ctx.clearRect(0,0,W,H); if(this.title)&#123; ctx.save(); ctx.textAlign='left'; ctx.font='bold 40px arial'; ctx.fillText(this.title,padding-50,70); ctx.restore(); &#125; if(this.yAxis&amp;&amp;this.yAxis.name)&#123; ctx.fillText(this.yAxis.name,padding,padding+paddingTop-30); &#125; // x轴 ctx.save(); ctx.beginPath(); ctx.translate(padding,H-padding); ctx.moveTo(0,0); ctx.lineTo(W-2*padding,0); ctx.stroke(); // x轴刻度 if(this.xAxis&amp;&amp;(xl=this.xAxis.data.length))&#123; xs=(W-2*padding)/xl; this.xAxis.data.forEach((obj,i)=&gt;&#123; var x=xs*(i+1); ctx.moveTo(x,0); ctx.lineTo(x,10); ctx.stroke(); ctx.fillText(obj,x-xs/2,40); &#125;); &#125; ctx.restore(); // y轴 ctx.save(); ctx.beginPath(); ctx.strokeStyle='hsl(220,100%,50%)'; ctx.translate(padding,H-padding); ctx.moveTo(0,0); ctx.lineTo(0,2*padding+paddingTop-H); ctx.stroke(); ctx.restore(); if(this.series.length)&#123; var curr,txt,dim,info,item,tw=0; for(var i=0;i&lt;this.series.length;i++)&#123; item=this.series[i]; if(!item.data||!item.data.length)&#123; this.series.splice(i--,1);continue; &#125; // 赋予没有颜色的项 if(!item.color)&#123; var hsl=i%2?180+20*i/2:20*(i-1); item.color='hsla('+hsl+',70%,60%,1)'; &#125; item.name=item.name||'unnamed'; // 画分组标签 ctx.save(); ctx.translate(padding+W/4,paddingTop+40); that.legend.push(&#123; hide:item.hide||false, name:item.name, color:item.color, x:padding+that.W/4+i*90+tw, y:paddingTop+40, w:60, h:30, r:5 &#125;); ctx.textAlign='left'; ctx.fillStyle=item.color; ctx.strokeStyle=item.color; roundRect(ctx,i*90+tw,0,60,30,5); ctx.globalAlpha=item.hide?0.3:1; ctx.fill(); ctx.fillText(item.name,i*90+tw+70,26); tw+=ctx.measureText(item.name).width;//计算字符长度 ctx.restore(); if(item.hide)continue; //计算数据在Y轴刻度 if(!info)&#123; info=calculateY(item.data.slice(0,xl)); &#125; curr=calculateY(item.data.slice(0,xl)); if(curr.max&gt;info.max)&#123; info=curr; &#125; &#125; if(!info) return; yl=info.num; ys=ydis/yl; //画Y轴刻度 ctx.save(); ctx.fillStyle='hsl(200,100%,60%)'; ctx.translate(padding,H-padding); for(var i=0;i&lt;=yl;i++)&#123; ctx.beginPath(); ctx.strokeStyle='hsl(220,100%,50%)'; ctx.moveTo(-10,-Math.floor(ys*i)); ctx.lineTo(0,-Math.floor(ys*i)); ctx.stroke(); ctx.beginPath(); ctx.strokeStyle='hsla(0,0%,80%,1)'; ctx.moveTo(0,-Math.floor(ys*i)); ctx.lineTo(xdis,-Math.floor(ys*i)); ctx.stroke(); ctx.textAlign='right'; dim=Math.min(Math.floor(info.step*i),info.max); txt=this.yAxis.formatter?this.yAxis.formatter.replace('&#123;value&#125;',dim):dim; ctx.fillText(txt,-20,-ys*i+10); &#125; ctx.restore(); //画数据 this.showData(xl,xs,info.max); &#125;&#125; 绘制数据因为数据项需要后续执行动画和鼠标滑过的时候显示内容，所以把它放进动画队列animateArr中。这里要把分组数据展开，把之前的两次嵌套的数组转为一层，并计算好每个数据项的属性，比如名称，x坐标，y坐标，宽度，速度，颜色。数据组织完毕后，接着执行动画。showData(xl,xs,max)&#123; //画数据 var that=this, ctx=this.ctx, ydis=this.H-this.padding*2-this.paddingTop, sl=this.series.filter(s=&gt;!s.hide).length, sp=Math.max(Math.pow(10-sl,2)/3-4,5), w=(xs-sp*(sl+1))/sl, h,x,index=0; that.animateArr.length=0; // 展开数据项，填入动画队列 for(var i=0,item,len=this.series.length;i&lt;len;i++)&#123; item=this.series[i]; if(item.hide)continue; item.data.slice(0,xl).forEach((d,j)=&gt;&#123; h=d/max*ydis; x=xs*j+w*index+sp*(index+1); that.animateArr.push(&#123; index:i, name:item.name, num:d, x:Math.round(x), y:1, w:Math.round(w), h:Math.floor(h+2), vy:Math.max(300,Math.floor(h*2))/100, color:item.color &#125;); &#125;); index++; &#125; this.animate();&#125; 执行动画执行动画也没啥好说的，里面就是个自执行闭包函数。动画原理就是给y轴依次累加速度值vy。但记得当队列执行完动画后，要停止它，所以有个isStop的标志，每次执行完队列的时候就判断。animate()&#123; var that=this, ctx=this.ctx, isStop=true; (function run()&#123; isStop=true; for(var i=0,item;i&lt;that.animateArr.length;i++)&#123; item=that.animateArr[i]; if(item.y-item.h&gt;=0.1)&#123; item.y=item.h; &#125; else &#123; item.y+=item.vy; &#125; if(item.y&lt;item.h)&#123; ctx.save(); // ctx.translate(that.padding+item.x,that.H-that.padding); ctx.fillStyle=item.color; ctx.fillRect(that.padding+item.x,that.H-that.padding-item.y,item.w,item.y); ctx.restore(); isStop=false; &#125; &#125; if(isStop)return; requestAnimationFrame(run); &#125;())&#125; 绑定事件事件一：mousemove的时候，看看鼠标位置是不是处于分组标签还是数据项上，绘制路径后调用isPointInPath(x,y)，true则鼠标设置为手形；如果是数据项的话，还要把该柱形重新绘制，设置透明度，区分出来。还需要把内容显示出来，这里是一个相对父容器container为绝对定位的div，初始化的时候已经建立为tip属性了。我们把显示部分封装成showInfo方法。 事件二：mousedown的时候，一样绘制路径调用isPointInPath判断鼠标点击哪个分组标签，然后设置对应分组数据series中的hide属性，如果是true，表示不显示该项，然后调用draw方法，重写渲染绘制，执行动画。 bindEvent()&#123; var that=this, canvas=this.canvas, ctx=this.ctx; this.canvas.addEventListener('mousemove',function(e)&#123; var isLegend=false; // pos=WindowToCanvas(canvas,e.clientX,e.clientY); var box=canvas.getBoundingClientRect(); var pos = &#123; x:e.clientX-box.left, y:e.clientY-box.top &#125;; // 分组标签 for(var i=0,item,len=that.legend.length;i&lt;len;i++)&#123; item=that.legend[i]; ctx.save(); roundRect(ctx,item.x,item.y,item.w,item.h,item.r); // 因为缩小了一倍，所以坐标要*2 if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; canvas.style.cursor='pointer'; ctx.restore(); isLegend=true; break; &#125; canvas.style.cursor='default'; ctx.restore(); &#125; if(isLegend) return; //选择数据项 for(var i=0,item,len=that.animateArr.length;i&lt;len;i++)&#123; item=that.animateArr[i]; ctx.save(); ctx.fillStyle=item.color; ctx.beginPath(); ctx.rect(that.padding+item.x,that.H-that.padding-item.h,item.w,item.h); if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; //清空后再重新绘制透明度为0.5的图形 ctx.clearRect(that.padding+item.x,that.H-that.padding-item.h,item.w,item.h); ctx.globalAlpha=0.5; ctx.fill(); canvas.style.cursor='pointer'; that.showInfo(pos,item); ctx.restore(); break; &#125; canvas.style.cursor='default'; that.tip.style.display='none'; ctx.globalAlpha=1; ctx.fill(); ctx.restore(); &#125; &#125;,false); this.canvas.addEventListener('mousedown',function(e)&#123; e.preventDefault(); var box=canvas.getBoundingClientRect(); var pos = &#123; x:e.clientX-box.left, y:e.clientY-box.top &#125;; for(var i=0,item,len=that.legend.length;i&lt;len;i++)&#123; item=that.legend[i]; roundRect(ctx,item.x,item.y,item.w,item.h,item.r); // 因为缩小了一倍，所以坐标要*2 if(ctx.isPointInPath(pos.x*2,pos.y*2))&#123; that.series[i].hide=!that.series[i].hide; that.animateArr.length=0; that.draw(); break; &#125; &#125; &#125;,false);&#125;//显示数据showInfo(pos,obj)&#123; var txt=this.yAxis.formatter?this.yAxis.formatter.replace('&#123;value&#125;',obj.num):obj.num; var box=this.canvas.getBoundingClientRect(); var con=this.container.getBoundingClientRect(); this.tip.innerHTML = '&lt;p&gt;'+obj.name+':'+txt+'&lt;/p&gt;'; this.tip.style.left=(pos.x+(box.left-con.left)+10)+'px'; this.tip.style.top=(pos.y+(box.top-con.top)+10)+'px'; this.tip.style.display='block';&#125; 总结所有图表代码请看*chart.js*。这里完成的只是个基本的效果，其实还有很多地方要进一步优化，比如响应式的支持，移动端的支持，动画的效果，多y轴的支持，显示内容的效果，同时支持折线功能等。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"WebGL学习(1) - 三角形","date":"2017-11-08T08:35:21.000Z","path":"2017/11/08/webgltriangle/","text":"还记得第一次看到canvas的粒子特效的时候，真的把我给惊艳到了，原来在浏览器也能做出这么棒的效果。结合《HTML5 Canvas核心技术》和网上的教程，经过半年断断续续的学习，对canvas的学习终于完结，对常用的canvas特效基本能做到信手拈来的。canvas特效请看：样例列表 众所周知，canvas是2D绘图技术，虽然可以通过坐标变换，位置计算也能做到3D的效果。但3D场景数据量毕竟比2D要高一个数量级的，纯粹用canvas的话，不管是性能和开发的复杂度会成为一个瓶颈。 这也是webGL出现的原因，解决web端3D渲染的场景。webGL会调用到GPU，处理大量重复的3D场景数据时，性能非常有优势。同时webGL是基于openGL ES 2.0， 因此它处理3D场景是非常成熟的。但为什么不直接学习three.js呢？因为本人对图形学感兴趣，只是希望做一些自己喜欢的效果的同时深入了解计算机图形学，没指望通过它做商业项目。 为了让学习更有动力和目的性，我们以实例为导向学习webGL，再从中展开到需要学习哪些知识点。这次我们来实现如下的动画，该教程参考了《WebGL编程指南》 实际效果请看：旋转的三角形 webGL渲染流程webGL的渲染流程如下，其中第2，3，4步是重点，里面细节比较多。接着我们就按这个流程一步一步解决问题 获取webGL绘图上下文 初始化着色器 创建、绑定缓冲区对象 向顶点着色器和片元着色器写入数据 设置canvas背景色，清空canvas 绘制 webGL绘图上下文webGL是canvas基础之上的3D绘图技术，只是上下文不同，get3DContext函数作用就是依次降级获取上下文。 var canvas = document.getElementById(\"canvas\"), gl = get3DContext(canvas, true);function get3DContext(canvas, opt) &#123; var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"]; var context = null; for (var i = 0, len = names.length; i &lt; len; i++) &#123; try &#123; context = canvas.getContext(names[i], opt); &#125; catch (e) &#123;&#125; if (context) &#123; break; &#125; &#125; return context;&#125; 着色器着色器就是嵌入到js中的webGL代码，是由GLSL语言编写的，可以把着色器看成是js代码连接webGL的中间件。顶点着色器和片元着色器分别用于操作顶点和颜色光照，《WebGL编程指南》中是把着色器写成字符串，但从可维护性考虑，还是写在script标签中比较好。GLSL语言与C语言非常像，只要熟悉了GLSL特有的部分，其实还是比较简单的。 限定符限定符只能用于全局变量，有3种类型： attribute用于表示顶点信息 uniform用于表示除顶点外的其他信息，可以是除结构体和数组之外的任意类型 varying用于顶点着色器向片元着色器传输数据 GLSL特有的数据类型 向量： vec2, vec3, vec4 : 表示有2,3,4个浮点数的向量 ivec2, ivec3, ivec4 : 表示有2,3,4个整形的向量 bvec2, bvec3, bvec4 : 表示有2,3,4个布尔值的向量 矩阵： mat2, mat3, mat4 : 表示有2x2,3x3,4x4的浮点数的矩阵 顶点着色器 &lt;script type=\"x-shader/x-vertex\" id=\"vs\"&gt;attribute vec4 a_Position; //顶点，4个浮点的矢量，attribute变量传输与顶点有关的数据，表示逐顶点的信息uniform mat4 u_xformMatrix; //变换矩阵，4*4浮点矩阵, uniform变量传输的是所有顶点都相同的数据void main() &#123; gl_Position=u_xformMatrix*a_Position;&#125; &lt;/script&gt; 片元着色器 &lt;script type=\"x-shader/x-fragment\" id=\"fs\"&gt;precision mediump float; // 精度限定uniform vec4 u_FragColor; // 颜色void main() &#123; gl_FragColor = u_FragColor;&#125;&lt;/script&gt; 接着就是创建着色器了，首先从页面script标签取出着色器代码，初始化着色器；接着创建程序对象，最后连接程序对象。中间的步骤其实非常的啰嗦，已经把这几个步骤封装，我们只需要调用createShaders就可以了。 /** * 根据script id创建着色器 * @param &#123;Object&#125; gl context * @param &#123;String&#125; vid script id * @param &#123;String&#125; fid script id * @return &#123;Boolen&#125; */function createShaders(gl, vid, fid) &#123; var vshader, fshader, element, program; [vid, fid].forEach(function(id) &#123; element = document.getElementById(id); if (element) &#123; switch (element.type) &#123; // 顶点着色器的时候 case \"x-shader/x-vertex\": vshader = element.text; break; // 片段着色器的时候 case \"x-shader/x-fragment\": fshader = element.text; break; default: break; &#125; &#125; &#125;); if (!vshader) &#123; console.log(\"VERTEX_SHADER String not exist\"); return false; &#125; if (!fshader) &#123; console.log(\"FRAGMENT_SHADER String not exist\"); return false; &#125; program = createProgram(gl, vshader, fshader); if (!program) &#123; console.log(\"Failed to create program\"); return false; &#125; gl.useProgram(program); gl.program = program; return true;&#125;/** * 创建连接程序对象 * @param &#123;Object&#125; gl 上下文 * @param &#123;String&#125; vshader 顶点着色器代码 * @param &#123;String&#125; fshader 片元着色器代码 * @return &#123;Object&#125; */function createProgram(gl, vshader, fshader) &#123; // 创建着色器对象 var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader); var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader); if (!vertexShader || !fragmentShader) &#123; return null; &#125; // 创建程序对象 var program = gl.createProgram(); if (!program) &#123; return null; &#125; // 连接着色器对象 gl.attachShader(program, vertexShader); gl.attachShader(program, fragmentShader); // 连接程序对象 gl.linkProgram(program); // 检查连接结果 var linked = gl.getProgramParameter(program, gl.LINK_STATUS); if (!linked) &#123; var error = gl.getProgramInfoLog(program); console.log(\"Failed to link program: \" + error); gl.deleteProgram(program); gl.deleteShader(fragmentShader); gl.deleteShader(vertexShader); return null; &#125; return program;&#125;/** * 加载着色器 * @param &#123;Object&#125; gl 上下文 * @param &#123;Object&#125; type 类型 * @param &#123;String&#125; source 代码字符串 * @return &#123;Object&#125; */function loadShader(gl, type, source) &#123; // 创建着色器对象 var shader = gl.createShader(type); if (shader == null) &#123; console.log(\"unable to create shader\"); return null; &#125; // 设置着色器程序 gl.shaderSource(shader, source); // 编译着色器 gl.compileShader(shader); // 检查编译结果 var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); if (!compiled) &#123; var error = gl.getShaderInfoLog(shader); console.log(\"Failed to compile shader: \" + error); gl.deleteShader(shader); return null; &#125; return shader;&#125; 缓冲区创建好缓冲区对象后，需要把它分配给变量，然后使它生效。注意顶点数组使用的是类型化数组Float32Array，这样更加高效。vertexAttribPointer方法这里指定了每个顶点分量的个数为2，因为我们目前只定义x,y坐标，z坐标使用系统默认。 /** * 创建缓冲区 * @param &#123;Array&#125; data * @param &#123;Object&#125; bufferType * @return &#123;Object&#125; */function createBuffer(data, bufferType) &#123; // 生成缓存对象 var buffer = gl.createBuffer(); if (!buffer) &#123; console.log(\"Failed to create the buffer object\"); return null; &#125; // 绑定缓存(gl.ARRAY_BUFFER&lt;顶点&gt;||gl.ELEMENT_ARRAY_BUFFER&lt;顶点索引&gt;) gl.bindBuffer(bufferType || gl.ARRAY_BUFFER, buffer); // 向缓存中写入数据 gl.bufferData(bufferType || gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); // 将绑定的缓存设为无效 // gl.bindBuffer(gl.ARRAY_BUFFER, null); // 返回生成的buffer return buffer;&#125;// 创建缓冲区并传人顶点var vertices = new Float32Array([-0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5]);if (!createBuffer(vertices)) return;// 分配缓冲区对象给a_Position变量// (地址,每个顶点分量的个数&lt;1-4&gt;,数据类型&lt;整形，符点等&gt;,是否归一化,指定相邻两个顶点间字节数&lt;默认0&gt;,指定缓冲区对象偏移量&lt;默认0&gt;)gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0);// 启动gl.enableVertexAttribArray(a_Position); 写入数据首先要获取变量的地址，然后再给变量赋值，感觉挺麻烦的。attribute标记的变量使用getAttribLocation获取，同理uniform标记的变量使用getUniformLocation获取。 我们的动画要使图形绕坐标原点旋转，那么这就需要用到矩阵的变换，矩阵相关的知识就不详细说明了。要注意webGL使用的是列主序的矩阵，计算好变换矩阵后，把值赋予变量就ok。 // 获取 u_FragColor变量的存储地址并赋值var u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor');if (!u_FragColor) return;//颜色模式为rgba，值范围0～1gl.uniform4f(u_FragColor, 1.0, 0.0, 0.0, 1.0);// 绕z轴旋转var deg=Math.PI/180*(angle++), cos=Math.cos(deg), sin=Math.sin(deg);// webgl中是按列主序 旋转加位移var xformMatrix=new Float32Array([ cos,sin,0.0,0.0, -sin,cos,0.0,0.0, 0.0,0.0,1.0,0.0, 0.3,0.0,0.0,1.0]);// v表示可以向着色器传输多个数值(地址变量,webgl中必须false,矩阵)gl.uniformMatrix4fv(u_xformMatrix,false,xformMatrix); 背景操作每次执行动画前进行清屏，和canvas中的设置fillStyle，执行clearRect，效果一样。 // 设置清屏颜色gl.clearColor(0.0, 0.0, 0.0, 1.0);// 清屏gl.clear(gl.COLOR_BUFFER_BIT); 绘制最后渲染图形，注意第一个参数，指定不同的值，它就渲染为不同的图形，大家可以用不同的值试试效果。 POINTS 点 LINES 线段 LINE_STRIP 线条 LINE_LOOP 回路 TRIANGLES 三角形 TRIANGLE_STRIP 三角带 TRIANGLE_FAN 三角扇 // (基本图形，第几个顶点，执行几次)，修改基本图形项可以生成点，线，三角形，矩形，扇形等gl.drawArrays(gl.TRIANGLES, 0, 3); 最后主体代码如下： var canvas = document.getElementById(\"canvas\"), gl = get3DContext(canvas, true);function main() &#123; if (!gl) &#123; console.log(\"Failed to get the rendering context for WebGL\"); return; &#125; if (!createShaders(gl, \"fs\", \"vs\")) &#123; console.log(\"Failed to intialize shaders.\"); return; &#125; // 创建缓冲区并传人顶点 var vertices = new Float32Array([ -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, -0.5 ]); if (!createBuffer(vertices)) &#123; console.log(\"Failed to create the buffer object\"); return; &#125; // 获取顶点位置 var a_Position = gl.getAttribLocation(gl.program, \"a_Position\"); if (a_Position &lt; 0) &#123; console.log(\"Failed to get the storage location of a_Position\"); return; &#125; // 分配缓冲区对象给a_Position变量 gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(a_Position); // 获取 u_FragColor变量的存储地址并赋值 var u_FragColor = gl.getUniformLocation(gl.program, \"u_FragColor\"); if (!u_FragColor) &#123; console.log(\"Failed to get the storage location of u_FragColor\"); return; &#125; gl.uniform4f(u_FragColor, 1.0, 0.0, 0.0, 1.0); // 获取矩阵变量 var u_xformMatrix = gl.getUniformLocation(gl.program, \"u_xformMatrix\"); if (!u_xformMatrix) &#123; console.log(\"Failed to get the storage location of u_xformMatrix\"); return; &#125; var xformMatrix, angle = 0; // 设置清屏颜色 gl.clearColor(0.0, 0.0, 0.0, 1.0); // 执行动画 (function animate() &#123; var deg = (Math.PI / 180) * angle++, cos = Math.cos(deg), sin = Math.sin(deg); // 旋转加位移 xformMatrix = new Float32Array([ cos, sin, 0.0, 0.0, -sin, cos, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.3, 0.0, 0.0, 1.0 ]); // v表示可以向着色器传输多个数值(地址变量,webgl中必须false,矩阵) gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix); gl.clear(gl.COLOR_BUFFER_BIT); // (基本图形，第几个顶点，执行几次)，修改基本图形项可以生成点，线，三角形，矩形，扇形等 gl.drawArrays(gl.TRIANGLES, 0, 3); requestAnimationFrame(animate); &#125;)();&#125;main(); 总结相比canvas，webGL的api要原始得多，涉及到很多底层的openGL细节，但经过封装后，我们可以把那部分细节看成一个黑箱。大部分的操作都是基于矩阵变换，尽管有很多方便的第三方矩阵库，但有牢固的线性代数基础还是大有裨益的，GLSL编程语言也是一样需要熟练掌握。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"webGL","slug":"webGL","permalink":"https://edwardzhong.github.io/tags/webGL/"}]},{"title":"canvas图形编辑器","date":"2017-11-02T05:27:38.000Z","path":"2017/11/02/drawboard/","text":"使用canvas进行开发项目，我们离不开各种线段，曲线，图形，但每次都必须用代码一步一步去实现，显得非常麻烦。有没有一种类似于PS，CAD之类的可视化工具，绘制出基本的图形，然后输出代码。之后我们就可以在这个生成的图形场景的基础上去实现功能，那将是多么的美妙的事啊。话不多说，我们来实现一个图形编辑器吧😂。 主要实现如下的功能： 直线(实线、虚线) 贝塞尔曲线(2次，3次) 多边形(三角形、矩形、任意边形) 多角星(3角星、4角星、5角星…) 圆形、椭圆 实际效果: drawboard(推荐在chrome或safari下运行) 功能点包括： 所有的图形都可以拖拽位置，直线和曲线需要拖拽中点(黄色圆点)，其他图形只需要把鼠标放于图形内部拖拽即可； 所有的图形只要把鼠标放于中心点或图形内部，然后按delete键即可删除； 线段可以实现拉伸减少长度，旋转角度； 贝塞尔曲线可以通过拖拽控制点实现任意形状的变化； 多边形可以拖拽控制点控制多边形的旋转角度和大小变化，所有顶点都可以拖拽； 多角星除了多边形的功能外，拖拽第二控制点可以实现图形的饱满程度； 是否填充图形，是否显示控制线，是否显示背景格； 生成代码。 使用方式： 选中工具栏中的图形选项，是否填充，颜色等，然后在画板拖动鼠标，同时选中的工具栏中的选项复位，此时为绘图模式； 完成绘制图形后，可以对图形进行拖拽位置，变换顶点，旋转等，此时为修改模式； 然后再选中工具栏选项，再次绘制，如此类推； 可以消除控制线和背景格，查看效果，然后可以点击生成代码，复制代码即可。 该项目用到的知识点包括： ES6面向对象 html5标签，布局 基本的三角函数 canvas部分有：坐标变换，渐变，混合模式，线条和图形的绘制。 工具栏 首先我们实现如图所示的工具栏，也就是基本的html/css，使用了flex布局，同时使用了html5的color, range, number标签，其它都是普通的html和css代码。主要注意的地方就是如下用纯css实现选择效果 .wrap [type=radio]&#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 99; opacity: 0; cursor: pointer;&#125;.wrap [type=radio]:checked~.label&#123;/* 覆盖radio */ background: hsl(200, 100%, 40%); color: hsl(0, 0%, 100%)&#125; 其中多边形边数选择范围控制为：3-20，当然我们也可以扩大为无限大的边数，但实际应用到的情况比较少。多角星情况类型，范围控制为3～20。 然后对线条粗细，描边颜色，填充颜色显示信息，也就是onchang事件触发时获取value值，再显示出来。显示鼠标当前的位置功能也非常简单，在此也略过不表。 图形基类开始实现画板的功能，第一步，实现图形基类，这个是最重要的部分。因为不管是线条，多边形都会继承该类。注意：isPointInPath非常有用，就是这个api实现鼠标是否选中的功能了，它的原理就是调用上下文context绘制路径，然后向isPointInPath传递位置(x,y)信息，该api会返回这个点是否在绘制路径上，相当于绘制的是隐形的路径进行判断点是否在该路径或图形内部，这也是我要把绘制路径和渲染的功能分离开的原因。 具体的功能还是直接看代码吧 class Graph&#123; //初始化图形需要用到的属性，位置，顶点列表，边的宽度，描边颜色，填充颜色，是否填充； constructor(pos)&#123; this.x=pos.x; this.y=pos.y; this.points=[]; this.sides=5; this.stars=5; this.lineWidth=1; this.strokeStyle='#f00'; this.fillStyle='#f00'; this.isFill=false; &#125; //实现绘制时的拖拽 initUpdate(start,end)&#123; this.points[1]=end; this.x=(start.x+end.x)/2; this.y=(start.y+end.y)/2; &#125; //实现修改模式下的拖拽顶点和控制点 update(i,pos)&#123; if(i==9999)&#123; var that=this, x1=pos.x-this.x, y1=pos.y-this.y; this.points.forEach((p,i)=&gt;&#123; that.points[i]=&#123;x:p.x+x1, y:p.y+y1 &#125;; &#125;); this.x=Math.round(pos.x); this.y=Math.round(pos.y); &#125; else &#123; this.points[i]=pos; var x=0,y=0; this.points.forEach(p=&gt;&#123; x+=p.x; y+=p.y; &#125;); this.x=Math.round(x/this.points.length); this.y=Math.round(y/this.points.length); &#125; &#125; //绘制路径 createPath(ctx)&#123; ctx.beginPath(); this.points.forEach((p,i)=&gt;&#123; ctx[i==0?'moveTo':'lineTo'](p.x,p.y); &#125;); ctx.closePath(); &#125; //判断鼠标是否选中对应的图形，选中哪个顶点，选中哪个控制点，中心点； isInPath(ctx,pos)&#123; for(var i=0,point,len=this.points.length;i&lt;len;i++)&#123; point=this.points[i]; ctx.beginPath(); ctx.arc(point.x,point.y,5,0,Math.PI*2,false); if(ctx.isPointInPath(pos.x,pos.y))&#123; return i; &#125; &#125; this.createPath(ctx); if(ctx.isPointInPath(pos.x,pos.y))&#123; return 9999; &#125; return -1 &#125; //绘制控制点 drawController(ctx)&#123; this.drawPoints(ctx); this.drawCenter(ctx); &#125; //绘制顶点 drawPoints()&#123; ctx.save(); ctx.lineWidth=2; ctx.strokeStyle='#999'; this.points.forEach(p=&gt;&#123; ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2,false); ctx.stroke(); &#125;); ctx.restore(); &#125; //绘制中心点 drawCenter(ctx)&#123; ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='hsla(60,100%,45%,1)'; ctx.fillStyle='hsla(60,100%,50%,1)'; ctx.beginPath(); ctx.arc(this.x,this.y,5,0,Math.PI*2,false); ctx.stroke(); ctx.fill(); ctx.restore(); &#125; //绘制整个图形 draw(ctx)&#123; ctx.save(); ctx.lineWidth=this.lineWidth; ctx.strokeStyle=this.strokeStyle; ctx.fillStyle=this.fillStyle; this.createPath(ctx); ctx.stroke(); if(this.isFill)&#123; ctx.fill(); &#125; ctx.restore(); &#125; //生成代码 createCode()&#123; var codes=['// '+this.name]; codes.push('ctx.save();'); codes.push('ctx.lineWidth='+this.lineWidth); codes.push('ctx.strokeStyle=\\''+this.strokeStyle+'\\';'); if(this.isFill)&#123; codes.push('ctx.fillStyle=\\''+this.fillStyle+'\\';'); &#125; codes.push('ctx.beginPath();'); codes.push('ctx.translate('+this.x+','+this.y+');')//translate到中心点，方便使用 this.points.forEach((p,i)=&gt;&#123; if(i==0)&#123; codes.push('ctx.moveTo('+(p.x-this.x)+','+(p.y-this.y)+');'); // codes.push('ctx.moveTo('+(p.x)+','+(p.y)+');'); &#125; else &#123; codes.push('ctx.lineTo('+(p.x-this.x)+','+(p.y-this.y)+');'); // codes.push('ctx.lineTo('+(p.x)+','+(p.y)+');'); &#125; &#125;); codes.push('ctx.closePath();'); codes.push('ctx.stroke();'); if(this.isFill)&#123; codes.push('ctx.fill();'); &#125; codes.push('ctx.restore();'); return codes.join('\\n'); &#125;&#125; 直线 实现直线功能相当简单，继承基类，只需要重写draw和createCode方法，拖拽和变换等功能都已经在基类实现了。 class Line extends Graph&#123; constructor(pos)&#123; super(pos); this.points=[pos,pos]; this.name='直线' &#125; createPath(ctx)&#123; ctx.beginPath(); ctx.arc(this.x,this.y,5,0,Math.PI*2,false); &#125; draw(ctx)&#123; ctx.save(); ctx.lineWidth=this.lineWidth; ctx.strokeStyle=this.strokeStyle; ctx.beginPath(); this.points.forEach((p,i)=&gt;&#123; if(i==0)&#123; ctx.moveTo(p.x,p.y); &#125; else &#123; ctx.lineTo(p.x,p.y); &#125; &#125;); ctx.closePath(); ctx.stroke(); ctx.restore(); &#125; createCode()&#123; var codes=['// '+this.name]; codes.push('ctx.lineWidth='+this.lineWidth); codes.push('ctx.strokeStyle=\\''+this.strokeStyle+'\\';'); codes.push('ctx.beginPath();'); this.points.forEach((p,i)=&gt;&#123; if(i==0)&#123; codes.push('ctx.moveTo('+p.x+','+p.y+');'); &#125; else &#123; codes.push('ctx.lineTo('+p.x+','+p.y+');'); &#125; &#125;); codes.push('ctx.closePath();'); codes.push('ctx.stroke();'); return codes.join('\\n'); &#125;&#125; 还有就是虚线功能了，其实就是先绘制一段直线，然后空出一段空间，接着再绘制一段直线，如此类推。小伙伴可以思考一下怎么实现，这个和直线所涉及的知识点相同，代码就略过了。 贝塞尔曲线 接着就是贝塞尔曲线的绘制了，首先继承直线类，曲线比直线不同的是除了起始点和结束点，它还多出了控制点，2次贝塞尔曲线有一个控制点，3次贝塞尔曲线则有两个控制点。所以对应初始化拖拽，顶点绘制的方法必须重写，以下是3次贝塞尔曲线的代码。 class Bezier extends Line &#123; constructor(pos)&#123; super(pos); this.points=[pos,pos,pos,pos]; this.name='三次贝塞尔曲线' &#125; initUpdate(start,end)&#123; var a=Math.round(Math.sqrt(Math.pow(end.x-start.x,2)+Math.pow(end.y-start.y,2)))/2, x1=start.x+(end.x-start.x)/2, y1=start.y-a, y2=end.y+a; this.points[1]=&#123;x:end.x,y:end.y&#125;; this.points[2]=&#123;x:x1,y:y1&lt;0?0:y1&#125;; this.points[3]=&#123;x:start.x,y:end.y&#125;; this.points[3]=&#123;x:x1,y:y2&gt;H?H:y2&#125;; this.x=(start.x+end.x)/2; this.y=(start.y+end.y)/2; &#125; drawPoints(ctx)&#123; ctx.lineWidth=0.5; ctx.strokeStyle='#00f'; //画控制点的连线 ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); ctx.lineTo(this.points[2].x, this.points[2].y); ctx.moveTo(this.points[1].x, this.points[1].y); ctx.lineTo(this.points[3].x, this.points[3].y); ctx.stroke(); //画连接点和控制点 this.points.forEach(function(point,i)&#123; ctx.beginPath(); ctx.arc(point.x,point.y,5,0,Math.PI*2,false); ctx.stroke(); &#125;); &#125; draw()&#123; ctx.save(); ctx.lineWidth=this.lineWidth; ctx.strokeStyle=this.strokeStyle; ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y); ctx.bezierCurveTo(this.points[2].x,this.points[2].y,this.points[3].x,this.points[3].y,this.points[1].x,this.points[1].y); ctx.stroke(); ctx.restore(); &#125; createCode()&#123; var codes=['// '+this.name]; codes.push('ctx.lineWidth='+this.lineWidth); codes.push('ctx.strokeStyle=\\''+this.strokeStyle+'\\';'); codes.push('ctx.beginPath();'); codes.push(`ctx.moveTo($&#123;this.points[0].x&#125;,$&#123;this.points[0].y&#125;);`); codes.push(`ctx.bezierCurveTo($&#123;this.points[2].x&#125;,$&#123;this.points[2].y&#125;,$&#123;this.points[3].x&#125;,$&#123;this.points[3].y&#125;,$&#123;this.points[1].x&#125;,$&#123;this.points[1].y&#125;);`); codes.push('ctx.stroke();'); return codes.join('\\n'); &#125;&#125; 至于贝塞尔2次曲线功能类似，同时也更加简单，代码也略过。 多边形 实现任意条边的多边形，大家思考一下都会知道如何实现，平均角度=360度／边数，不是吗？ 在知道中点和第一个顶点的情况下，第n个顶点与中点的角度 = n*平均角度；然后记录下每个顶点的位置，然后依次绘制每个顶点的连线即可。这里用到了二维旋转的公式，也就是绕图形的中点，旋转一定的角度。 既然我们已经记录了每个顶点的位置，当拖动对应的顶点后修改该顶点位置，重新绘制，就可以伸缩成任意的图案。 难点是拖拽控制线，实现旋转多边形角度，和扩大缩小多边形。等比例扩大缩小每个顶点与中点的距离即可实现等比例缩放多边形，记录第一个顶点与中点的角度变化即可实现旋转功能，这里用到反正切Math.atan2(y,x)求角度；具体实现看如下代码。 /** * 多边形 */class Polygon extends Graph&#123; constructor(pos)&#123; super(pos); this.cPoints=[]; &#125; get name()&#123; return this.sides+'边形'; &#125; //生成顶点 createPoints(start,end)&#123; var x1 = end.x - start.x, y1 = end.y - start.y, angle=0; this.points=[]; for(var i=0;i&lt;this.sides;i++)&#123; angle=2*Math.PI/this.sides*i; var sin=Math.sin(angle), cos=Math.cos(angle), newX = x1*cos - y1*sin, newY = y1*cos + x1*sin; this.points.push(&#123; x:Math.round(start.x + newX), y:Math.round(start.y + newY) &#125;); &#125; &#125; //生成控制点 createControlPoint(start,end,len)&#123; var x1 = end.x - start.x, y1 = end.y - start.y, angle=Math.atan2(y1,x1), c=Math.round(Math.sqrt(x1*x1+y1*y1)), l=c+(!len?0:c/len), x2 =l * Math.cos(angle) + start.x, y2 =l * Math.sin(angle) + start.y; return &#123;x:x2,y:y2&#125;; &#125; initUpdate(start,end)&#123; this.createPoints(start,end); this.cPoints[0]=this.createControlPoint(start,end,3); &#125; //拖拽功能 update(i,pos)&#123; if(i==10000)&#123;//拖拽控制点 var point=this.createControlPoint(&#123;x:this.x,y:this.y&#125;,pos,-4); this.cPoints[0]=pos; this.createPoints(&#123;x:this.x,y:this.y&#125;,point); &#125; else if(i==9999)&#123; //移动位置 var that=this, x1=pos.x-this.x, y1=pos.y-this.y; this.points.forEach((p,i)=&gt;&#123; that.points[i]=&#123;x:p.x+x1, y:p.y+y1 &#125;; &#125;); this.cPoints.forEach((p,i)=&gt;&#123; that.cPoints[i]=&#123;x:p.x+x1,y:p.y+y1&#125;; &#125;); this.x=Math.round(pos.x); this.y=Math.round(pos.y); &#125; else &#123;//拖拽顶点 this.points[i]=pos; var x=0,y=0; this.points.forEach(p=&gt;&#123; x+=p.x; y+=p.y; &#125;); this.x=Math.round(x/this.points.length); this.y=Math.round(y/this.points.length); &#125; &#125; createCPath(ctx)&#123; this.cPoints.forEach(p=&gt;&#123; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2,false); &#125;); &#125; isInPath(ctx,pos)&#123; var index=super.isInPath(ctx,pos); if(index&gt;-1) return index; this.createCPath(ctx); for(var i=0,len=this.cPoints.length;i&lt;len;i++)&#123; var p=this.cPoints[i]; ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2,false); if(ctx.isPointInPath(pos.x,pos.y))&#123; return 10000+i;break; &#125; &#125; return -1 &#125; drawCPoints(ctx)&#123; ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='hsla(0,0%,50%,1)'; ctx.fillStyle='hsla(0,100%,60%,1)'; this.cPoints.forEach(p=&gt;&#123; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(p.x,p.y); ctx.stroke(); ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2,false); ctx.stroke(); ctx.fill(); &#125;); ctx.restore(); &#125; drawController(ctx)&#123; this.drawPoints(ctx); this.drawCPoints(ctx); this.drawCenter(ctx); &#125;&#125; 多角星 仔细思考一下，多角星其实就是2*n边形，不过它是凹多边形而已，于是我们在之前凸多边形基础上去实现。相比于多边形，我们还要在此基础上增加第二控制点，实现凹点与凸点的比值变化，通俗点就是多角星的胖瘦度。 class Star extends Polygon&#123; //增加凹顶点与凸顶点的比例属性size constructor(pos)&#123; super(pos); this.cPoints=[]; this.size=0.5; &#125; get name() &#123; return this.stars+'角星' &#125; // 增加凹顶点 createPoints(start,end)&#123; var x1 = end.x - start.x, y1 = end.y - start.y, x2 =x1*this.size, y2 =y1*this.size, angle=0, angle2=0; this.points=[]; for(var i=0;i&lt;this.stars;i++)&#123; angle=2*Math.PI/this.stars*i; angle2=angle+Math.PI/this.stars; var sin=Math.sin(angle), cos=Math.cos(angle), newX = x1*cos - y1*sin, newY = y1*cos + x1*sin, sin2=Math.sin(angle2), cos2=Math.cos(angle2), newX2 = x2*cos2 - y2*sin2, newY2 = y2*cos2 + x2*sin2; this.points.push(&#123; x:Math.round(start.x + newX), y:Math.round(start.y + newY) &#125;); this.points.push(&#123; x:Math.round(start.x + newX2), y:Math.round(start.y + newY2) &#125;); &#125; &#125; initUpdate(start,end)&#123; this.createPoints(start,end); this.cPoints[0]=this.createControlPoint(start,end,3); this.cPoints[1]=this.createControlPoint(start,this.points[1],3); &#125; update(i,pos)&#123; if(i==10000)&#123; var ang=Math.PI/this.stars, angle=Math.atan2(pos.y-this.y,pos.x-this.x), sin=Math.sin(ang+angle), cos=Math.cos(ang+angle), a=Math.sqrt(Math.pow(pos.x-this.x,2)+Math.pow(pos.y-this.y,2)); this.cPoints[1]=&#123; x:(a*this.size+10)*cos+this.x, y:(a*this.size+10)*sin+this.y &#125;; var point=this.createControlPoint(&#123;x:this.x,y:this.y&#125;,pos,-4);//第一个顶点坐标 this.cPoints[0]=pos;//第一个选择控制点坐标 this.createPoints(&#123;x:this.x,y:this.y&#125;,point);//更新所有顶点 &#125; else if(i==10001)&#123; var x1 = this.points[1].x - this.x, y1 = this.points[1].y - this.y, angle=Math.atan2(y1,x1), a=Math.sqrt(Math.pow(pos.x-this.x,2)+Math.pow(pos.y-this.y,2)), b=Math.sqrt(Math.pow(this.points[0].x-this.x,2)+Math.pow(this.points[0].y-this.y,2)); var x=a*Math.cos(angle), y=a*Math.sin(angle); this.size=(a-20)/b; this.cPoints[1]=&#123;x:this.x+x, y:this.y+y &#125;; this.createPoints(&#123;x:this.x,y:this.y&#125;,this.points[0]);//更新所有顶点 &#125; else &#123; super.update(i,pos); &#125; &#125;&#125; 三角形，矩形 这两个图形就是特别的多边形而已，功能非常简单，而且只需要继承图形基类Graph /** * 三角形 */class Triangle extends Graph&#123; constructor(pos)&#123; super(pos); this.points=[pos,pos,pos]; this.name='三角形'; &#125; initUpdate(start,end)&#123; var x1=Math.round(start.x), y1=Math.round(start.y), x2=Math.round(end.x), y2=Math.round(end.y); this.points[0]=&#123;x:x1,y:y1&#125;; this.points[1]=&#123;x:x1,y:y2&#125;; this.points[2]=&#123;x:x2,y:y2&#125;; this.x=Math.round((x1*2+x2)/3); this.y=Math.round((y2*2+y1)/3); &#125;&#125;/** * 矩形 */class Rect extends Graph&#123; constructor(pos)&#123; super(pos); this.points=[pos,pos,pos,pos]; this.name='矩形'; &#125; initUpdate(start,end)&#123; var x1=Math.round(start.x), y1=Math.round(start.y), x2=Math.round(end.x), y2=Math.round(end.y); this.points[0]=&#123;x:x1,y:y1&#125;; this.points[1]=&#123;x:x2,y:y1&#125;; this.points[2]=&#123;x:x2,y:y2&#125;; this.points[3]=&#123;x:x1,y:y2&#125;; this.x=Math.round((x1+x2)/2); this.y=Math.round((y1+y2)/2); &#125;&#125; 圆形，椭圆 绘制圆形比较简单，只需要知道中点和半径，即可绘制，代码在此省略。 椭圆的绘制才是比较麻烦的，canvas并没有提供相关的api，我这里参考了网上的例子，是使用4条三次贝塞尔曲线首尾相接来实现的，椭圆有两个控制点，分别可以拖拽实现椭圆的压扁程度。这里只展示部分的代码，其他和多边形类似： initUpdate(start,end)&#123; this.points[0]=end; this.a=Math.round(Math.sqrt(Math.pow(this.points[0].x-start.x,2)+Math.pow(this.points[0].y-start.y,2))); this.b=this.a/2; this.angle = Math.atan2(this.points[0].y-this.y,this.points[0].x-this.x); this.rotateA(); &#125; update(i,pos)&#123; if(i==9999)&#123; var that=this, x1=pos.x-this.x, y1=pos.y-this.y; this.points.forEach((p,i)=&gt;&#123; that.points[i]=&#123;x:p.x+x1, y:p.y+y1 &#125;; &#125;); this.x=pos.x; this.y=pos.y; &#125; else &#123; this.points[i]=pos; if(i==0)&#123; this.a=Math.round(Math.sqrt(Math.pow(this.points[0].x-this.x,2)+Math.pow(this.points[0].y-this.y,2))); this.angle = Math.atan2(this.points[0].y-this.y,this.points[0].x-this.x); this.rotateA(); &#125; else if(i==1)&#123; this.b=Math.round(Math.sqrt(Math.pow(this.points[1].x-this.x,2)+Math.pow(this.points[1].y-this.y,2))); this.angle = Math.PI/2+Math.atan2(this.points[1].y-this.y,this.points[1].x-this.x); this.rotateB(); &#125; &#125;&#125;createPath(ctx)&#123; var k = .5522848, x=0, y=0, a=this.a, b=this.b, ox = a * k, // 水平控制点偏移量 oy = b * k; // 垂直控制点偏移量 ctx.beginPath(); //从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线 ctx.moveTo(x - a, y); ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b); ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y); ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b); ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y); ctx.closePath();&#125; 事件部分绘图的主体部分已经完成，接下来就是定义相关的事件了，首先mousedown的时候记录下第一个坐标mouseStart，这个点是绘制直线和曲线的起始点，同时也是多边形和多角星的中点； 然后再定义mousemove事件，记录下第二个坐标mouseEnd，这个是绘制直线和曲线的结束点，同时也是多边形和多角星的第一个顶点； 当然这中间还要区分绘制模式和修改模式，绘制模式下，根据类型从对象工厂获取对应的对象，然后设置对象的属性，完成初始化之后就把图形对象放入图形列表shapes中。列表中的图形对象就可以作为后续修改模式进行应用动画。 如果是修改模式的话，首先是遍历shapes中所有的图形对象，并依次调用isInPath方法，看看当前的鼠标位置是否在该图形上，并判断是在中点或图形内部，还是某个顶点上。而具体的判断逻辑已经控制反转在图形对象内部，外部并不需要知道其实现原理。如果鼠标落在了某个图形对象上，则在鼠标移动时实时更新该图形对应的位置，顶点，控制点，并同步动画渲染该图形。 删除功能的实现，就是按下delete键时，遍历shapes中所有的图形对象，并依次调用isInPath方法，鼠标如果在该对象上面，直接在shapes数组上splice(i,1)，然后重写渲染就ok。 生成代码功能一样，遍历shapes，依次调用createCode方法获取该图形生成的代码字符串，然后将所有值合并赋予textarea的value。 这里要理解的是，只要启动了对应的模式，改变了图形的某部分，背景和对应所有的图形都要重新绘制一遍，当然这也是canvas这种比较底层的绘图api实现动画的方式了。 // 生成对应图形的对象工厂function factory(type,pos)&#123; switch(type)&#123; case 'line': return new Line(pos); case 'dash': return new Dash(pos); case 'quadratic': return new Quadratic(pos); case 'bezier': return new Bezier(pos); case 'triangle': return new Triangle(pos); case 'rect': return new Rect(pos); case 'round': return new Round(pos); case 'polygon': return new Polygon(pos); case 'star': return new Star(pos); case 'ellipse': return new Ellipse(pos); default:return new Line(pos); &#125;&#125;canvas.addEventListener('mousedown',function(e)&#123; mouseStart=WindowToCanvas(canvas,e.clientX,e.clientY); env=getEnv(); activeShape=null; //新建图形 if(drawing)&#123; activeShape = factory(env.type,mouseStart); activeShape.lineWidth = env.lineWidth; activeShape.strokeStyle = env.strokeStyle; activeShape.fillStyle = env.fillStyle; activeShape.isFill = env.isFill; activeShape.sides = env.sides; activeShape.stars = env.stars; shapes.push(activeShape); index=-1; drawGraph(); &#125; else &#123; //选中控制点后拖拽修改图形 for(var i=0,len=shapes.length;i&lt;len;i++)&#123; if((index=shapes[i].isInPath(ctx,mouseStart))&gt;-1)&#123; canvas.style.cursor='crosshair'; activeShape=shapes[i];break; &#125; &#125; &#125; // saveImageData(); canvas.addEventListener('mousemove',mouseMove,false); canvas.addEventListener('mouseup',mouseUp,false);&#125;,false);// 鼠标移动function mouseMove(e)&#123; mouseEnd=WindowToCanvas(canvas,e.clientX,e.clientY); if(activeShape)&#123; if(index&gt;-1)&#123; activeShape.update(index,mouseEnd); &#125; else &#123; activeShape.initUpdate(mouseStart,mouseEnd); &#125; drawBG(); if(env.guid)&#123;drawGuidewires(mouseEnd.x,mouseEnd.y); &#125; drawGraph(); &#125;&#125;// 鼠标结束function mouseUp(e)&#123; canvas.style.cursor='pointer'; if(activeShape)&#123; drawBG(); drawGraph(); resetDrawType(); &#125; canvas.removeEventListener('mousemove',mouseMove,false); canvas.removeEventListener('mouseup',mouseUp,false);&#125;// 删除图形document.body.onkeydown=function(e)&#123; if(e.keyCode==8)&#123; for(var i=0,len=shapes.length;i&lt;len;i++)&#123; if(shapes[i].isInPath(ctx,currPos)&gt;-1)&#123; shapes.splice(i--,1); drawBG(); drawGraph(); break; &#125; &#125; &#125;&#125;;//绘制背景function drawBG()&#123; ctx.clearRect(0,0,W,H); if(getEnv().grid)&#123;DrawGrid(ctx,'lightGray',10,10); &#125;&#125;//网格function drawGuidewires(x,y)&#123; ctx.save(); ctx.strokeStyle='rgba(0,0,230,0.4)'; ctx.lineWidth=0.5; ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,ctx.canvas.height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(ctx.canvas.width,y+0.5); ctx.stroke(); ctx.restore();&#125;//绘制图形列表function drawGraph()&#123; var showControl=getEnv().control; shapes.forEach(shape=&gt;&#123; shape.draw(ctx); if(showControl)&#123; shape.drawController(ctx); &#125; &#125;);&#125; 最后功能全部完成，当然里面有很多的细节，可以查看源代码，这里有待进一步完善的是修改功能，比如调整边框宽度，改变边框颜色和填充颜色。 还有就是本人是在mac平台的chrome下玩canvas，因此不保证其他对es6，canvas的支持度差的浏览器会出现的问题。","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"canvas绘制太阳系","date":"2017-10-26T11:27:38.000Z","path":"2017/10/26/solar/","text":"学习canvas有一段时间了，顺便写个小项目练手，该项目用到的知识点包括： ES6面向对象 基本的三角函数 canvas部分有：坐标变换，渐变，混合模式，线条和图形的绘制。 实际效果: solar system(推荐在chrome或safari下运行) 场景首先建立场景类，主要用来组织管理对象，统一更新和绘制对象。这里用到了ES6的类语法，构造函数建立对象列表属性planets，绘制背景方法drawBG，使用requestAnimationFrame反复执行的动画方法animate 绘制背景使用到了径向渐变：createRadialGradient(x1,y1,r1,x2,y2,r2); 该渐变主要用于创建两个圆相交过渡效果，如果前后两个圆心相同(x1==x2 &amp;&amp; y1==y2)，则会构造同心圆样式的渐变。 这样我们就以太阳为中心的黄色调渐变到黑色，最后用fillRect填充整个背景。 //场景class Stage &#123; constructor()&#123; this.planets=[]; &#125; init(ctx)&#123; ctx.translate(W/2,H/2);//坐标重置为中间 this.animate(ctx); &#125; //绘制背景 drawBG(ctx)&#123; ctx.save(); ctx.globalCompositeOperation = \"source-over\"; var gradient=ctx.createRadialGradient(0,0,0,0,0,600); gradient.addColorStop(0,'rgba(3,12,13,0.1)'); gradient.addColorStop(1,'rgba(0,0,0,1'); ctx.fillStyle=gradient; // ctx.fillStyle='rgba(0,0,0,0.9)'; ctx.fillRect(-W/2,-H/2,W,H); ctx.restore(); &#125; //执行动画 animate(ctx)&#123; var that=this, startTime=new Date(); (function run()&#123; that.drawBG(ctx); that.planets.forEach(item=&gt;&#123; item.update(startTime); item.draw(ctx); &#125;); requestAnimationFrame(run); &#125;()); &#125;&#125; 星球然后建立星球基类，除构造函数，还有更新位置角度的方法Update，对象绘制方法draw。之后所有的星球，都会初始化该类或者继承该类建立对应星球。 行星绕太阳做圆周运动，这个可以用三角函数根据角度和半径求出x,y，但还有更加方便的方法，那就是使用canvas提供的坐标旋转方法rotate，以360度为一个周期。 /** * 星球基类 */class Planet&#123; /** * @param &#123;Number&#125; x x坐标 * @param &#123;Number&#125; y y坐标 * @param &#123;Number&#125; r 半径 * @param &#123;Number&#125; duration 周期(秒) * @param &#123;Object&#125; fillStyle * @param &#123;Object&#125; blurStyle */ constructor(x,y,r,duration,fillStyle,blurStyle)&#123; this.x=x; this.y=y; this.r=r; this.duration=duration; this.angle=0; this.fillStyle=fillStyle; this.blurStyle=blurStyle; &#125; update(startTime)&#123; this.angle=Tween.linear(new Date()-startTime,0,Math.PI*2,this.duration*1000); &#125; draw(ctx)&#123; ctx.save(); ctx.rotate(this.angle); // ctx.translate(this.x,this.y); drawCircle(this.x,this.blurStyle.color); ctx.beginPath(); // ctx.globalCompositeOperation = \"lighter\"; ctx.fillStyle=this.fillStyle; ctx.shadowColor=this.blurStyle.color; ctx.shadowBlur=this.blurStyle.blur; // ctx.arc(0,0,this.r,Math.PI*2,false); ctx.arc(this.x,this.y,this.r,0,Math.PI*2,false); ctx.fill(); ctx.restore(); &#125;&#125;; 太阳开始建立第一个对象-太阳，继承上面的星球基类Planet，重写draw方法 /** * 太阳 */class Sun extends Planet&#123; draw(ctx)&#123; ctx.save(); ctx.beginPath(); ctx.globalCompositeOperation = \"source-over\"; ctx.fillStyle=this.fillStyle; ctx.shadowColor=this.blurStyle.color; ctx.shadowBlur=this.blurStyle.blur; ctx.arc(this.x,this.y,this.r,0,Math.PI*2,false); ctx.fill(); ctx.restore(); &#125;&#125; 土星土星有美丽的土星环，所以也继承出一个单独的类，重写draw方法，其中土星环比较麻烦，建立了很多颜色节点的径向渐变。 /** * 土星 */class Saturn extends Planet&#123; draw(ctx)&#123; ctx.save(); ctx.rotate(this.angle); drawCircle(this.x,this.blurStyle.color); ctx.beginPath(); ctx.fillStyle=this.fillStyle; ctx.arc(this.x,this.y,this.r,Math.PI*2,false); ctx.fill(); //土星光环 ctx.globalCompositeOperation = \"source-over\"; var gradient=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.r+25); var startStop=(this.r+3)/(this.r+24); gradient.addColorStop(startStop,'#282421'); gradient.addColorStop(startStop+0.06,'#282421'); gradient.addColorStop(startStop+0.1,'#7e7966'); gradient.addColorStop(startStop+0.18,'#706756'); gradient.addColorStop(startStop+0.24,'#7e7966'); gradient.addColorStop(startStop+0.25,'#282421'); gradient.addColorStop(startStop+0.26,'#282421'); gradient.addColorStop(startStop+0.27,'#807766'); gradient.addColorStop(1,'#595345'); ctx.fillStyle=gradient; ctx.beginPath(); ctx.arc(this.x,this.y,this.r+24,0,Math.PI*2,true); ctx.arc(this.x,this.y,this.r+3,0,Math.PI*2,false); ctx.fill(); ctx.restore(); &#125;&#125; 建立星球接着开始初始化星球对象，包括太阳和八大行星，然后所有的星球颜色都使用了径向渐变，这样更加的美观。这里给出太阳，水星，土星的例子，其他的行星如此类推。 // 初始化场景类var stage=new Stage();// sunvar sunStyle=ctx.createRadialGradient(0,0,0,0,0,60);sunStyle.addColorStop(0,'white');sunStyle.addColorStop(0.5,'white');sunStyle.addColorStop(0.8,'#ffca1e');sunStyle.addColorStop(1,'#b4421d');var sun=new Sun(0,0,60,0,sunStyle,&#123;color:'#b4421d',blur:300&#125;);stage.planets.push(sun);// mercuryvar mercuryStyle=ctx.createRadialGradient(100,0,0,100,0,9);mercuryStyle.addColorStop(0,'#75705a');mercuryStyle.addColorStop(1,'#464646');var mercury=new Planet(100,0,9,8.77,mercuryStyle,&#123;color:'#464646'&#125;);stage.planets.push(mercury);//saturn var saturnStyle=ctx.createRadialGradient(500,0,0,500,0,26);saturnStyle.addColorStop(0,'#f2e558');saturnStyle.addColorStop(1,'#4c4a3b');var saturn =new Saturn(500,0,26,1075.995,saturnStyle,&#123;color:'#4c4a3b'&#125;);stage.planets.push(saturn); 小行星带当然还有火星和木星之间的小行星带，同理继承星球基类，这里用到了图像混合模式globalCompositeOperation，使用xor可以和背景对比度没那么突兀。当然还有其他属性值，比如source-over, lighter等。这里我们随机生成了300个对象，一样填充进场景类的planets属性统一更新绘制。 /** * 小行星 */class Asteroid extends Planet&#123; draw(ctx)&#123; ctx.save(); ctx.rotate(this.angle); ctx.beginPath(); ctx.globalCompositeOperation = \"xor\"; ctx.fillStyle=this.fillStyle; ctx.arc(this.x,this.y,this.r,0,Math.PI*2,false); ctx.fill(); ctx.restore(); &#125;&#125;function createAsteroids()&#123; var asteroid=null, x=300,y=0, r=2,rd=300, angle=0, d=283, color='#fff'; for(var i=0;i&lt;400;i++)&#123; rd=Random(300,320); angle=Random(0,Math.PI*2*1000)/1000; x=Math.round(Math.cos(angle)*rd); y=Math.round(Math.sin(angle)*rd); r=Random(1,3); d=Random(28.3,511); color=getAsteroidColor(); // console.log(angle,color); asteroid = new Asteroid(x,y,r,d,color,&#123;color:color,blur:1&#125;); stage.planets.push(asteroid); &#125;&#125; 彗星基本快完成了，但我们除此之外，可以再添加做椭圆运动的彗星，这样更加酷。一样随机生成20个彗星填充进场景类统一更新绘制。 /** * 彗星 */class Comet &#123; constructor(cx,cy,a,b,r,angle,color,duration)&#123; this.a=a; this.b=b; this.r=r; this.cx=cx; this.cy=cy; this.x=0; this.y=0; this.color=color; this.angle=angle; this.duration=duration; &#125; update(startTime)&#123; var t=Tween.linear(new Date()-startTime,0,Math.PI*2,this.duration*1000); this.x=this.cx+this.a*Math.cos(this.angle+t); this.y=this.cy+this.b*Math.sin(this.angle+t); &#125; draw()&#123; ctx.save(); ctx.rotate(this.angle); //画运动轨迹 ctx.lineWidth=0.5; ctx.strokeStyle='rgba(15,69,116,0.2)'; Shape.ellipse(ctx,this.cx,this.cy,this.a,this.b); //画球 ctx.beginPath(); // ctx.globalCompositeOperation = \"lighter\"; ctx.globalCompositeOperation = \"source-atop\"; ctx.shadowColor=this.color; ctx.shadowBlur=1; ctx.fillStyle=this.color; ctx.arc(this.x,this.y,this.r,0,Math.PI*2,false); ctx.fill(); //画尾迹 ctx.restore(); &#125;&#125;function createComets()&#123; var l=180, a=800,b=300, cx=a-l,cy=0, r=3,duration=30,angle=0,color='#fff', comet = null; for(var i=0;i&lt;20;i++)&#123; l=Random(120,350) a=Random(600,1000); b=a/Random(1,3); cx=a-l; r=Random(2,4); angle=Random(0,Math.PI*2*1000)/1000; color=getCometColor(); duration=Random(20,100); stage.planets.push(new Comet(cx,cy,a,b,r,angle,color,duration)); &#125;&#125; 运动轨迹最后的细节，就是标识出行星圆周运动的轨道，当然最简单的是按运动半径画个圆。但我们用线性渐变添加好看的尾迹，这样效果更好 function drawCircle(r,color)&#123; var hsl=Color.hexToHsl(color); ctx.lineWidth=1; // ctx.strokeStyle='rgba(176,184,203,0.3)'; // ctx.arc(0,0,this.x,Math.PI*2,false); // ctx.stroke(); var gradient=ctx.createLinearGradient(-r,0,r,0); gradient.addColorStop(0,'hsla('+hsl[0]+','+hsl[1]+'%,0%,.3)'); gradient.addColorStop(0.6,'hsla('+hsl[0]+','+hsl[1]+'%,50%,.9)'); gradient.addColorStop(1,'hsla('+hsl[0]+','+hsl[1]+'%,80%,1)'); ctx.strokeStyle=gradient; // ctx.shadowColor=color; // ctx.shadowBlur=4; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI,true); ctx.stroke();&#125; 最后所有的部分都已经完成，我们只需要启动场景类即可 createAsteroids();createComets();stage.init(ctx);","tags":[{"name":"前端","slug":"前端","permalink":"https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"https://edwardzhong.github.io/tags/js/"},{"name":"canvas","slug":"canvas","permalink":"https://edwardzhong.github.io/tags/canvas/"}]},{"title":"喜马拉雅之旅（尼泊尔EBC篇）","date":"2017-04-15T15:16:32.000Z","path":"2017/04/15/ebc/","text":"&emsp;&emsp;在喜马拉雅，我们过着修行般简单而自律的生活。整个徒步过程中，喜马拉雅南坡以其所特有的高落差，带来的跨越四季的气候、动植物分布的多样性，以及从河谷到山巅的震撼风景固然给我带来不少视觉上的冲击，但印象更深刻的，是在路上遇见的人，人与动物、自然和睦相处，这才是旅途中最美丽的风景。 &emsp;&emsp;尽管刚刚走完ABC，但EBC无疑远胜于ABC，它仍带给我一阵阵惊叹和无与伦比的震撼。在触手可及的距离内，庞大的山体，纤毫毕现的细节，给人雷霆万钧的压迫感，大自然的宏大，把人的脆弱和渺小衬托到了极致。 &emsp;&emsp;在16天的行程中，跨过一座座的吊桥，穿过一条条山谷，翻过一个个垭口，看过一个个湖泊，走了很长很长的路，看过很美很美的风景。一路上从各个角度欣赏十几座世界级的山峰，美景真是应接不暇。EBC是如此的震撼，景色是如此之美，同时环境又是如此恶劣，在高海拔下，顶着严酷的低温，高强度的紫外线，高强度的徒步，这是一段天堂地狱般的征程。 &emsp;&emsp;EBC就是围绕世界最高峰所建立起来的，珠峰在国际上通称为”Everest”; 我们称之为珠穆朗玛峰，藏语意为”第三女神”; 而尼泊尔则称为萨加玛塔峰，意为”天空之女神”。所以EBC所在的国家公园又称为萨加玛塔国家公园。 &emsp;&emsp;EBC相比ABC线路要复杂得多，海拔更高，条件更加艰苦，大部分海拔基本都在4000米以上，甚至相当一部分在海拔5000米以上，这对徒步者是严峻的考验。因此徒步者应该从低海拔开始逐步适应，慢慢爬升，这样让身体机能慢慢适应高海拔，切忌直接飞到5000多米的海拔。(Namche去Tenboche的路上) (Tenboche看日落金山) (Chhunkhung) (Gorak Shep) (Kala Patharr观看珠峰日落) (Gokyo) 行程路线这是总的行程，本游记是加德满都，ebc部分。穷游行程助手下的详细行程单西藏部分请看： 喜马拉雅之旅（西藏篇）ABC部分请看： 喜马拉雅之旅（尼泊尔ABC篇）ACT部分请看： 重返喜马拉雅之ACT篇 基于Google earth做的路线图 &emsp;&emsp;红色线为主要的徒步路线; 绿色线为翻越垭口的路线; 红色框为重要的地标; 蓝色为重要景点，在住宿点安顿好可以轻装徒步过去。 &emsp;&emsp;从地图可以很清楚的看到，从Lukla一直走到Namche Bazar就是前期的低海拔休闲路线，从Namche往后海拔越来越高，同时依次开始分出4条冰川洗刷出来的山谷，每条沟之间都有垭口翻越路线，可以节省时间，但同时也比较艰苦和危险。强驴可以走三垭口连穿的大环线，但时间有限的大部分人，基本走EBC大本营的主线，然后原路回撤，一个星期就可以走完；如果时间充足可以去Gokyo(强烈推荐)，Gokyo Ri观景台可以媲美Kala Patharr, 如果冬天来Gokyo第三湖真的美哭了；还有Chhunkhung线也还是不错的，是冰河最多的一条沟，而且可以近距离看洛子峰南坡。 &emsp;&emsp;我们这次把主要的线路都走完了，除了左边第一条沟没去，其他沟都有去；EBC主线，Chhukhung线，Gokyo线，穿越了最危险的Chola Pass垭口。 日程安排 时间 交通 地点 景点 住宿 2016/11/28 (Mon) 加德满都 加德满都杜巴广场 sunrise cottage 2016/11/29 (Tue) taxi 加德满都 办理EBC相关证件,到Lukla的机票 sunrise cottage 2016/11/30 (Wed) 飞机 07:30-&gt;08:30,徒步 加德满都-&gt; Lukla-&gt;Phakding 上午赶路，下午休息 民宿 2016/12/01 (Thu) 徒步 Phakding-&gt;Namche bazar 上午赶路，下午补充物质装备 民宿 2016/12/02 (Fri) 徒步 Namche bazar-&gt;Tenboche 上午赶路，下午寺庙祈福，休息 民宿 2016/12/03 (Sat) 徒步 Tenboche 休整一天，逛寺庙，傍晚雪山群的日落金山 民宿 Tenboche guest house 2016/12/04 (Sun) 徒步 Tenboche-&gt;Dingboche 上午赶路，下午Dingboche附近的平台，Lhotse日落金山 民宿 Lucky hotel 2016/12/05 (Mon) 徒步 Dingboche-&gt;Chhukhung 上午赶路，下午IBC，Lhotse日落金山 民宿 2016/12/06 (Tue) 徒步 Chhukhung-&gt;Dingboche 上午Chhukhung Ri看雪山群，Lhotse南坡，下午返回Dingboche 民宿 Hotel Bright Star 2016/12/07 (Wed) 徒步 Dingboche-&gt;Loboche 上午赶路，下午Loboche附近平台，Nuptse日落金山 民宿 2016/12/08 (Thu) 徒步 Loboche-&gt;Gorak Shep 上午赶路，下午Kala Patthar看Everest、Nuptse日落金山 民宿 2016/12/09 (Fri) 徒步 Gorak Shep 上午休息，下午EBC，昆布冰川，Nuptse日落金山 民宿 2016/12/10 (Sat) 徒步 Gorak Shep-&gt;Dzonglha 上午赶路，下午休息 民宿 2016/12/11 (Sun) 徒步 Dzonglha-&gt;gokyo 整天赶路，穿越Chola pass，Ngozumba冰川 民宿 2016/12/12 (Mon) 徒步 gokyo 上午第三湖，下午Gokyo Ri看雪山群的日落金山 民宿 2016/12/13 (Tue) 徒步 gokyo 赶路一天看第四、第五、第六湖 民宿 2016/12/14 (Wed) 徒步 gokyo-&gt;Phortse Thanga 整天赶路 民宿 2016/12/15 (Thu) 徒步 Phortse Thanga-&gt;Lukla 整天赶路 民宿 2016/12/16 (Fri) 飞机 11:00-&gt;12:00 Lukla-&gt;加德满都 gilingche tibet restaurant sunrise cottage 2016/12/17 (Sat) 加德满都 帕坦博物馆，杜巴广场，黄金庙 sunrise cottage 2016/12/18 (Sun) 加德满都 fire and ice pizza sunrise cottage 2016/12/19 (Mon) 飞机 16:30-&gt;21:30 加德满都-&gt;昆明 休息 机场 2016/12/20 (Tue) 飞机 09:00-&gt;10:00 昆明-&gt;成都 休息 梦之旅国际青旅 2016/12/21 (Wed) 成都 都江堰，宽窄巷子 梦之旅国际青旅 2016/12/22 (Thu) 成都 武侯祠，锦里 梦之旅国际青旅 2016/12/23 (Fri) 飞机 11:50-&gt;14:30 成都-&gt;深圳 回家 徒步准备&emsp;&emsp;此次EBC的行程，就我和zy两个人，我们都有徒步经验，zy还是专业领队，有高大上的专业gps，加上我们对ebc的路线也计划了好久，所以都决定自己负重徒步，不用背夫向导。参考了很多前人的攻略，我觉得自己负重，就算不请向导和背夫，在身体和装备上做好充分准备，只要不作死，总体来说ebc风险还是可控的。在此之前，我都是天天晚上跑步，过星期爬山，身体上状态不错。但要在5000多米的海拔负重徒步，心里还是没底的，于是一再的轻量化背包，三脚架、插座和一些杂七杂八的都不带了，寄存在加都的hotel，最后我的包也就30斤左右。 &emsp;&emsp;当然应急的药品也是要准备的，各种药品，防感冒的，防拉肚子的，防喉咙痛的，防高反的，还有维生素片。在拉萨买了几百rmb的应急高反的药，结果一直没派上用场，原封不动的背回来了，看来我还是挺扛得住高海拔的😂。尼泊尔的食物还是比较放心的，但是很多国人不适应，但我还好，什么都能吃饱，但zy就不行了，比较挑，经常吃不进去，所以挑食的人老干妈，榨菜之类的可以带。这边的食物基本都是煎烤炸之类的，加上山上非常干燥，冷空气吸多了，还容易咳嗽感冒，加上我容易上火，所以喉咙痛和防感冒的药一定要带啊。维生素也要带一些，毕竟山上很难吃到水果和新鲜蔬菜。 &emsp;&emsp;保险方面买的是美亚的万国游踪户外险，包含直升机救援的，15天也才几百rmb，听说安联的户外险也很不错。万一在山上顶不住了，没有保险，直接叫直升机那是要花好几千美金的。 &emsp;&emsp;至于装备方面，双登山杖，冲锋衣裤，速干衣裤，羽绒服，睡袋，手套，厚袜子，魔术头巾，遮阳帽，抓绒帽，保温瓶，充电宝。这里早晚真是刺骨的寒冷，相比平原，就算是同样的温度，高海拔的山上冷了不止一个数量级，所以保暖的帽子和手套必备。因为天天徒步，脚流汗，袜子尽量多带几双，那种长筒的厚袜子，保暖同时徒步也比较舒服。衣服的话，把最保暖的带过来，最好有羽绒服，又保暖又轻。睡袋可以带，毕竟山里面有些地方住宿的床铺比较脏。 &emsp;&emsp;保温瓶也是必须的，喝暖水安全也舒服，还预防高反。山上充电和wifi都要钱，你在上面充电的钱都够买几个充电宝了，所以尽量多带几个上去。有点可惜的是没有买便携式太阳能电池板，要不然会省好多钱，我们在ebc遇到的小伙伴就带了，真的好方便，徒步的时候挂在背包后面，可以一边走一边充。 &emsp;&emsp;至于拍摄方面的，带了单反确实比较重，但这么美的风景，为了以后美好的回忆，我还是背上去了。如果带个大广角的镜头会非常给力，在Chhukhung Ri、Gokyo Ri和Kala Patthar面对壮阔的场景，好嫌弃镜头不够广啊。长焦方面的话，100mm焦距以内就可以搞定了，因为EBC的很多雪山都靠的比较近，完全可以走近点再拍。所以不用特意带笨重的长焦镜头，我的15-85镜头能轻松应付抓拍雪山细节的场景。最可惜的就是没有拍星空照，为了减负，我们都把脚架寄存加都了，晚上又太冷，根本不想出去。 &emsp;&emsp;还有山上，尽量少洗澡，容易感冒，感冒后很大可能会高反，尤其是海拔4000米之后。这边空气这么干燥，十几天不洗澡不是什么不可思议的事情，来ebc徒步的人几乎个个都是十几天不洗澡的，等回到比较低海拔的namche之后再洗不迟。 EBC相关的证件TIMS：Trekker Information Manerger System，徒步者信息管理系统，花费2000rs；萨加玛塔国家公园门票：花费4000rs。 办理这两个证件还是很方便的，既可以在加都的Nepal tourism board办理，也可以到了萨加玛塔国家公园（EBC）再办理，我们一开始不清楚，提前在加都办完了才坐飞机过来。 11/28 加德满都&emsp;&emsp;话说昨晚加都发生了5.1级的地震，但我睡得很爽很舒服，完全没啥感觉。早上到9点多醒来，然后一直玩iPad到11点多才起床，然后去加都一号准备兑换尼币，但老板还在睡觉，必须等到下午两点才上班。 &emsp;&emsp;加都一号附近的小店能买到很多中国的食物零食之类的，老干妈，榨菜，泡面，加多宝都有。恰好我上火舌头痛，顺便买了两罐加多宝，终于有凉茶治疗了。这几天只能吃清淡的，不能和他们重口味的一起吃，必须EBC之前治好我的上火。中午还是到那家叫齐鲁聚鑫源的中餐馆吃，点了个牛肉面，做得不错。 &emsp;&emsp;下午送衣服去干洗店，顺便兑换尼币，先去圆梦hotel兑，又是老板不在，没办法只能到加都一号兑了，汇率是16.7。比我们一周前凤凰宾馆兑的16.3的汇率好多了。兑了超多的尼币，拿着一大沓的钱，感觉瞬间变土豪。下午还有空，顺便去杜巴广场附近转转，各种脏乱差，加都就是个大号的城中村。而且杜巴广场很多建筑自从地震之后还在修复中，真的没啥好看的，进皇宫的门票还要1000rs，这么坑，果断放弃游览的念头。 杜巴广场附近的寺庙和佛塔 **某个小区里面的佛塔** 11/29 加德满都&emsp;&emsp;今天早上赶紧订机票先，我们就在hotel附近的一家旅行社订的，加都到Lukla的双程机票，折合2000RMB，比网上订的要便宜点，但还是好贵啊。然后就帮zy办理相关证件，因为他几乎不会英语，也是醉了。打taxi先到Nepal tourism board办理EBC相关证件，然后再到immigration office续签visa，然后再返回泰米尔区，共花了800rs。 &emsp;&emsp;中午回来后又在齐鲁吃饭，下午没事做上网，提前跟房东结了房费，然后跟房东预定订了明天去domestic airport 的taxi。上网也挺无聊的，于是又出去乱转，这次是从住宿的东边开始逛，然后再往南绕到杜巴广场，再回到住宿的地方，回来的路上顺便把干洗完的衣服拿回来，收拾东西，准备明天出发卢卡拉。好像叫玛哈德喜瓦神庙 **加德辛布佛塔** 在加都居民区到处都有寺庙佛塔，这个佛塔也是无意中在某个街区逛到的，外观非常像苏瓦扬布佛塔。 大街中间也有很多不知名的佛塔 11/30 加德满都 -&gt; Lukla -&gt; Phakding&emsp;&emsp;早上6点起床，收拾好东西，把一部分行李寄存在hotel，然后坐hotel提供的taxi出发。我们订的是tara air的航班，7点45起飞，一个小时不到就可以到lukla，所以决定到lukla再吃早餐。 &emsp;&emsp;尼泊尔国内的航班在domestic airport，在国际机场旁边。这里的安检和登机的手续太简单了，这种小飞机是人工到站提醒的，显示牌完全没有提示，搞得一开始找了好久。等到7点半的时候，终于可以出发了，坐接驳车去登机坪，终于看到我们的小飞机了，飞机真的好小，只能坐10几个人的螺旋桨小飞机。为了欣赏喜马拉雅山，去lukla的飞机要坐左边，回来就坐右边。我第一个验登机牌，然后也第一个登机，虽然坐到了左边第一个位，但是就在螺旋桨旁，而且窗子很脏，很影响拍照。 &emsp;&emsp;在螺旋桨的轰鸣声中，飞机离开加都，冲进了雄伟的喜玛拉雅山脉中。8点多的时候已经看不到日出了，但是恢宏的山脉，云雾缭绕，险峻的山峰刺破云霄，景色非常壮观。最后是在tenzing Hillary airport降落，估计大家都知道这个全球最危险的机场，这里几乎每年都会发生事故。不过这个季节气候干燥，气流稳定，安全度还是很高的，我们今天的航班简直太平稳了✌️。 &emsp;&emsp;半个小时就到lukla了，但找行李好折腾，我们不知道在哪个地方取行李，费了好大周折才知道就在机场边自己去取的，😭。这个就是我们坐的飞机了，我们刚下飞机，回加都的人就开始准备登机了。 &emsp;&emsp;Lukla就位于山谷中间的台地，东西北三面都是高耸的雪山，北面正对着“坤布之神”贡比拉山（Khumbila）。Tenzing Hilary机场是全球最危险的机场之一，它以平均每年都发生坠机事故而闻名，而元凶就是喜马拉雅山区恶劣多变的气候，尤其是每年的雨季。尽管如此，全世界的驴友和登山家们还是络绎不绝来到昆布山区徒步探险。 背着行李就在机场附近找了一家餐厅吃早餐，550rs，好贵，还是在加都吃划算啊。吃完早餐，顺便在机场旁边逛一下，看飞机起降，因为今天行程非常轻松。 我们9点多开始向Phakding进发，今天行程很轻松，海拔也就2000多，路也好走，于是非常悠闲的一边走一边拍照。一路上都是蓝天白云，田园风光。 在lukla检查点检查完证件之后，就从这个大门进去，算是进入萨加玛塔国家公园了，EBC徒步开始了😄。 这个地方同时也可以办理TIMS。 途中经过的这个地方很多转经筒，画着符文的石块和佛塔，这上面写着说转一转就可以 get rid of sin，哈哈。 &emsp;&emsp;大约12点半就到Phakding，找了家看起来还行的hotel住下，双人间400rs，但是午餐的Dal Bhat分量好少，而且只能加饭，不能加菜，这啥世道啊。下午就休息了，我就在附近乱转，发现还有很多比较nice的hotel，有点后悔选了之前那家。回去后无聊，加上充电和wifi都要钱，也只能回房盖着被子看书，看地图计划我们的行程。看着看着不知不觉就睡着了，一觉睡到5点，呆到6点的时候，hotel的伙计敲门催我们点晚饭。 &emsp;&emsp;我点的是鸡蛋春卷，这边的春卷好大只啊，但做得不错，zy要了份鸡扒，也还行。大厅里竟然放的是成龙很早以前的电影，真没意思，但夏尔巴人看的津津有味。整个大厅10多个欧美的，就只有我们两个中国人，吃完晚餐，消化了下，然后订好明天的早餐，回房继续看书休息。明天的目标是namche，看攻略上说也是比较轻松的。 12/01 Phakding -&gt; Namche bazar&emsp;&emsp;今天7点多起床，吃完早餐马上出发，沿着河谷走，河水好清澈，颜色都是绿色的，前面一段还是比较轻松的。 这个地方是检查门票的，没有门票的在这里办理 &emsp;&emsp;走着走着，Thamserku雪山就映入眼帘了，从山谷往上看，太惊艳和挺拔了。尼泊尔山区徒步是从海拔1000-2000米直到到海拔5000米，山地垂直气候带造成植被和景观层次非常丰富，景色多姿多彩，既能看到秀丽的河谷也能看壮阔的冰川。 牛掰的夏尔巴背夫 这个就是在很多电影场景中出现的双层吊桥，其中下面那个吊桥已经废弃了。从吊桥这里开始要一直往上爬很长的陡坡，翻过这个山到namche用了两个多小时，累死了。 &emsp;&emsp;中午12点半才到达目的地Namche bazar。我为了找到的是能看到对面Kongde Ri雪山的hotel，背着累人的大包一路往上走，最后找了一家还不错的，订了200rs的双人间。因为是淡季，旅客很少，每间hotel都很多空房，所以比较便宜。 &emsp;&emsp;Namche Bazar是EBC里面最大最繁华的镇子，hotel和resturant太多了，酒吧，咖啡馆也有，里面还有很多店铺，在这里可以最后一次补充物资和装备。再往山上走条件越来越艰苦，价格也会越来越贵，在这里可以洗最后一次澡，设备都充满电，休整好，之后就要挑战越来越艰苦的行程。 &emsp;&emsp;当然从这里还可以往上爬1个多小时到达小镇Khumjung，途中会经过日本人的星级酒店Everest View，Khumjung景色更棒，能远眺珠峰在内的峰群。里面也有小一点的市场补充物资，我当时不清楚路线所以没去，我们回程特意路过Khumjung。 &emsp;&emsp;我还要在村口去接zy，他走得比较慢，然后英语也不好，我手机又没电了，一直联系不上，等我联系上他时，他已经找了另外一家hotel在休整了，也好，我本来也挺累的了。午餐点了份牛扒，吃完后去市场买雪套，冰爪之类的。买完雪套冰爪后，觉得往后充电麻烦而且太贵，顺便再买一个充电宝，同时要求店主充满电给我，六点过去拿。采购完装备，返回住宿的hotel，写日志，整理行李，清点money，总共还有73300rs，按15天算，每天可以花费4800多，非常奢侈。其实每天花费2000-3000rs基本就够了，多余的到时回加都兑回来好了。 12/02 Namche Bazar -&gt; TengbocheEBC第三天，Namche到Tengboche。6点多起来看完Kongde Ri雪山的日照金山，然后吃早餐，7点多一个人出发。Kongde Ri日照金山 &emsp;&emsp;当转过第一个山脊的时候，我瞬间被震慑了😱，空无一人的山谷，蓝色的云雾，山谷尽头就是世界上最高的群峰。Everest，Ama Dablam，Lhotse，Nuptse，还有几个我叫不上名字的山峰。这是EBC给我的第一次震撼瞬间，当时呆呆的看着云雾变白。接下来的行程就是不断的向Everest的方向靠近，直到山脚下的大本营。世界级的群峰 &emsp;&emsp;从今天开始，EBC的壮美景色让人目不暇接，我觉得这一段海拔4000米左右的风景是最优美的，既有青山绿水，也能看到雪山冰川，非常多姿多彩。而往后的风景都是4000米以上，基本只能看到空旷裸露的山体，冰川和雪山，那是另一种雄壮苍凉的美。 &emsp;&emsp;前方最远处的是MT. Everest，距离我们最近的雪山就是右边的Ama dablam，海拔6856米，形状非常优美。 这中间有个老头摆了个捐款箱，EBC很多路都是他出资免费修理的，我把几百的的零钱都捐了，来EBC的小伙伴们看着办吧。 就算是垃圾桶也能拍出很好的效果😂 一边喝着咖啡和茶，一边欣赏美景，这样的生活夫复何求啊！ &emsp;&emsp;后半程先是下坡跨过河谷，然后再向上爬，这一下一上落差都有300米以上了吧，非常的累😝，一路上不知停下来休息多少回了。中间遇到个自己负重的西班牙大叔，特意告诉我要这么走:”slow and don’t stop”,按他的方式走，果然有效啊，而厉害的大叔一下就把我甩在后头了。 &emsp;&emsp;快到Tenboche的时候，遇到个留长发的欧美小伙，他从EBC下撤回来，向他问距离Tenboche还有多久。 &emsp;&emsp;最后终于到达Tengboche了，我住的是最里面的Tenboche guest house，订的单人间，因为zy今天还在Namche休整，我今天在这里等他；还有西班牙大叔也住这里哦，和他一边聊天，一边吃dal bhat，我虎吞狼咽的吃完美味的午餐。这家民宿虽然住宿比较简陋，但食物做得很美味，在EBC期间吃得最满意的。 隔着云层的雪山够震撼 &emsp;&emsp;然后回房休息，3点多的时候，太阳出来了，于是出来看雪山，可惜还是很多云雾，不然超级壮观。和西班牙大叔聊了下天，才知道他10年前就已经来过EBC了，他还告诉我前面几个山峰的名称。然后和来自苏格兰的一对情侣到附近的藏传佛教寺庙逛。我们一群人包括夏尔巴背夫和向导20人左右一起进寺庙大厅听祝福祷告，要脱鞋才能进去，不穿鞋里面好冷啊，20分钟后出来，然后就在附近乱转了下。 &emsp;&emsp;回到住宿地方看书，然后又回房躺，直到5点多，房东叫订晚餐。原来大厅里面有烤火取暖，赶紧进去烤火，我点了份chowmein，类似意大利面，很好吃。吃完晚餐，一边烤火，听他们几个老外聊天，除西班牙大叔和苏格兰情侣外，还有个尼泊尔小伙，西班牙大叔和尼泊尔小伙聊了很多比较深入问题，经济，政治，人生，我英语水平有限，插不上嘴啊，最后7点多才回房休息。 12/03 Tenboche&emsp;&emsp;EBC第四天，今天在Tengboche休整，等待zy过来会合。我一个人6点多爬起来看日出，但是珠峰群峰就在Tenboche的东北面，所以几乎是看不到日出的，但却非常适合看日落。但往西南方向看过去，可以看kongde Ri的日出。峰群终于露出了真容，依次是努子峰(Nuptse)，珠峰(Everest)，洛子峰(Lhotse)，其中中间的巨大岩壁就是连成一片的努子峰和洛子峰，最右边最近的是AmaDablam，其中珠峰在努子峰后面，只露出一点点的峰顶。 Kongde Ri的日出 Kangtega(鞍之雪山) &emsp;&emsp;看完日出后准备刷牙洗脸时，发现水都被冻住了，只能叫房东冲温水才行。今天我们hotel所有客人都向Dingboche进发了，跟他们告别后，开始吃早餐，然后就到处乱转拍照，拍完回来整理行李，晒袜子，鞋子，剪指甲，刮胡子，然后晒太阳，看书。 俊俏的AmaDablam &emsp;&emsp;中午的时候我在外面晒太阳吃午餐，这时候来了个西班牙帅哥John，也是个自己负重的背包客，非常健谈，很有意思，全世界到处徒步爬山，他游遍南美，还爬过安第斯山，他特别喜欢说“ok”,“all right” 😂，他还是个佛教徒呢。遇到过的几个西班牙人都是那种特热情，特能聊，特别会享受生活的人，西班牙人给我留下的印象很好。一会儿，zy也赶过来了，他下午主要去寺庙逛，我下午大部分时间在晒太阳。然后来了个像华裔的人，我就问是Chinese吗？他直接答Taiwanese，我cao，尴尬! 好几个在尼泊尔的朋友都有遇到这种情况,大部分台湾人都是不认同中国的。 John在晒鞋袜 午餐不错 带着帽子，对着雪山，晒太阳😂 &emsp;&emsp;三四点的时候，我又开始到处逛拍照，开始爬前面的一座山，哎哟，原来山上角度这么好。又碰到John，还有个澳洲帅哥Jimmy，然后一起爬到半山的一处小平台，欣赏雪山美景。因为Tenboche就在群山中间，后面的Kangtega雪山挡住了太阳，所以4点过的时候Tenboche就开始天黑，我们只能回住宿的hotel。 越往上爬越陡 从半山腰向四周看 刚下山日落就开始了，壮观的日落金山，伴随着寺庙的钟声，当时心情只能用快乐激动来形容，我和John不断的赞叹着难得一见的美景。 挂着旗云的分别是珠峰和世界第四峰Lhotse（洛子峰），同时南边天空也出现了绮丽的彩霞。 &emsp;&emsp;回到hotel等晚餐吃，hotel又来了一个澳洲老奶奶Susan，还有个新加坡妹子，她们都有背夫，加上John，一起聊天。其中新加坡妹子聊到我们刚从西藏过来，竟然问我们是怎么办理到去西藏的visa的。我擦，西藏是中国的一部分，中国公民想去就去啊，还真以为西藏是独立的，😤。Susan推荐了一个不错的景点Amadablame base camp，所以我们明天准备去ABC转一下，反正时间充裕。吃完晚饭，他们几个开始聊佛教相关的话题。而我消化了一下晚餐，然后出去看星空，真的是星汉灿烂。但太冷了，我只能回房休息，写日志，睡觉。晚上11点又起来上厕所，顺便又出来看星空，满天星斗，肉眼都能看到银河啊。 12/04 Tenboche -&gt; Dingboche&emsp;&emsp;EBC第五天，今天要终于离开Tenboche，向Dingboche进发，4个小时的路程。走到一半，我的右肩开始酸痛，好痛苦，这个是包没有打好导致的，好在今天路程比较短。还有我们本来打算去Amadablame base camp，昨天susan强烈推荐。很不幸的是，因为是旅游淡季，今天ABC里面的hotel关闭了，所以只能略过这个点了，不过这个路线在我们的计划之外，没啥好遗憾的。早上晒不到太阳的时候，好冷，尤其是手指头，中午出太阳的时候又太热了，这时候好多欧美小伙都只穿着T恤短裤啊！ **途中经过Panboche** &emsp;&emsp;途中经过Panboche，Panboche就在Amadablam雪山下面，从这里可以去Amadablam Base Camp，继续向着Lhotse的方向前进。 今天路程也不是很赶，于是叫zy帮我拍了几张重装徒步照。 &emsp;&emsp;到达Dingboche后，找了家很多客人住的叫lucky的hotel，午餐吃了份dal bhat，难吃。这个店什么都贵，而且食物也不好。 &emsp;&emsp;Dingboche位于Gorak shep和Chhukhung两条线路的连接点上，所以规模很大，应该是仅次于Namche了，旅馆也是特别多。这里海拔已经是4000米以上了，周围基本都是一片荒芜，再也看不到绿色了。 &emsp;&emsp;今天运动量不大，还有一整个下午可供我们消遣，就想到附近去逛逛。我们于是爬Dingboche附近的山坡，上面有平台，平台上还有佛塔，风景也非常壮观，南边正对着Amadablame的北坡，东边是Nuptse和Lhotse连成一线的的巨大冰雪岩壁，西南边是Thamserku，西边是像墙一样延伸的Tabuche雪山，Dingboche就坐落在巨大的山谷中间。我们在上面摆拍了各种装逼的姿势，然后等着看日落。 &emsp;&emsp;4点半开始，太阳逐渐落下，开始看努子峰洛子峰的日落金山，到5点的时候，雪峰红到了极致，美爆了。回到hotel点了份stew当晚餐，其实就是各种面和蔬菜的乱炖，吃起来还行。 12/05 Dingboche -&gt; Chhukhung&emsp;&emsp;EBC第六天，从Dingboche出发去Chhukhung，共两个小时的路程。中途经过一个纪念碑，纪念的是攀登Lhotse南坡的遇难者。 &emsp;&emsp;Chhukhung背后就是世界第四高峰-洛子峰(Lhotse)，我觉得这里的风景不输于Gorak shep，只是名气没有另一边的珠峰出名罢了，但非常近的距离观看Nuptse和Lhotse，是整个EBC期间最壮观的日落金山，时间足够的话，真的不要错过这个点。上午11点不到就到达Chhukhung，发现这里好冷清，没几个人，而且店也少，只有两三家hotel。我们选了最近一家，休息了一会，吃中饭，这家做的饭也好难吃。在这里又遇到了澳洲帅哥Jimmy😂。因为从Dingboche开始手机就没有信号了，还在这里买了个200mb的Everest link wifi卡，500rs，有效时间15小时，好贵。我们两天都没上网，贵也忍了。 **雪景房，正对着Ama Dblame冰川** &emsp;&emsp;下午我们出发去Island Peak Base Camp，左边是Nuptse和Lhotse连成一片的山峰，右边是岛峰。 &emsp;&emsp;走了1个多小时已经走到Baruntse和Num Ri雪山的跟前了，已经过了岛峰大本营，景色没有想象的壮观，只是里面有个很深的冰湖，周边有一些夏尔巴人的帐篷，还有一些夏尔巴人正在放牧牦牛。还碰到一种完全不怕人的鸟，估计是当地人不杀生导致的。IBC这里海拔5100多米，我们也总算突破了5000米的大关，身体没有任何不适应。 **洛子峰旗云** &emsp;&emsp;我们在里面拍完装逼照，很快就3点半了，赶紧往回走，一边赶路一边欣赏Lhotse壮观的日落金山，洛子峰顶火山爆发般汹涌澎湃的旗云。这也是此次EBC行程看到的最壮观日落。 &emsp;&emsp;走了三分之二时，zy指了一条我们没有走过的路。这下麻烦大了，因为刚好这时太阳下山了，越来越黑，而且这条是一条绕了很远的路。我们两人分开了，我跟着当地人的牦牛队伍走，但牦牛队是去Dingboche的，他们指了一条错误的路给我。其实那是通向河谷的路，我走着走着发觉不对劲，当时心里好慌，只能往高处走看看有没有其他路，终于找了一条小路，沿着走了一会终于看到了远处的亮光。顺着亮光，再加上微弱的月光，终于回到chhukhung，回来后心情真的久久不能平复，想起来还后怕，如果晚上不能回去，晚上零下十几度的低温，后果可想而知。 12/06 Chhukhung -&gt; Dingboche&emsp;&emsp;EBC第七天，今天接近8点才起床，吃完早餐后接近9点。我们先退房结账，同时把包寄存在hotel，爬完Chhukhung Ri我们还会回来吃午餐，然后下午再回撤到Dingboche。安排好后就轻装出发去Chhukung Ri，也就是我们后面的山，海拔有5550米，最高点海拔超过5800米。我们住宿的地方不过海拔4700多米，落差有1000米，所以难度很大，zy没有爬，他在山脚等我，我一个人往上爬。 爬上Chhukhung后面的坡，回望Chhukhung **Chhukhung Ri就是下图洛子峰左边的土黄的山，从这个角度看，简直可以比肩洛子峰，知道有多高了吧😭** &emsp;&emsp;越往上爬发觉越陡，海拔又高，还不能停下来休息太久，因为越是停下来休息就越累，不休息又喘不过气来，后面就是屏着气往上冲，太疯狂了。但山顶非常震撼，北面是一排世界级的雪山，中间隔着巨大的冰川和冰川洗刷出来的深坑。东北面是世界第四高峰-洛子峰如刀削般的巨大南坡。东面到南面是一直延伸的岛峰，还能看到昨天去过的大本营和里面的冰湖。西面最震撼，那是我们来时走过的巨大深邃的山谷，山谷两边是庞大的雪山，风一刮过，低沉的轰鸣响彻山谷。 &emsp;&emsp;11点半开始下撤，回来的路上遇到了成都妹纸卡卡和她的背夫，她这会正准备去攀登Chhukhung Ri。回到hotel刚好12点半，点了份鸡蛋蔬菜炒土豆，1点多才上，吃完在大厅里小睡了会。在这里我们遇上了非常好的上海大叔，他是请了背夫过来的，那个背夫是个坑货，我们都看不过眼，往后的表现简直没有职业道德可言，之后我们偶遇了很多次大叔。他今天没有爬Chhukhung Ri，因为他的背夫用各种借口不让爬，他提前返回了Dingboche。 &emsp;&emsp;我们存了一些东西在Dingboche，要不我们就从这里穿越Kongma La Pass 直接到Loboche，还是因为看攻略说这个垭口难度很大，但当地人和很多旅馆里面的驴友都说挺容易的，有点后悔没穿越这个垭口，没办法只能返回Dingboche，还要再多花一天时间去EBC。 &emsp;&emsp;我们两点出发，3点多就到达Dingboche了，很轻松。我们找了家看起来很nice的hotel，名字叫Bright Star，双人间500rs，这是整个EBC期间住的最贵的hotel，因为整个行程里面大部分双人间就是一两百的，要知道山上的hotel主要是靠提供食物赚钱的。然后我们去之前的lucky hotel取回存放的行李，到了新hotel休整了会，这里遇到了一对韩国情侣和英国大叔以及它们的背夫。很快傍晚又是洛子峰的日落金山，现在对日落金山有点审美疲劳了😪。看完日落后气温越来越低，于是回到大厅烤火等饭吃。这家hotel的鸡扒做得太好吃了，里面还有陷，吃得好过瘾，可能也有我们好久没吃肉的缘故。 12/07 Dingboche -&gt; Lobuche&emsp;&emsp;EBC第八天，从Dingboche到Loboche。8点多才吃完早餐，接近9点开始出发，在EBC主线就是不同热闹多了，几十个驴友浩浩荡荡一起出发；与之天壤之别的就是去Chhunhung路上，人影都看不到几个啊😄。 &emsp;&emsp;今天遇到了好多中国人，遇到一个五六个上海小伙伴组成的豪华团，他们请了一堆的背夫向导，但他们很少运动，看他们轻装徒步都很费力的样子，重装徒步的我们毫不费力就把他们甩在了后面。我和zy本来是准备在Dughla吃午饭，但我们走的太快了，途中超越了很多驴友，10点多就到Dughla了，所以决定到了Loboche再吃午饭。在Dughla休息了一会，然后爬过前面300米左右的坡，之后的一路上好多的石碑，都是征服珠峰路上遇难的夏尔巴人和登山者的纪念碑，很有感触。 **登山者和夏尔巴人的纪念牌** &emsp;&emsp;再往前走就是豁然开朗的一片谷地，两边的雪山甚是壮观，左边金字塔造型的是Pumo Ri，这个也是中国尼泊尔的界峰；它们中间是隔着巨大的昆布冰川； **每天都有直升机的轰鸣声，总算抓拍到了灰机😄** &emsp;&emsp;右边则是城墙一般的Nuptse，Nuptse现在从南边看像一条山脉，到了Gorak Shap看它的西面，则是三角形般的尖锐山峰，就是古诗说的“横看成岭侧成峰”。 **海拔已经快接近5000米了，就算中午大太阳天积雪仍然不化** &emsp;&emsp;12点一刻，我们第一个到达lobuche，选了一家视角比较好的hotel，午餐点了份dal bhat，910rs，好贵。吃完午饭，在大厅休息，这里的充电还算不错，于是iPad和充电宝一起充了。3点开始爬附近的小山，爬上去可以看到漂亮的Pumo Ri，近距离观看努子峰，在这里又遇到了上海大叔和成都妹纸卡卡。 山坡上的心形图案估计是国人摆的 **近距离观看Pumo Ri** **一大群驴友在拍照，右边的大坑就是昆布冰川** **远处垭口上摇摇欲坠的冰川** **我也摆几个pose先😄** &emsp;&emsp;很多驴友在山上看过之后就回hotel了，但我们是没看到日落坚决不回。4点的时候平台上就没有阳光了，瞬间变得刺骨的寒冷，我们必须不断的踱步，热身运动，才能保持身体的温度，好不容易熬到5点，拍到喜欢的日落金山后，赶紧回hotel等饭吃，用上午在Dingboche买的wifi卡继续上网。 看，我们背后的Taboche和Cholatse雪山挡住了阳光，4点左右我们所在的平台就没有阳光了，冷气袭人😭 **Pumo Ri和Nuptse的日落金山，没有Lhotse的壮观** 12/08 Lobuche -&gt; Gorak Shep&emsp;&emsp;EBC第9天，Loboche到Gorak Shep。早上真是太冷了，我连牙都没刷，随便抹了下脸就完事了，吃完早餐8点多，开始出发，一路上也有很多驴友。 **昆布冰川边缘的路** &emsp;&emsp;冰川表面都是砂石灰尘，所以看上去根本不是想象中的那种晶莹剔透的冰川。 &emsp;&emsp;我们走得还是比较快的，两个小时后就到达了Gorak shep，只有三四家hotel，幸亏是淡季，床位大把，不用提前预定。马上找了家不错的hotel，找了间对着雪山的房间，然后到大厅订午餐。在大厅又遇到好几个中国小伙伴，上海大叔，卡卡还有另外两个国人，然后一边吃饭一边聊天，当然在这里又和澳洲帅哥Jimmy碰面了。 最终目的地-Gorak shep **我们的房间，正对着努子峰😄** **大厅的风景也是杠杠的，一边欣赏努子峰，一边吃午饭** **这几栋hotel背靠努子峰，风景没得说** **中间垭口后面那个山峰就是中国境内的章子峰了，我们终于看到了祖国了😄** &emsp;&emsp;中午1点多的时候，太无聊我和大叔出去外面转，又碰到了那个上海豪华团，看他们几个都有气无力的，有个妹纸看样子都有高反的症状了，他们第二天果然就呼叫直升机救援了。 &emsp;&emsp;我们回大厅继续聊天到下午2点，我和大叔，卡卡一起去爬Kala Patthar。其中大叔的向导给我们指错了路，搞得我们上的是平台另一个较矮的山头，而且这条路还很难走，上面一大堆的石头，爬到顶才发觉走错路了。最后又要从这个山头再爬到真正的顶峰，跟我同行的上海大叔和卡卡体力跟不上，他们没上到顶峰。我则费了九牛二虎之力才到顶，已经4点50分，刚好赶上日落。爬到Kala Patthar平台的一半 **看到珠峰了，努子峰后面黑黑的山峰，我们从这里看到的是它的西南坡，挺丑的😂，还是中国那边的北坡才有拔地而起的气势** **回望Gorak Shep，中间那几栋小房子就是** **我爬到第一个顶了，给小伙伴们指路去** **向另外一边的山顶进发，Pumo Ri就在我们头顶啊，有泰山压顶之感** **我终于爬到最终的顶了，看一眼珠峰** **终于爬到了顶峰，来几发装逼照** &emsp;&emsp;拍完留念照，珠峰的日落金山开始了，最帅气的是最前面的努子峰，珠峰是努子峰后面黑黑的山峰，根本不美，还是西藏那边的北坡才霸气。 Kala Patthar观看日落 **珠峰的金顶停留得最久，知道谁才是群山的王者了吧** 努子峰细节 珠峰细节 天黑之前这段时间，柔和的天光下，雪山的颜色很美 &emsp;&emsp;5点15左右日落结束，温度开始急剧下降，刺骨的寒风在耳边呼啸，我乘着月光，快速下撤，超过一个又一个驴友，40分钟就下撤到hotel了。马上点了个披萨，叫服务员ASAP，因为等下撤的人回来后，人多就要等很久才能吃到饭，所以我6点左右就开吃了。过了一会我们几个国人也到齐了，大家一边聊天，一边吃东西，因为只有我和zy带了单反，拍的效果比较好，分享了很多照片给他们。最后我们聊得太high了，从ebc,尼泊尔，印度，西藏，聊到中国，国家大事，一直聊到9点多，我们聊到大厅的火炉都熄了，太冷受不了才回去睡觉。 12/09 Gorak Shep&emsp;&emsp;EBC第10天，今天就是去最终目的地珠峰南坡大本营(Everest Base Camp)打卡，因为从Gorak shap到EBC来回总共就三四个小时，所以我和zy决定上午睡懒觉，下午再过去。但是我睡不了懒觉，9点多就起床了，洗漱完毕，到大厅看书，早餐就吃拉萨带过来的牛肉干，都到最终点了，赶紧把带来的零食消灭掉，留一点到Gokyo就行了。然后11点半就开始吃午餐，点的是Dal Bhat。刚好今天上午几个国人从EBC回来，他们竟然来回共用了接近5小时，去的时候就用了3小时。他们劝我们早点出发，我们本来准备2点才出发的，听了他们的劝告后我们提前到1点15分就出发。卡卡和另外两个国人则叫了架直升机，在珠峰山腰转了一圈后就直接飞回Lukla了，他们要去博卡拉玩几天。还有上海那个豪华团很多个高反了，也是坐直升机回去了。网上说呼叫直升机要七八千美元，但是向导帮卡卡他们叫的直升机也就2000美元左右，怎么这么便宜呢。 &emsp;&emsp;去大本营前半段比较好走，但后半段都是石头沙子，走起来特别费力，而且路还不明显，最后穿到昆布冰川的中间的大本营。我们居然只用了一个半小时，看来每个人的体能差距还是挺大的。到达这个标记后，很快就横穿进昆布冰川里面的大本营了 **从珠峰西坡延伸出来的冰川，这下冰川真的是晶莹剔透的** **就像进入了梦幻的童话世界** 我先来几个pose &emsp;&emsp;这会儿没有任何帐篷和人员，大本营非常的荒凉，只有个标记EBC的石堆。如果在登山季，这里就会变成各色国旗和帐篷的海洋。但冰川还是很漂亮的，拍了很多照，然后在EBC标志前留影，然后开始返程。知道吗，这里是我们离珠峰最近的地方，同时也是我们离祖国最近的地方，山的北面就是中国。 EBC标志 &emsp;&emsp;回到Gorak Shep已经5点左右，刚好可以看Nuptse的日落，继续拍照，毕竟以后很难再看到这么美的日落金山了。晚餐吃的是煮土豆和蘑菇汤，吃完饭几个国人又一起聊天，又买了个wifi卡更新朋友圈，流量一下就用完了。于是继续写日志，看书，然后回去睡觉。 Gorak Shep最后的日落金山Pumo Ri峰 **月在中天** **在大厅欣赏日落** **中国境内的章子峰** **努子峰** **边吃晚餐，边欣赏微软天光中的努子峰** 明天就要返程咯，顺路去拜访最美的一个点Gokyo，因为那里除了雪山还有美丽的高山湖泊，当然中间要翻越危险的Chola垭口。 12/10 Gorak Shep -&gt; Dzonglha&emsp;&emsp;EBC第11天，从Gorak Shep经过Lobouche直接下撤到Dzonglha。 一个小时就下撤到Loboche了 我们从西边的小路开始岔到zongla，对面就是我们来时走过的小路，现在这个时节，到Zongla的没几个人，一路上只有我和zy两个小黑点在半山腰跳动。苍茫天地，巍巍雪山，内心无比的平静和孤寂。 **AmaDblame又回到了我们的视线了，从西北坡这个角度看像尖锐的金字塔，比较一般** 终于看到湖了，从这里往右转弯，很快就看到Zongla了，感觉很近了，其实中间还隔着一个山谷啊，路程还挺远，而且一上一下很累的，但当时我们高兴了好久，以为半小时就能到，所以停下来慢悠悠的吃零食享受美景 &emsp;&emsp;休息完一路狂飙到达目的地才发现这个小村子也就七八家hotel，大部分都关了，只有两三家还开，因为现在正是淡季。到傍晚，整个村子不超过10个驴友，晚上又有些驴友过来了，才热闹起来。但zongla的景观挺棒，在ChoLa Ri雪山脚下，河谷方向正对Amadablame的的西北面。找了家在村口的hotel，但饭真是难吃。 &emsp;&emsp;晚上我们借用厨房自己做饭吃，因为zy带了吊炸天的高山高压锅，腊肉等。于是晚餐就是腊肉饭，再加个清炒土豆丝，我的是不辣的，他的是加辣的，一个盘子一半辣一半不辣😂。晚饭吃的真是饱，吃完喝茶，上网，写日志。另外今天一路下山看气喘吁吁往上爬的驴友，好有满足感😄。明天将翻过最难的垭口Chola Pass到达Gokyo。 12/11 Dzonglha -&gt; Gokyo&emsp;&emsp;ebc第12天，今天6点就起床了，因为太迟翻垭口，雪会结冰，太阳一晒融化后很滑，非常危险。吃完早餐已经6点半过了，刚好和两个泰国驴友以及他们的背夫向导一起。前面一段还行，只是爬了两个陡坡，我觉得比较简单。 &emsp;&emsp;到了覆盖冰川的垭口后，有些雪都已经化为冰，开始很难走了。我给了一个冰爪给zy，只有一个冰爪很滑啊，走三步滑两步，好不容易翻了过去。要翻越这个垭口以防万一必须带冰爪，雪一融化之后太滑了。 拼接出来的全景图，恐怖巨大的冰川，厚度超过3米，如果跌下去就是粉身碎骨 &emsp;&emsp;好不容易过了冰川，到达顶点，大家开始休息，都把随身带来的巧克力糖果等零食分享出来。休息完开始下山，接着就是很陡的下坡和乱石堆，路不好找，好不容易走出来。接着就是翻过前面一座山坡，然后就是沿着很明显的山谷往下走。这次泰国驴友的向导发挥了很大作用，要不我们还不知道能不能走过Chola Pass呢。 翻过危险的冰川后，登上垭口最高点 &emsp;&emsp;中午快12点的时候，zy太饿了，就在河谷中间用自己带的炉子气罐做方便面吃。我是不想吃方便面，于是一路向Dragonal进发，12点半到达，中午吃的是dal bhat。 眼前就是Dragonal &emsp;&emsp;吃完午餐休息到2点，zy过来和我汇合，一起向Gokyo出发。前半段比较好走，后半段穿越Ngozummpa冰川，Ngozummpa冰川要比珠峰那边的昆布冰川要巨大的多，中间的沙石路好难走，花了1个多小时才穿越冰川，4点左右终于到达Gokyo。 **走到冰川中间，时不时轰隆隆的巨响，万一冰真的崩了，我们的小命不保，远处就是世界第六高峰-卓奥友峰** &emsp;&emsp;快到Gokyo的时候，又碰到了之前遇到的西班牙小伙John和几个欧美哥们。他们不熟悉路线是跟着个尼泊尔向导过来的，John给我们推荐的是lakeside，听说老板娘做的饭好吃。于是就住那了，住了间能看到湖景和雪景的房间，这家hotel很好的地方是住宿不要钱的，😄，但略坑的是，wifi卡竟然贵多了。进到大厅，我们又遇到了老熟人澳洲小伙Jimmy😂。 gokyo在第三湖边，北面对着卓奥友峰，景色很美 **卓奥友峰日落，从这个角度看很一般** &emsp;&emsp;晚饭点了份牦牛肉momo,味道果然不错，但没吃饱，6点多又点了份veg chowmain，两个人分了吃，然后围着火炉烤火，上网，写日志，hotel里面只有我们两个中国人，其他都是欧美澳洲人。 12/12 Gokyo&emsp;&emsp;EBC第13天，今天美美的睡了个懒觉，接近9点才起床，早餐吃的是美味的三明治和hot orange。然后我就沿着Gokyo第三湖拍照，还爬上村子背面的小山拍全景。 Gokyo附近平台，就在冰川边缘 &emsp;&emsp;拍照回来再点了个美味的dal bhat当中饭，这会上海大叔竟然过来了，我们又住同一个hotel了，太有缘了。原来他的向导找的房子太差，所以就丢开向导自己来找靠近湖边的房子，刚好看到我和zy在lakeSide hotel的大厅玩耍😄，所以就进来了。同时又来了个广州的妹子，她已经在东南亚，印度，中东一圈玩过来，有一年多了，太🐂了，中国人多起来就好玩了。 &emsp;&emsp;下午我们约好一起去Gokyo Ri，我和zy体力好，2点半才出发，他们不到2点就出发了，太早到山顶风大，冷死人，所以我们都是慢悠悠的爬,4点过就到顶了。顶上可以看到十几座世界级的山峰，除了珠峰，洛子峰，努子峰，还有世界第五高峰-马卡鲁峰，世界第六高峰-卓奥友峰，等等，名字都数不过来，太多了。Gokyo Ri比Kala Patthar距离珠峰比较远，但视角更加开阔，珠峰反而更加壮观。先是拍个人照，很快就到5点了，开始欣赏壮观的日落。 Gokyo Ri上的自拍 Gokyo Ri世界级雪山群的全景 &emsp;&emsp;难得一遇同时月亮从珠峰上升起，颜色从黄色，红色，紫色最后变为蓝色。日落金山完了，接着就是月照银山。视觉的盛宴，太美，太壮观了。当日落一开始，气温马上直降，加上强劲的寒风，还没看完月照银山，就冷到受不了。迎着皎洁的月光，用了一个小时下山，赶紧回lakeSide吃饭烤火。 Gokyo Ri观看珠峰日落 Gyachung Kang的日落&emsp;&emsp;卓奥友峰在我们的西北端，除了只看到一点点金顶，其余都是漆黑一片，所以日落效果很差，但它旁边的世界第十五高峰-Gyachung Kang，日落金山却非常壮观。 &emsp;&emsp;晚餐吃的是春卷，美味但不够吃，于是又点了份蔬菜炒饭。吃完饭，发朋友圈，写日志，准备明天的计划。明天上海大叔要和他的向导翻越Renjo La Pass到第一条山谷往下走，大概后天会到第一第二条山谷相交的Khumjung。而我、zy和广州妹纸明天继续留在Gokyo，徒步去看第4，5，6湖，后天我和zy不穿越Renjo La垭口，直接从Gokyo这边的第二条山谷往下走，和大叔相约在Khumjung见面。 而广州妹纸后天则是继续去EBC，她装备不是很好，反向翻越Chola Pass太危险，所以我们建议她和我们一样先从Gokyo这条山谷往下走，再从Dingboche那条山谷往上去EBC。我们计划都完成后，就开始聊天，聊自己的旅行见闻，聊文化历史，聊嗨了。 12/13 Gokyo&emsp;&emsp;EBC 第14天，今天我们和广州妹子一起去看Gokyo的第4，5，6湖，而上海大叔则要翻越Renjo La EBC 第14天，今天我们和广州妹子一起去看Gokyo的第4，5，6湖，而上海大叔则要翻越Renjo La pass，然后徒步第一条山谷，2天后到达Khumjung，希望后天我们还能遇上。大家吃完早餐8点过了，告别了大叔，我们也要往北徒步去看遥远的第六湖。因为Gokyo离第六湖很远，来回几乎要一天时间，午餐只能在路上解决，于是跟hotel老板买米，中午用来做腊肉煲饭，zy有腊肉，还有先进的高压锅。本来我们不需要那么多米的，但老板娘不高兴，就必须卖1公斤给我们，一共花了400rs，好坑。不过想想她的住宿免费呢，中午少赚了我们三个人的午饭钱（三个人午餐接近2000rs），也可以理解吧。走了一段路，zy发现没有带火机，他又回去找，我们则到第4湖等他。半小时后，他过来了，火机没有找到，估计丢了，带了一盒火柴过来。向着卓奥友峰进发 结冰的第四湖，周围光秃秃的，水也不绿 快到第五湖了 &emsp;&emsp;第4湖已经结冰了，风景一般，继续走，大概11点45左右到了第五湖，海拔更高，冰层更加厚实，用大石头都砸不烂。但是好失望啊，四五六湖都结冰了，我们决定不再去看第六湖了，同时开始做午饭，没有水，那就用第五湖的冰块烧水做饭。半小时左右，香喷喷的腊肉煲饭就好了，我和zy一人一个小塑料碗和一根筷子，广州妹子就用锅盖乘饭，用手抓，她自嘲说从印度一直到中东吃惯了手抓饭😂。 第五湖也已经结冰了&emsp;&emsp;第五湖大多了，结冰的湖面泛出幽幽的绿光，我们先拍照，然后就丢石块砸冰块玩。 我们的午餐-腊肉煲饭 &emsp;&emsp;在做饭的间隙，我就爬到附近的小山看风景，果然是观赏珠峰的好地方，珠峰整个西南坡都能看到，还能看到洛子峰和珠峰之间的山谷，那是珠峰南坡登顶必经之路。 卓奥友峰被左前方的山坡挡住了，但露出的格重康峰很美 珠峰的西南坡，如果爬山附近那座小山，视角一定更棒 &emsp;&emsp;吃完饭后，我们就慢悠悠的往回走，两点半左右到达lakeSide hotel。赶紧乘阳光灿烂，天气暖和，洗脚，洗脸，洗袜子，晾鞋子。 &emsp;&emsp;收拾完开始看书，沉思录已经看第二遍了😄。悲催的是下午4点多就没有太阳，刮起了大风，温度急降，袜子还没干就变成硬邦邦的冰条了，于是拿进屋子的火炉旁烤。6点准时吃饭，吃的是chowmein add double eggs，一下就吃完了，接着写日志，上网，明天就要离开呆了两天三夜的Gokyo了，这是我们呆得最久的一个点了。 12/14 Gokyo -&gt; Phortse Thanga&emsp;&emsp;EBC第15天，吃完早餐开始结账，发现三夜两天消费了7600rs，消费太高了😭。而广州妹纸这会不知去哪了，我们时间紧只能先出发了，9点开始沿着河谷向Khumjung出发，经过Gokyo的第二，第一湖，湖一个比一个小，其中第二湖一半结冰了，还挺漂亮的的。拍完照继续往下走，Thamserku和Amadablame又回到了我们的视线，今天开始天空还有了云，雪山更娆挠了。 再见，Gokyo 湖面结冰了一半的第二湖 微型的第一湖，清澈见底 直升机在我们头顶呼啸而过 Thamserku和kangtega雪山又回到我们的视线了 最后回望一眼卓奥友峰 沿着河谷往下走，海拔越来越低，风景也由裸露大气变得越来越秀气 &emsp;&emsp;糟糕的是过了Machhermo村大概1个多小时后我们走错路了，最后走到河谷的下面去了，离Dhole还差一公里的地方被前面的悬崖挡住过不去。如果往回走到之前的分叉口要3公里多啊，再重走过来一共6公里多😭。而且这会gps又没电了，于是只能往上爬，高度差有400多米，中间有部分很陡峭很危险，手脚并用爬上去之后，精疲力尽了。关键是浪费了两个小时，最后爬上去的地点是Dhole 的前一个地点Lhabarma，随便点了份蛋炒饭，非常难吃，吃完已经快下午3点了，今天我们是赶不到Khumjung了。 &emsp;&emsp;zy顺便在这家店找了很多旧电池把gps启动起来，以后岔路一定要看gps，不然迷路之后太危险了。后面是一路下坡，到达Phortse Thanga已经4点半了，到Khumjung还要接近3小时，而且前面还有一段300多米的坡，走夜路又太危险，中间几乎没有客栈，于是我们决定就在Phortse Thanga住宿。海拔终于降到4000米以下，又能看到青山绿水了，比起5000米以上的海拔，4000米海拔太暖和了😂，而且有了手机信号，但不稳定，几乎不能上网。还有这家hotel的房间的灯太TMD暗了，饭也难吃。洗簌完毕之后，点了份Dal bhat，回房间写日志休息，等晚饭吃。在hotel遇到的是澳洲的四口之家，儿子大概七八岁，女儿也就十二三岁的样子，背夫向导一应俱全，他们一家子还带着吉他。吃完饭后，他们一家子就开始一边弹吉他一边唱歌，我们就一边烤火一边欣赏，好欢乐啊，聊到8点后，大家就回去睡觉了。 12/15 Phortse Thanga -&gt; Lukla&emsp;&emsp;EBC第16天，7点半吃完早餐，从Phortse Thanga出发，越过300多米爬升的坡，我把zy甩在后头了，在山顶上等了将近20分钟，他竟然错过，先走了。于是我又要去追他，在快到Khumjung时终于汇合了。 &emsp;&emsp;然后路过最美的小镇Khumjung，日本人的豪华酒店就建在该小镇附近的山上，是世界最高的星级酒店哦，我还特意去转了一下。Everest,Nuptse,Lhotse,Amadablame都能看到，视野开阔，景色超棒。 Kangtega就在不远处，说明就快到Khumjung和Namche了 美丽的Khumjung &emsp;&emsp;Khumjung就在半山腰，而Namche就在山脚，它们之间行程不到1小时，Khumjung也算挺大的小镇，也有市场，最关键视角很棒，能看到远处的珠峰所在的峰群。 日本人的豪华酒店 向近在咫尺的Namche进发 &emsp;&emsp;Namche Bazar就在我们脚下，往下的山路非常陡，中午的时候我们回到了整个EBC最大最繁华的小镇Namche，它是建在半山腰的窝窝里面，前面是Kongde Ri雪山，各种hotel和resturant真是多余牛毛，商店，酒吧等娱乐场所也一应俱全。 很nice的店，午餐也很美味 &emsp;&emsp;吃完后马上出发，因为从Namche到Lukla路程还很长，相当于两天的上山路程，我们一个下午要走完。我们今天的路程相当于之前三天上山的行程，所以非常艰苦。尽管EBC风景很美，但艰苦的环境我们确实熬不住啊，早就归心似箭了，这几天只想着回温暖湿润的加都享受热水澡，美食，懒觉，还有休养我那过度损耗的膝盖。 &emsp;&emsp;先是到达namche的check pose进行check out登记。有意思的是，尼泊尔警察问我们要不要350rs的EBC证书。想想也不是很贵，就要了，里面写上自己的名字，国籍，走过哪些主要的点，还是可以用来炫耀的，这警察挺会赚钱的嘛😄，一张纸卖个350rs。 &emsp;&emsp;之后就开始下大坡了，上这个坡是很累的，看着一路上气喘吁吁的驴友，好快意。我走的比较快，3点左右到达Phakding，又把zy甩在后面了，我想提前去机场改签。 过这个吊桥的时候遇到一大队的牛马运输队，足足等了接近10分钟 回到了Phkading &emsp;&emsp;Phakding到Lukla的最后一段路比较累，因为Lukla就在一个高坡上，反而更多时候是往上爬，一路不敢休息太久，因为5点后就天黑，走夜路太危险。尼泊尔时间16点40终于到达Lukla，于是找了家离机场很近的旅馆Paradise lodage，等zy过来。我手机没电，赶紧充电宝，信号也不好，只能用hotel 的wifi，联系zy，告诉他旅馆的位置。可是一直联系不上，他那边也没信号，好不容易6点多才联系上，在我们之前吃过早餐的店接头。可是他手机又没电，他随便订了家旅馆，用wifi 才联系上我，我们一商量，还是一起住我之前订的房，我帮他退了房，一起到paradise lodage住。这家店做的饭也好吃，但上的慢，我们点的是dal beat with meat，是牦牛肉，好吃。再点了两罐啤酒，庆祝完成EBC。 终于回到了起始点-Lukla，圆满完成了EBC 12/16 Lukla -&gt; 加德满都&emsp;&emsp;今天我们7点就起床，收拾行李，早餐准备回加都再吃，因为加都什么东西都物美价廉。收拾完7点半过点就去机场，然后去机场check in，因为我们比预计的计划提前了一天，所以还得找工作人员帮我们改签到今天回加都。可能今天太多驴友回加都，必须额外增派航班，等到10点多，才轮到我们的航班，我们只能在机场吃最后剩余的零食当早餐了。太有缘了，飞机起飞前，又遇到了上海大叔，于是聊天打发时间，可惜不是同一航空公司，我们所在的Tara Air飞机先走，他的航班要稍后。大叔回加都休息一段时间后，接着还要去尼泊尔的平原地区看人文风景，然后再去不丹，好羡慕😭。 &emsp;&emsp;返程我又争到靠雪山一侧的位置，也就是靠右的位置😂，但这次风景一般。回到加都已经11点多，打taxi回之前住宿的地方，420rs，其中20是司机的停车费，😷。想想当时来机场是500rs,也就算了。回来我们订了1400的双人间，很好，同时取回之前的行李，稍微收拾了下，直接去吃午餐，太饿了，吃的是附近的中餐馆，还不错。但两人吃了2400rs多，好贵。然后买了梨子，加多宝，降火和治喉咙痛，好奇怪，回加都海拔低的地方，喉咙好了一大半。回到房间，开始清理洗澡，毕竟我们16天没洗澡和洗头发了，我洗了将近40分钟吧😄。然后把堆积的衣服拿去干洗店干洗，反正尼泊尔物价便宜得很。下午就是休息上网，电子设备，充电宝开始充电。但到4点多，我就觉得饿，于是去找好吃的，攻略推荐了一家gilingche,就在附近。我点了份momo sizzler bufff，果然美味，让我对尼餐有了改观。吃完就到附近超市买零食，买了1300多，回来继续上网吃零食，然后写日志，洗澡，休息。 12/17 加德满都、帕坦&emsp;&emsp;今天7点就起床了，特意去外面逛，发觉很多早餐店还没开门。逛到8点，去了家听说不错的helena ‘ restaurant，要跑到8楼吃早餐，听说是加都最高的餐厅。点了份最贵的400rs的早餐，最后结账加上小费共495rs，挺贵的，但比起山上动不动接近1000rs的价格，已经实惠很多了。吃完回去休息，喝了点果汁，这下肚子不舒服，竟然拉肚子，一整天一直拉到晚上，太难受了。 &emsp;&emsp;下午3点我和周毅打了车去加都附近的帕坦看博物馆、黄金庙和那边的杜巴广场。博物馆1000rs，黄金庙50rs，打车1000rs。司机太热情了，兼职当我们的向导，帮我们讲解和带路。但风景觉得一般了，杜巴广场的塔正在修复，很多脚手架，宫殿也是一样，真的大煞风景，到5点就回加都了。但路上的晚霞很漂亮啊，感觉比在景区看古迹强。最后到hotel 已经6点，今晚周毅请吃饭，炖了鸡汤，再加上卤牛肉，白油豆腐。大吃特吃，晚上我又拉肚子了，起来了两次，太难受了。 帕坦 神猴哈奴曼，类似西游记神通广大的孙悟空，也许是美猴王的原型呢 精美的木雕 博物馆藏品 黄金庙 宫殿 回加都路上 12/18 加德满都&emsp;&emsp;今天10点多起床后准备出去吃早餐，好巧啊，又碰到西班牙小伙John，竟然和我们一样住在sun rise cottage，他今天刚回到加都。顺便一起去吃早餐，先带他到附近的laundry店，接着带他到Gilingche tibet restaurant。但我目前肠胃不好就去齐鲁聚鑫源餐厅，好巧啊，吃完回来路上又遇到了在gokyo客栈遇到的斯洛伐克小伙，世界好小😊。然后我把昨天干洗的衣服取回来，再收拾下，然后上顶楼阳台用iPad 上网。楼顶和我一起的还有之前呆了几个月一边学习英语的中国妹子。她们还要继续在尼泊尔一段时间，需要尼币，于是顺便跟她们把尼币换成了人民币，按之前的汇率16.7。 下午John也跑到顶楼和我们一起聊天，晒太阳。快到傍晚的时候，中国妹子们准备去看电影吃饭，我很久没有看电影了，顺便和她们一起去看电影，听说星战前传《rouge one》已经在尼泊尔上映了，而国内还要过一段时间才上映呢。但到影院后才发现，过几天才上映，其他全是印度电影，对印地语的电影看不懂，也没兴趣。我逛了一会就回去了，顺便去吃了攻略上推荐的fire and ice pizza，还行吧。 12/19 加德满都 -&gt; 昆明&emsp;&emsp;今天是我在加都最后一天，碰巧成都的卡卡也是要回国，还和我同一架次。所以我们约好一起打我们hotel 的车去机场。早上我们就在写明信片，先寄到自己的住宿，再一个个分发给朋友。我想不到什么祝词，就所有都写一样的，请接受我来自尼泊尔的祝福。每张明信片10rs，每张寄出去35rs。写完之后，我去吃了个拉面，快1点，卡卡收拾完也过来了。 &emsp;&emsp;1点半出发去特里布万国际机场，客栈老板娘还特意给我们离开的人戴哈达，这是她的一个惯例，并叮嘱我们多介绍朋友过来。去机场路上交通堵塞，司机左弯右拐，总算把我们送到机场。到了之后还有接近2小时才起飞，我想办法把我最后500尼币花出去，要么太贵买不起，要么不是我想要的东西，关脆把它留作纪念好了。在机场时，我们又遇到了和卡卡一起的从ebc下撤的小伙伴。 &emsp;&emsp;最后4点半飞机终于起飞了，再一次从高空欣赏喜玛拉雅山脉，终于要回到祖国了。经过徒步路上深刻的洗礼，我毫不费劲就认出了最著名的那几座山峰，卓奥友峰，格重康峰，珠峰，努子峰，洛子峰，马卡鲁峰。由于有两个多小时的时差，尼泊尔时间4点半起飞，到昆明已经是北京时间晚上9点。两个多小时内体验了从傍晚的夕阳迅速变为夜晚的过程。 从左到右，最高的几座分别是卓奥友峰，格重康峰，努子峰，珠峰，洛子峰，马卡鲁峰 **珠峰、努子峰、洛子峰特写** &emsp;&emsp;由于第二天9点转机到成都，取完行李后已经是晚上10点多了，干脆就在机场呆一个晚上。好在机场有免费的wifi，于是在候机厅找了个长凳上网打盹睡觉等候黎明的到来。 12/20 昆明 -&gt; 成都&emsp;&emsp;早上7点左右开始办理托运行李，安检，在德克士吃了份玉米牛肉粥后匆匆出发。一个晚上没睡好觉，很困，而且登机牌没有标记gate、no，我跑到错误的云南航空49号登机位，还在工作人员提醒我赶紧去22号登机口。刚到马上就开始登机，整个飞行过程1个多小时，我几乎都是睡过去的。到达成都了，感觉比昆明要冷，雾霾也很大啊。坐机场2号线到天府广场东路，然后打摩托过去找梦之旅青旅。摩托阿姨兜了好久也没找到这个青旅，我干脆自己看地图导航找，就在武侯祠对面找到了。里面的环境很棒，住了个55的四人间，还有空调。吃了附近小店的担担面，非常好吃。晚上顺便去附近的万达影城看《血战钢锯岭》，感觉一般般，回来上网睡觉。 12/20-23 成都&emsp;&emsp;这几天就是呆成都到处逛吃的，要好好补一补。吃了各种出名小吃，龙抄手一般，但老麻抄手好吃，钟水饺，老妈蹄花也不错，夫妻肺片还行，三大炮太腻。感觉川菜味道很好，而且真的不是很辣，反正我几乎不吃辣的广东人都能接受。但我真的很喜欢吃成都的各种面食啊，太好吃了。然后中间去了趟都江堰，武侯祠，然后和卡卡小聚了一会，吃串串。 12/23 成都 -&gt; 深圳&emsp;&emsp;今天7点半闹钟吵醒了，但昨晚没睡好，还是继续睡到8点才起床。起来到附近小店吃了份排骨面，很好吃，觉得不过瘾，再到另一家吃了份肥肠粉和包子，这家真的不好吃。吃完到青旅对面，武侯祠旁买了10元到机场的直通车车票。回去收拾完行李，退房，到停车场就快9点了，等了一会，出发，到达机场45分左右，比较坑的是，在国际航站楼下车，搞得我费了不少周折，背着沉重的行李赶到T2国内航站楼。过完安检，候机的时候就一边上网，然后开始写这几天在成都的日志。11点20登机，12点多飞机起飞，2点半到达深圳，一个多月的长途旅行终于结束了。回来一大推的计划要完成啊。 后记&emsp;&emsp;从普通背包客到真正的登山家，尼泊尔都是天堂，便宜，丰富，而且是那种只要你愿意探索，就永远有新东西的地方。短短一个多月的时间，令人窒息的美景，艰难至极的跋涉，喜马拉雅的群山，尼泊尔，我还会再回来的，就像那句口号说的:”Welcome to Nepal, once is never enough”. 重返喜马拉雅之ACT篇重返喜马拉雅之ACT篇","tags":[{"name":"旅游","slug":"旅游","permalink":"https://edwardzhong.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"尼泊尔","slug":"尼泊尔","permalink":"https://edwardzhong.github.io/tags/%E5%B0%BC%E6%B3%8A%E5%B0%94/"},{"name":"加德满都","slug":"加德满都","permalink":"https://edwardzhong.github.io/tags/%E5%8A%A0%E5%BE%B7%E6%BB%A1%E9%83%BD/"},{"name":"lukla","slug":"lukla","permalink":"https://edwardzhong.github.io/tags/lukla/"},{"name":"ebc","slug":"ebc","permalink":"https://edwardzhong.github.io/tags/ebc/"}]},{"title":"喜马拉雅之旅（尼泊尔ABC篇）","date":"2017-01-20T13:01:00.000Z","path":"2017/01/20/abc/","text":"&emsp;&emsp;在连绵的喜马拉雅山的南边，有这样一个国家： &emsp;&emsp;国土面积仅占全球面积的0.1%,但这里生长着800多种鸟，500多种蝴蝶，600种特有植物，在方圆20公里的范围内有7处世界文化遗产。 &emsp;&emsp;庙宇多如房舍，节日超过一年的天数，2000多万人口有3.3亿神祗。 &emsp;&emsp;她是高山的国度，阳光明媚，鸟语花香；在不满15万平方公里的国土上，拥有8座8000米以上的高峰；她是世界上海拔差异最大的国家。 &emsp;&emsp;她又是丛林的国度，她还是动物的王国。你可以住在原始森林里，骑在大象的背上，和孟加拉虎同饮，和独角犀牛跳舞。 &emsp;&emsp;她绝对是探险家的天堂：登山、徒步、漂流、攀岩、跳伞。 &emsp;&emsp;她就是尼泊尔。 &emsp;&emsp;尼泊尔是亚洲最贫穷的国家之一，但却是世界上幸福指数最高的国家之一。 &emsp;&emsp;她虽然很落后，但却完全西式教育，几乎人人都会英语。 &emsp;&emsp;她虽然民风淳朴，但却是英勇善战的廓尔喀雇佣军的家园，严酷的自然条件造就了悍不畏死的山民。(Ghandruk) (安娜普尔纳一号峰) (鱼尾峰) (鱼尾峰日落金山) (鱼尾峰日落金山) (ABC星空) (安娜普尔纳日照金山) &emsp;&emsp;2016年11月16日，结束西藏之行后，带着无限的憧憬和对雪山的向往，从拉萨乘飞机跨过喜玛拉雅山脉，来到神秘的国度-尼泊尔。 &emsp;&emsp;尼泊尔的著名的徒步路线有十多条，其中最知名的就是安娜普尔纳山区的ACT（Annapurna Circuit Trekking），ABC（Annapurna Base Camp），Poon Hill（布恩山小环线）和萨加玛塔国家公园的EBC（Everest Base Camp）。安娜普尔纳山区的3条徒步路线可以自由组合起来一起走。 &emsp;&emsp;ACT是一条环绕安娜普尔纳山脉的大环线，基本上是远看雪山和田园风光，走完要接近两个星期，是一条人文路线，也可以结合Poon Hill和ABC。 &emsp;&emsp;ABC最终目的地是安娜普尔纳大本营，近距离观看壮观的鱼尾峰和安娜普尔纳峰，6、7天可以走完，Poon Hill则是看布恩山日出和云海，3、4天可以走完，ABC结合Poon Hill要9、10天。 &emsp;&emsp;EBC的最终目的地就是世界最高峰-珠峰的大本营。近距离观看最壮观的雪山和冰川，一路上是世界级的山峰数都数不过来，风景和震撼程度也是安娜普尔纳无法比拟的，但难度也是高了一个级别的。ABC海拔最高的地点就是最后一天的大本营4100多米，而EBC基本上海拔都在4000米以上，有好几天还是海拔5000米以上，我爬过最高的海拔是5800米。如果只走EBC主线，10天左右可以走完；但一般都会加上Gokyo线；时间足够的话，则再加上Chhunkung线，三条线一起走一共要15天左右。 &emsp;&emsp;而这次我走了其中的ABC和EBC，加上在加德满都，博卡拉的时间，在尼泊尔呆了一个月多点。所以30天的签证是不够的，刚到加都我就去尼泊尔移民局续签了15天，续签是免费的，手续也很简单。ABC徒步必须要办理两个证件TIMS和ACAP，游记后面有介绍这两个证件和办证地点。 &emsp;&emsp;中国游客可以说是尼泊尔最大的客源，加德满都和ABC碰到国人的几率很高，加都还有一条类似于唐人街的街道。所以见到尼泊尔人操一口很溜的中文，不要觉得奇怪。反正在加德满都街头，尼泊尔小贩就喜欢用“你好”搭讪看着像中国人的。尼泊尔人都比较友善淳朴，英语普及率很高，除了在比较偏避的山区外，用英语交流基本没问题，不过那一口印式口音，也是醉了，一开始非常不习惯。在尼泊尔呆了一个多月，我的英语水平真的是突飞猛进啊。 行程路线这是总的行程，本游记是加德满都，博卡拉，abc部分。穷游行程助手下的详细行程单西藏部分请看:喜马拉雅之旅（西藏篇）EBC部分请看:喜马拉雅之旅（尼泊尔EBC篇）ACT部分请看:重返喜马拉雅之ACT篇 日程安排 时间 交通 地点 景点 住宿 2016/11/16 (Wed) 拉萨-&gt;加德满都飞机 13:10 - 12:00 拉萨-&gt;加德满都 加德满都兑换尼币，换电话卡，找住宿 民宿 2016/11/17 (Thu) taxi 加德满都 办理ABC、EBC相关证件，续签visa Tibet Guset House 2016/11/18 (Fri) tourist bus 8:00 - 17:00 加德满都-&gt; 博卡拉 逛博卡拉 hotel Mandap 2016/11/19 (Sat) 巴士,徒步 博卡拉,ABC ABC徒步开始 民宿 2016/11/24 (Thu) 巴士,徒步 博卡拉,ABC ABC徒步结束 hotel Mandap 2016/11/25 (Fri) 自行车 博卡拉 世界和平塔 hotel Mandap 2016/11/26 (Sat) 巴士 博卡拉 滑翔伞 hotel Mandap 2016/11/27 (Sun) tourist bus 8:00 - 16:00 博卡拉-&gt;加德满都 返回加都 sunrise cottage 11/16 加德满都&emsp;&emsp;在拉萨呆了10天后，今天终于出发去尼泊尔了。中午11点多的飞机，早上好不容易找到布达拉宫旁边的机场直达车，出发到贡嘎机场一个多小时。到达机场后又推迟了一个多小时才起飞，听说是因为军演，我在贡嘎机场也是有看到歼10战机频繁起飞的。到达尼泊尔要一个小时左右，尼泊尔时间12点左右终于到达加德满都。 喜马拉雅山脉&emsp;&emsp;飞机从喜马拉雅山脉的上空飞过，在我们右侧的就是珠峰所在的密集峰群，大部分在尼泊尔一侧。雄伟高大的雪山组成的峰群看上去就像是一大片波涛汹涌的海浪，峰峦如聚，波涛如怒。尼泊尔就在山脉的南侧，海拔从8000多米一直往南延伸到海拔1000米以下，可以说尼泊尔整个国土就是建立在喜马拉雅山南麓的迎风坡上，而印度洋季风可以毫无阻碍的湿润整个尼泊尔。这一世界最高山脉的阻隔导致的两边巨大的差异，印度次大陆是气候宜人，温暖湿润，现在尼泊尔还到处都是一片绿意盎然，而西藏自然条件就恶劣很多了。最直接的对比就是，在拉萨还穿冲锋衣，一到加都，我们直接穿T恤就可以了。 从飞机上俯瞰雄伟的喜玛拉雅山，山间云雾缭绕，峰顶直冲云霄。很快我就要在ABC和EBC中近距离的欣赏你的伟岸英姿和感受你的豪迈气概。 加德满都街头&emsp;&emsp;在机场的出入境处，3个来尼泊尔腐败游的妹纸遇到我们，她们没有准备攻略和计划，于是决定和我们一道游玩，她们也没有徒步经验，竟然也要跟我们一起去博卡拉徒步ABC。这样我们就变成6个人的团队了，我和zy，zy的女同事加上3个妹纸，2男4女。 &emsp;&emsp;刚出机场，一群尼泊尔司机就围过来，有个司机中文还说得很溜。我们讲了好久的价，最后6个人挤一辆的士，800rs到泰米尔区。司机把我们载到他朋友开的旅行社，我们嫌旅行社提供的住宿太贵了，于是旅行社代理就把我们介绍给附近比较便宜的旅馆。我和zy住的是1000rs的双人间，一开始觉得还挺划算的，真是太天真了。我们都是按中国的消费水平来看的，哪知道尼泊尔消费很低，1000rs可以住很好的房间了。但当时只想快点安顿下来，没想那么多，因为有很多事情要办，兑尼币，买电话卡，办理各种证件。 &emsp;&emsp;首先就是找国人开的凤凰宾馆兑换尼币，用支付宝换尼币，关键汇率比外面的高，外面是15.8左右，而凤凰宾馆有16.3，我兑了3000人民币，拿着一大沓的钱，瞬间感觉变成了土豪。然后顺便在里面办尼泊尔Ncell手机卡，1g流量，900rs。办理完手机卡后，已经是尼泊尔时间4点多了，我们中午只吃了很小分量的飞机餐，肚子都饿了，于是决定去试一下尼餐。点了6份式样不同的，互相尝试，有些还可以接受，但有些不合口味。吃完回去hotel休息了下，晚上出来继续逛街买一些当地特产，顺便吃了些零食当晚餐。 这附近有很多中餐馆和中国旅馆 我们的下午茶，来尼泊尔的第一顿饭，好多咖喱 关于加德满都&emsp;&emsp;加德满都真的是各种脏乱差，而泰米尔区就是一个大城中村，吃住行应有尽有，一般游客都会选择到这个区住宿。这里到处都是卖衣服，体育用品和工艺品等的小店，这里还特别多山寨的户外用品店。旅行社也是特别多，基本上都是热门的徒步、登山、滑翔、漂流，谁叫尼泊尔户外资源这么多，而且还挺会开发的。 &emsp;&emsp;从机场打车去Hotel Phoenix，司机基本都懂。凤凰宾馆里面有住宿，可以用支付宝兑换尼币，比街上的汇率要高一些，还可以直接办理电话卡，同时里面还有一些旅游相关的业务，总之主要服务对象是中国人，里面的尼泊尔服务员中文也是非常溜。凤凰宾馆的住宿和一些服务性价比是比较低的。 &emsp;&emsp;我们刚来尼泊尔，不懂事，其实附近还有汇率更高的地方，也是后来跟当地的中国人接触后才了解到的。都是在附近的旅馆，比如“圆梦”和“加都一号”，汇率更高，更实惠。 &emsp;&emsp;如果懂基本的英语，还是多了解和融入当地人比较好，出国还呆在中国人的圈子里多没意思。而且尼泊尔人的住宿和各种服务性价比非常高，同时可以多了解当地的风俗习惯和生活方式，所以我们选择住在当地人开的旅馆。 11/17 加德满都&emsp;&emsp;今天要办的事情很多，第一要找新的住宿，因为对之前的住宿不满意；第二要办理相关的证件，ABC徒步的TIMS和ACAP，我和zy同时把EBC的也一起办了，然后去续签visa。第三明天去博卡拉的车票。 &emsp;&emsp;我们一开始找青旅，但这边的青旅都不怎么样，在加都找地点太麻烦了，没有规划，房子又密，明明地图显示到了，但又找不到，真是累死了。当我们不抱希望的时候，无意中遇到一家叫Tibet guset house的旅馆，平均一人1000rs，里面条件很不错。于是退了原来住宿，打了两辆车把我们的行李都运过来。 &emsp;&emsp;午饭都没顾得上吃，又去找Nepal tourism board，办理徒步相关的证件。在杜巴广场找了好久找不到，好在附近的中国餐厅的好心老板告诉我们办证的地点。我们一开始是按地图去找的，但加都就是规划太乱了，怎么也找不到啊。没办法我们就坐了几辆人力三轮车一起去目的地，一路上太刺激了，尼泊尔三轮车小哥技术太牛逼，在拥挤的街上狂飙。到达Nepal tourism board后，我是很快就办完了ABC和EBC的证件，然后一路问路去找immigration office，好不容易才找到，最后办了visa的续签，我续签了15天，免费，手续很简单，很快就办完了。于是马上赶回Nepal tourism board和小伙伴集合，打车回住宿附近吃饭，吃的是西餐，但牛扒也做得太老太难吃了。 &emsp;&emsp;今天走了好多路，一个个都不想动，回到住宿的地方，就找附近的旅行代理，买了明天去博卡拉的tourist bus车票，2000rs，包中餐，早上7点发车。其实这个车票不划算，一般的不包午餐的车票也就800rs，午饭自助的话300rs就够了。所以我们到时从博卡拉回加都就是买800rs的车票，然后午餐自己掏钱买。 关于徒步的证件TIMS：Trekker Information Manerger System，徒步者信息管理系统。就是徒步者的相关信息，国籍，年龄，性别，保险之类的。每个不同的地区都要办理，比如ABC和EBC就要分别办理，费用是2000rs。 ACAP：Annapurna Conservation Area Permission，安娜普尔纳保护区许可证。这个就是类似于门票的性质，费用也是2000rs。 这两个证件是在Nepal torisem board办理，如果在安娜普尔纳被抓到没有这两个证件，是要双倍的价格重新办理的。 下面就是坐尼泊尔小哥的人力三轮车经过杜巴广场看到的街景 街头有很多雕像和佛塔，这个是古代的某个国王 加德满都街头到处都是摩托车，技术都很牛掰 11/18 博卡拉&emsp;&emsp;今天6点就起来收拾行李，然后下去吃早餐，吃的是酒店提供丰盛的自助餐。吃完就找巴士停靠点kanti path，这条路停的全都是巴士，太多了，至少有上百辆啊，我们的是baba adventure，最后等到8点多才发车，在加都还一路捡客，好坑。 &emsp;&emsp;从加都到博卡拉大部分都是山路，关键尼泊尔的基建很落后，路太差了，走到一半的时候，大塞车，塞了接近两个小时。我们被迫延误到3点多才吃午饭，饿死了，午餐车票包含的，在半路上的尼餐馆吃的美味自助餐。在车上还碰到去Poon Hill的美国母女，很好说话。 &emsp;&emsp;到博卡拉已经5点多了，一出车站又是被一群司机围住。随便找了一位，他把我们载到自己的家庭旅馆hotel Mandap，我们住的是800rs的双人间，各种条件非常棒啊，平均每人不到30rmb。房东还安排了明天去Naya Pul的车。我们这次去abc共6人，四女两男。我们两男不用背夫，四个妹子东西少，房东还帮忙找了个背夫，bing，五六十岁了，体能不大好，英语也不是太好。 &emsp;&emsp;晚上我们就到附近补充购买装备，几个妹纸几乎没有装备，基本都是在加都和博卡拉买齐的。然后就在lemon tree吃西餐，扒做得不错。这顿饭我们给了600rs的小费，太奢侈了，服务员和收费的分别给了300。 加都一路上的街景，杂乱无章的感觉 这是我们到达博卡拉后住的Hotel Mandap的双人间，条件非常棒，三面都有窗，不远处就是费瓦湖，才800rs。 11/19 - 11/24 ABC徒步 ABC徒步行程博卡拉出发Day 1 博卡拉坐车到Naya Pul, Naya Pul -&gt; Syauli Bazar(午饭) -&gt; GhandrukDay 2 Ghandruk -&gt; Komrong(午饭) -&gt; ChhomrongDay 3 Chhomrong -&gt; Bamboo(午饭) -&gt; DovanDay 4 Dovan -&gt; MBC(午饭) -&gt; ABCDay 5 ABC -&gt; Dovan(午饭) -&gt; ChhomrongDay 6 Chhomrong -&gt; kyume(午饭) -&gt; Siwai, Siwai 坐车回博卡拉 上面是我本次徒步的行程，下面是可以调整的部分： 其中Day 3比较轻松，可以到Dovan再吃午饭和住宿，也可以到Himalaya，然后第二天就会比较轻松。调整为：Day 3 Chhomrong -&gt; Dovan(午饭) -&gt; Himalaya 然后Day 5一路下坡，伤脚和膝盖，很辛苦，可以分两天走。调整为：Day 5 ABC -&gt; Himalaya(午饭) -&gt; Bamboo/Sinuwa在Jhinu 还可以泡天然的温泉，我们时间赶，没有去泡。 &emsp;&emsp;最后一天，其他攻略很多都是徒步回Nayal Pul，其实徒步到Siwai就可以了，这里是坐车最近的地点。因为后面一段路是没有什么风景的，也看不到雪山，基本都是土路。没必要浪费时间和体力去走，坐车回博卡拉就好。 &emsp;&emsp;我们本次行程没有走Poon Hill小环线，如果要走Poon Hill可以在Birethanti往左边的路走，强驴一天可以到达Ghorapani住宿，第二天看Poon Hill的日出，然后一天时间再赶到Chhomrong，接下来的路线和ABC一致，只相当于比ABC多一天的时间，但合理的安排是再多安排一天时间，这样不会太赶。Day 1 Naya Pul -&gt; Birethanti -&gt; GhorapaniDay 2 Ghorapani -&gt; Tadapani -&gt; ChhomrongDay 3 后面接着ABC的行程 Day 1 Ghandruk&emsp;&emsp;早上坐房东叫的车从博卡拉出发，汽车一路爬上山，然后又下到山谷，Naya Pul就在山谷里面。然后我们在Naya Pul开始负重出发，在Birethanti有检票点，先检查TIMS，过了桥还有个检查ACAP的点。背夫bing竟然没有相关的证件，被检票点的人员拦住不让过。如果没有背夫的话，那几个妹纸肯定是走不动ABC的，最后也不清楚是怎么弄的，折腾了好久，bing最后还是通过了检查点，但我们在这里浪费了至少1个多小时，这个导致我们今天走了一段夜路。 &emsp;&emsp;我们在Syauli Bazer吃午餐，这前面一段都是平坦的泥土路，灰尘大，也没有风景可看。午餐吃的是难吃的蛋炒饭，米太差了，饭完全没有粘性啊。 &emsp;&emsp;吃午饭休息了一会然后出发，后面就是一路的爬坡，经过Kimche，最后达到Ghandruk，背着三四十斤的包，好累。但从Syauli Bazer到Kimche一路都是很美的田园风光。山里面6点就天黑了，我们走夜路到7点多才到达Ghandruk，本来是想住snow land cottage，但去得太迟了，房子已经没有了。于是又往回走，找其他hotel，最后住的是位置超好的Ghandruk guest house。晚上有个妹子下厨做饭吃，鸡汤，西红柿炒蛋，青菜，红烧鸡肉。鸡肉不够，做的鸡汤味道很淡，但是能吃上中国菜还是很幸福的。 Nayal Pul起始点Naya Pul，一个不大的小镇，房子都比较破旧。 这是我们通过的第一个吊桥 Naya Pul路过一个小餐馆 Birethanti从这里开始进入安娜普尔纳保护区了 这是TIMS的检查点，在这里背夫bing被拦住不让通过。Mr Bing，你这是搞神马鬼，证件之类的都不齐全，还说已经走过ABC不下10次呢。 再过了一座桥后，这个就是ACAP的检查点，背夫bing在这里又被拦住了，不能通过。最后他们用尼泊尔语唧唧歪歪，打电话，折腾了好久，最后才放行。 我和zy两个人走错路了，原来这是去Poon Hill的路 从Birethanti到Syauli Bazar都是这样的泥土路，太阳炙烤，很热风景也很差，车一通过，灰尘满天。 快到Syauli Bazar的时候，终于看到雪山了，那是安娜普尔纳南峰 Syauli Bazar接近1点的时候到达Syauli Bazar，我们在路边的小店吃午饭 bing把我们的蛋炒饭端过来了，而背夫在这里是免费的。 厨房和小卖部就在这栋小房子里面 吃完饭我们走的是右边的小路，沿着这个河谷往上爬。 一路上是田园风光，很多花花草草 这些尼泊尔人的民宿种满了花草，房子也挺有情调的。 路的两边也全是花花草草，不是大冬天了嘛，怎么感觉像是春暖花开的季节呢 背夫bing背着妹纸们的两个大包，有五六十斤，他年纪大了，背得很辛苦。 我们又跨过一座吊桥 过了吊桥之后，开始很陡的上坡。 这前面的一段路都是很陡的石板台阶路，实际情况比照片显示的要难走多了。第一天还没有完全进入状态，运动量就那么大，走得好累。 从这后面开始，路没有那么陡了，人开始多了起来。不管遇到尼泊尔人还是外国驴友，我一路就是namaste问候过去 Kimchebing在前面带路，我跟着走，我们走的比较快。到达Kimche，在这里先等下后面的小伙伴们。 这个就是妹纸们的背夫bing 我们接着走到Kimche的这个旅馆，在这里休整了好久。 这时候天开始变黑了，但我们还在去Ghandruk的路上。 Ghandruk晚上7点到达Ghandruk，但我们走到最终山顶的旅馆又花了接近40多分钟，这最后一段夜路也是走得很崩溃。但我们住的这个旅馆还是很不错，在这里遇到了第一位国人，晚上我们自己下厨做饭吃。饭后，我们一边吃带来的零食一边喝茶，聊今天有多苦逼啊，聊自己之前的经历，巴拉巴拉。 晚上10点左右出去试拍星空，效果不是很好，本来想12点后出来再拍，但太冷起不来。 Day2 Chhomrong今天早上起床有点迟，尽管错过了日照金山，但风景还是非常美的。出门就是壮观的雪山，安娜普尔纳南峰(Annapurna south) 和鱼尾峰(Machhapuchhare)。我们就对着雪山吃早餐，怎一个爽字了得。 安纳普尔娜南峰和鱼尾峰 我们正对着安纳普尔娜山脉的南坡，左边是安娜普尔纳南峰，右边尖尖的山峰就是大名鼎鼎的鱼尾峰，这是我们第一次看到鱼尾峰，好兴奋。 安纳普尔娜南峰 鱼尾峰，尼泊尔语叫Machhapuchhare，海拔6993米，禁止攀登。从南坡看上去，两个山顶就像是分叉的鱼尾，知道它为啥叫鱼尾峰了吧。鱼尾峰是尼泊尔的圣山，地位类似于西藏的岗仁波齐峰。 旅馆前面的是种满鲜花的小花园，草地上有桌椅，远处是壮观的安娜普尔纳雪山。我特意要求在这个小花园中的桌子吃早餐。 土豆片，番茄，煎鸡蛋，面包，黄油，果酱还有奶茶，很标准的西式早餐。8点多的时候，太阳其实很晒，反正我是戴着帽子吃的早餐 我们今天的目的地是Chhomrong，看下面的图示，我们现在所在的地点- Ghandruk已经是在山顶了，然后要翻过前面两个山谷，两个垭口，两下两上，每个落差都有500米以上，非常的陡。然后还要再走一段路才能到达里面的一个山，chhomrong就在这个山的半山腰。对于全身负重的我和zy是个严峻的考验，爬上去非常累，然后下山又很伤脚和膝盖。 但从今天开始，远处的安娜普尔纳雪山一路伴随着我们。能欣赏到美丽的风景，不管多困难的路走起来都动力十足！我带着激动的心情向着安娜普尔纳的方向进发。 跨过第一个山谷后，我们向第一个垭口进发。我由于喉咙不舒服，早上吃了药，感觉全身不舒服，走走停停。 离鱼尾峰越来越近了。 爬完这个台阶，我们即将到达垭口 终于爬到垭口了，又渴又累，买了瓶冰镇的可乐犒劳自己。我们在这里休整了一会，zy这会在玩手机，我在山顶拍照。 前面就是陡峭的下坡，然后穿过山谷再爬上前面的高山。稍微欣慰的是，雪山也是越来越壮观了。 &emsp;&emsp;接着这个坡几乎是70读以上的，太陡了，我们小心翼翼的下坡。后面一段还有水，加上烂泥，到谷底的时候，我们的裤子和鞋子都变得脏兮兮的了。在谷底的时候，我们还遇到一对欧美的情侣在小溪边戏水，我过去打招呼，怎么感觉像英式的口音，就问他们是不是UK的，但他们却是希腊的。我们也是和他们挺有缘的，后面经常会碰到，他们休息时，我们超过他们，然后到我们休息的时候，他们就超过我们。 Komrong从坡下来，来到谷底，然后穿过Komrong之前的吊桥，到达Komrong。 &emsp;&emsp;到达Komrong，已经11点多了，我们就在这里吃午饭，Komrong就位于两座山之间的山谷。我们点的是青菜炒饭，本来是要等后面的四个妹纸和背夫的，饭都预定好了，但她们体能不好，走得很慢，赶不过来。我们只能把预定的饭取消了，休息了一会，然后又开始出发。 &emsp;&emsp;接着开始爬前面的山坡，这个坡也是超级陡啊。一个多小时后终于爬到顶了，让我们从垭口看看我们来时走过的路。中间就是河谷，底下就是我们吃饭的地方Komrong，对面最高处就是我们翻过的第一个垭口，对面的坡和我们这边的坡是一样的陡，一上一下，对负重的我们来说太累了。 在这个山顶的小店我又再喝了瓶芬达，然后休息了一会，后面仍然还很长的路。但我们已经走完了最艰难的路段，心情还是很happy的 &emsp;&emsp;到了下午之后，山里就开始起雾气了。在低海拔的山谷，因为山里水汽多的原因，每天的气候模式都是上午大晴天，下午是阴云，这下看不到雪山了。这后面一段基本都是平坦的土路，比较轻松，还有一条二哈和我们一起走了好远，就像帮我们带路似的。 Chhomrong&emsp;&emsp;4点多的时候，我们终于到达了Chhomrong，这家旅馆叫Excellent view top lodage and restaurant。果然是excellent view top，我们这家是位置最高的，前面还有两个大阳台，明天看日出一定很棒。然后我们就在等妹纸们和背夫，她们最终7点多才到达，背夫bing累得够呛的，年纪大了果然不行。 &emsp;&emsp;在这里我们也是告诫妹纸们，如果体能跟不上就下撤，还要跟我们走的话，就在这里寄存东西，轻装出发。因为体能不好，上下坡再加上走夜路，真的太危险了。这里有一对中国夫妇就是不想继续走了，直接下撤了。 &emsp;&emsp;但我们也是第一次走ABC，并不知道后面一段的路其实还是比较轻松的。 &emsp;&emsp;还有Chhomrong还是能吃到肉的，从这里进去之后就没有肉可吃了，禁荤。所以，小伙伴们在这里好好的享受肉食吧。 云雾太浓了，看不到雪山了，在阳台上遇到了一对韩国的恋人，聊了一会天。然后无聊没事做，那就拍拍旅馆的花草吧。 吃完饭，晚上8点多的时候，在二楼的阳台上试拍星空，然后睡觉。晚上还是太冷了，拍星空还是起不来啊。 Day 3 Dovan&emsp;&emsp;今天总算没有睡过头，终于拍到了日照金山。今天的行程比较轻松，除了一开始到Sinuwa这段要爬坡下坡。只走了半天就到达了目的地Doven，然后半天时间休息，是最悠闲的一天。 Chhromgrong的日照金山&emsp;&emsp;早上7点不到就起来拍日照金山了，并不是很美。 Sinuwa&emsp;&emsp;爬完第一个坡就到了Sinuwa，我们状态已经出来了，所以并不觉得多难。当然一路还是能看到雪山的，虽然距离是越来越近，但角度不是很好，反而没有昨天远距离的好看。 &emsp;&emsp;这个就是Sinuwa了，这里是在半山腰了，从这里开始要往下走了，雪山也渐渐被近处的山峰挡住了 走着走着，前面出现了有好多竹林，这也意味着我们离下一个休息点Bamboo很近了，Bamboo就是竹子的意思。 &emsp;&emsp;近距离观看鱼尾峰，那两个分叉的顶是不是非常像鱼尾呢，从这里看是最清楚不过了。 Bamboo&emsp;&emsp;我们大约11点到达Bamboo，就在这吃中饭了。因为热，胃口不是很好，我点了个鸡蛋蔬菜汤面，其实是方便面做的，但汤做得不错。因为从这里到目的地Dovan 最多1个多小时，所以我们可以在这里好好休息。徒步完脚好多汗，我们吃完午饭就集体晒太阳晒脚丫子。我对面的就是昨天遇到的国人，也在这里吃午饭，他是一个人走的ABC，后面还遇到一次。在这里我们又遇到了昨天那对希腊情侣。 Dovan&emsp;&emsp;我们两点左右到达Dovan，住的是Annapurna approach。今天真轻松，只走了半天，下午可以好好休息了，洗澡，洗袜子，洗衣服，然后就是看书晒太阳的时间。 &emsp;&emsp;我还花了300rs冲iPad 和单反电池，因为再往里面走就是MBC、ABC了，充电会更贵，而从这里开始手机也没有信号了。 &emsp;&emsp;晚上他们几个闲得蛋疼的，又是自己做饭吃，是zy做的，但是太辣，不是很喜欢，但总强过尼餐，不过这家店的披萨很好吃。吃完晚饭，在餐厅里面看2015就已经看过的电影《Chappie》。这个时候突然下雨了，那些还在外面晾衣服的孩子们这下就悲催了，还好我的衣物傍晚的时候已经提前收了。 没事，这雨也就晚上下，第二天又会是大晴天的。 Day 4 MBC、ABC&emsp;&emsp;因为昨天Bamboo吃的汤面给我们留下了很好的印象，所以今天早餐我们就集体预定了鸡蛋汤面再加momo。不过这个决定把我们坑惨了，因为今天上午运动量挺大的，早餐能量不足啊。吃完8点多，我和zy就先行出发了，从Dovan到Deurali一路上都是在峡谷下面走。两边陡峭的石山挡住了阳光，所以上午的时候，还是挺冷的，手套，抓绒帽子，厚衣服都要穿。 &emsp;&emsp;路上的时候我们遇到了来自新疆的君姐和同样来自深圳的阿柯，他们一起结伴，向导都被他们抛在后面了。abc路线成熟简单，完全不需要向导。君姐和阿柯和我们还有后话，我们也是多次偶遇，最后还一起下山，博卡拉也有碰头。 远处有房子的地方就是Himalaya，到这里后又和希腊小情侣打过招呼。 一路上是峡谷风光，峭壁上还有瀑布，是融化后的雪水流出来的，如果夏天的时候，瀑布一定很壮观吧。 Deurali&emsp;&emsp;Deurali就在峡谷的尽头，我们到达Deurali后，休息了一下，我又喝了瓶可乐。在这里我们遇到了一个刚从ABC下撤到这里的中国妹纸，早上10点不到就能走到这里，挺快嘛，ABC到这里距离还是有点远的。 离开Deurali后，雪山很快又出现在我们的视线里了，右边嵌在石山中间的就是是鱼尾峰，而在我们前方的是安娜普尔纳的主山脉。 休息的时候，顺便用登山杖摆个pose拍照 双鬼拍门，夹在中间的鱼尾峰，这个角度看上去挺不错的，多拍几张吧。 MBC&emsp;&emsp;早餐能量不够的后遗症开始起作用了，从Deurali出来没多久，就开始走不动了。方便面和momo还是不行，热量太低了。打这次之后，我对早餐再也不敢马虎应付了，一定要吃好吃饱。中午1点多的时候好不容易熬到MBC，赶紧点了份Dal Bhat。我们真是太饿了，虎吞狼咽，吃完再免费加饭菜，我和zy两个简直用一份的钱，吃了两份饭。 &emsp;&emsp;Dal Bhat 就是尼泊尔的手抓饭，有米饭，豆汤，薄煎饼，开胃小菜和蔬菜，配肉和蛋的比较贵点。但这里禁荤，别想吃到肉。而且Dal Bhat里面的饭，汤和蔬菜任加的，吃饱为止。尼泊尔人都是直接用右手抓饭吃，我们外国人就算了，好好用刀叉吧。 &emsp;&emsp;远处有房子的地方就是MBC (Machhapuchhare Base Camp，鱼尾峰大本营)。从这里开始体验360度雪山环绕的感觉，震撼的风景去除了我们的疲劳。 下面就是MBC四面八方的各个角度的壮观景色，MBC就坐落在鱼尾峰下面。 东边是俊俏的鱼尾峰 北面是Ganggapurna峰 南边就是我们徒步过来的方向，崎岖的小路就在两边耸立的峡谷中间 我们就在外面的平台吃午饭，这简直就是中国人专场。阿柯和君姐也在这，还有另外一男一女的两个国人，除了一个外国妹子，全都是中国人 &emsp;&emsp;吃完午饭，然后休息到2点左右，我和zy终于离开了MBC，开始向最终目的地ABC进发。2个小时左右的路程，不急，慢悠悠的走过去就行了，刚好可以看日落 &emsp;&emsp;走了一段路，首先映入眼帘的是安娜普尔纳南峰。看了这么多天的南坡，我们现在终于走到它的背面-北坡了。从这条路一直往里面走，再转过前面的弯，就差不多可以看到ABC了 &emsp;&emsp;走着走着，我们遇到了另一个同样来自深圳的妹纸K和她的尼泊尔背夫“拉杜”，还有君姐她们的尼泊尔向导“阿朔”。阿朔竟然和K一起走，把君姐她们都弄丢了，“阿朔”是k和向导起的中文名。拉杜的中文水平不错，还用微信呢。而阿朔一路跟着k学中文，也是醉了，而他的口头禅就是“啊呀妈呀”。 我们就这样一边聊一边走，当然这一路也有很多其他国家的驴友，但来走ABC的中国人真的很多。 &emsp;&emsp;不断的回头看鱼尾峰，虽然距离越来越远，却越来越壮观。因为我们往西走是一路的缓坡，越走越高，鱼尾峰就看到更多。同时前面的安娜普尔纳南峰也是越来越壮观。 k在拍鱼尾峰 就是前面这个弯了，往右转过去之后，ABC就近在咫尺了 这是看鱼尾峰最好的角度了，马上就要到ABC了。 ABC下午4点多的时候，终于到达了我们此行的目的地，安娜普尔纳大本营！！！ 来几张我胜利到达ABC的留念照 ABC的旅馆就在前面的一个小平台上，背靠着安娜普尔纳南峰。这里只有几家店，我们就选了最前面的一家，大厅正对着东边的鱼尾峰，看鱼尾峰日落是最好的位置。 &emsp;&emsp;平台西边不远处就是世界第十高峰，安娜普尔纳山脉的主峰，安娜普尔纳一号峰。它海拔8091米，高耸入云，但形状不够挺拔，看上去好像不是很高。所以一开始，人们以为鱼尾峰才是安娜普尔纳的主峰呢。安娜普尔纳峰是是最难攀登的山峰之一，有50多人在此遇难。 从ABC看鱼尾峰 坐落在壮观的安娜普尔纳主峰下面的大本营 从这个角度看鱼尾峰，近处是ABC的旅馆。 从旅馆后面出发，不用走多远就可以来到安娜普尔纳峰前面的冰川边缘，上面是飘飞的风马旗和一片遇难者的墓地。 安娜普尔纳峰的前面是冰川洗刷出来的巨坑。 在安娜普尔纳峰的冰川边缘往东看大本营和远处的鱼尾峰 几个欧美的驴友在这里搭帐篷 鱼尾峰峰顶的细节一览无余，有长焦就是好。 安娜普尔纳的日落&emsp;&emsp;四点半之后，光线开始变得柔和起来，先来看看安娜普尔纳的日落吧。因为我们在安娜普尔纳峰的东边，所以我们只看到峰顶的一点点光，前面是一片黑。还是等明天看安娜普尔纳的日出吧，日出角度非常好，一定很美。 鱼尾峰&emsp;&emsp;来看鱼尾峰的震撼日落吧，因为我们在鱼尾峰的西边，所以看日落的角度非常好，夕阳下的鱼尾峰太美了。 飘飞的风马旗映衬着雪山 穿上最保暖的衣服和抓绒帽，摆几个pose拍剪影，主要就是为了拍鱼尾峰，人是衬托 鱼尾峰的日落金山&emsp;&emsp;之前徒步路上的千辛万苦，在这一刻终于得到了的回报。这肯定是我一生中最难忘的时刻之一，最美最震撼的日落。有很多雷同的照片，但都很美，选择困难症，都放上来吧！ 这么美的景色，怎么能不摆几个pose呢。 &emsp;&emsp;ABC的海拔4200米左右，太阳下山之后，冷飕飕的，在外面呆久了，手脚都会冻僵。好多人都是一来就跑进旅馆的大厅里，弃外面大好景色不顾。但我们还是坚持看完整个日落才到大厅烤火吃饭。吃饭的时候，k，拉杜，阿朔，君姐，阿柯和我们6人加bing决定明天一起下撤。向导建议我们明天看完日出后就下撤到MBC吃早饭，因为ABC人太多，早餐上得很慢，然后一天赶到Chhromrong，我们都同意了这个计划。 &emsp;&emsp;晚上本来要去拍星空，但晚上至少是零下5度以下，太冷了。同时zy在七八点的时候也已经拍过星空了，所以我就直接回屋睡觉。 &emsp;&emsp;住宿条件那个差啊，男女混住，有人晚上打呼噜，还有磨牙的，加上全身是汗，没有刷牙洗脸，晚上睡得很不好。我后来半夜起来上厕所时，看到外面满天的星斗，真的太美了。 ABC的星空下面就是zy大神拍的ABC的星空，美爆了。 Day 5 Chhomrong&emsp;&emsp;今天要走很长的路，所以6点就起床收拾东西，然后看安纳普尔那峰的日照金山。看完马上就赶紧下撤到MBC，然后在MBC吃完早餐8点多。其中有个妹子，擅自脱离团队，自己一个人早餐也不吃就往前走，而且山上没有信号，联系不上，真是操碎了心。由于是原路返回，没啥心思拍照，一心往回赶，中午就到dovan 了，点了份披萨，太大一个人吃不完。然后在这个店还碰到两个香港来的妹子，聊了一会天，然后我们就接着出发。 &emsp;&emsp;最后爬Chromrong的那个坡时，我们都精疲力尽了，爬得好崩溃。因为我们到这里已经接近5点了，所以之前住的那家excellent view top已经满员了。于是我们就和k，君姐和阿珂一起在checkout pose 上面一点点的那家hotel住。今天走完后，脚趾摩擦鞋的地方火辣辣的，满身是汗，粘乎乎的，感紧洗热水澡，然后到大厅烤火等晚餐吃。今天下山的路程是之前上山的两天路程之和，虽说是下山，体力消耗没上山那么大，但腿和膝盖磨损更严重。在这里，我们回程的团队集合到一起了（我们6人加bing，阿柯，k，君姐，阿朔，拉杜）共12人。一路上还碰到好多来自中国的驴友，中国人真的好多啊。 安纳普尔娜的日照金山早上是看安娜普尔纳峰日照金山的好时机，这是ABC最美的日出了。 看完日出后，马上出发，让我们看看清晨中的鱼尾峰吧 Thank you for being together with you have a fantastic trekking. See you again.现在看到ABC标志牌的背面写的文字，有点伤感。fantastic trekking，不知什么时候还能再来，也许再也没有机会了。 最后回望一眼ABC和安娜普尔纳峰，再见ABC！ 这是在MBC吃早餐时看到的路线图，不错。 回程的风景&emsp;&emsp;回程路上，重温旧景。由于刚看完ABC震撼的美景，感觉其他风景就是渣渣了，所以看完一线天之后我干脆把单反放进包里，一心赶路。 这个就是一线天，来的时候没有注意到，现在补拍，之后就收起单反 &emsp;&emsp;Chhomrong这家店的餐桌很有特色，底下是火炉，一边烤火，一边吃晚餐，一边聊天，好欢乐。我点的是chicken sizzler，就是鸡腿扒再加沙拉，很美味。来到这里终于又开荤了，因为从chhomrong到ABC都是没有肉吃的。小伙伴们一开始不知道有肉吃，这时候都看着我啃鸡腿。明天早餐我又点了份法式蘑菇牛扒，小伙伴们都纷纷点扒吃，哈哈。 &emsp;&emsp;这里还碰到一个日美混血儿，jimmy，中文说的溜，还会写汉字，正在给长沙的中国朋友写明信片，叫我和k帮他修正，然后一边聊天。他去年存了好多钱，然后今年间隔年就离职出来旅游，已经7个月了。去过陕西、四川、湖南、云南等等，大半个中国啊！好多地方我们都没去过。他喜欢吃米饭，最喜欢吃鱼香肉丝，被朋友戏称饭桶。然后几天前来走ABC，他一天就从chhomrong到ABC，然后再一天回来，牛掰，今天晚上遇到我们。明天，他还要到雪山的另一边住帐篷。 Day 6 Siwai、博卡拉&emsp;&emsp;今天我们从比较好走的一条路回去，徒步到siwai，然后坐吉普车直接回博卡拉。从Chhomrong出发，经过new bridge，在kyume吃了个鸡蛋蔬菜面当午餐。反正很快就到回到博卡拉吃大餐，将就一下就好了。在kyume手机终于有了信号，顺便加了大家的微信，到时可以回博卡拉聚会。 &emsp;&emsp;两点不到就到了siwai，我们6人加k，bing，阿朔，刚好9人一车，共6000rs，到博卡拉要大概两小时。而君姐和阿柯坐稍后的bus回来。终于要从山卡拉出来了，大家兴致都很高，bing和阿朔唱起了尼泊尔歌曲。 &emsp;&emsp;回到之前住的hotel mandap的时候已经接近4点。回来第一件事就是洗热水澡，然后把这几天的美照发到朋友圈，我还把衣服洗了。都搞定完已经快6点了，然后出发吃晚饭。找一家中餐馆吃才是王道，詹大师这家火锅听说还不错，我们就打车过去。这家店的厨师是福建的，但火锅还不错，大家吃得好high。我们吃完晚餐，还不够尽兴，准备去附近的酒吧继续high，刚好被lemon tree对面酒吧里面的阿柯招呼上去，再加两个妹子和拉杜。也许是经过艰难的徒步后，疲惫的身心太想放松了，一边玩游戏一边喝酒，整个酒吧就我们这桌的玩的最high。外国人都很诧异的看着疯狂的我们，最后拉杜阿珂他们还跳起了舞，庆祝我们完成了ABC。喝到9点多，已经很头晕了，最后我和zy互相扶着回hotel mandap，倒头就睡。 安纳普尔娜最后的日照金山看最后一眼的雪山和日照金山，开始告别安娜普尔纳保护区了。 11／25 博卡拉&emsp;&emsp;昨晚喝了太多酒，不是很舒服，所以四五点就醒了，趟在床上，继续玩iPad，发朋友圈。本来今天准备去滑翔伞的，身体不是很舒服就作罢。但我和团队里的君姐一起订了滑翔伞，我订的是明天11点的，价格7500rs。 &emsp;&emsp;下午没事做，在君姐的推荐下，租了辆自行车，半天300rs，准备骑到费瓦湖另一边，然后爬到世界和平塔上面看博卡拉全景。我骑着租来的自行车回hotel休息了下，然后开始骑车去爬和平塔。骑过去接近1小时，爬山又1个小时。由于雾气太重，雪山不是很清晰，不然费瓦湖加上远处安娜普尔纳雪山，风景一定很壮观。既然天气不好，看了一会儿我就下山了，又骑车回城区，还过自行车已经接近傍晚6点。于是就在附近的兰花饭店吃中餐，苦瓜牛肉，加西红柿蛋汤，总共花了700多rs，好贵。从ABC回来还没有好好休息，所以不跟他们去酒吧了，还是回hotel 休息，上网，写日记，顺便买点果汁，饼干之类的回去当宵夜。 世界和平塔&emsp;&emsp;这个世界和平塔是日本人建的寺庙里面的一个塔。这里可以看到大半个的费瓦湖和远处的安娜普尔纳雪山，视角非常棒。 远处云层中隐隐约约的就是安娜普尔纳雪山 我们就住在对面的费瓦湖边上，这一片地区也是博卡拉规划比较好，干净整洁，比较有情调的，大部分游客也住在这里，老城区和加德满都一样很脏乱差。 11／26 博卡拉&emsp;&emsp;今天多云，雾气弥漫，天气太糟糕了，12点左右才开始出太阳。我预定11点开始的滑翔伞，只能推迟了，最后定在两点去滑翔。快两点的时候旅行代理开着摩托到hotel来接我过去填表单，准备滑翔，但填完之后，滑翔的教练还在睡觉，什么鬼，要我等大概三四十分钟。只能跟代理聊天，然后上网，补写前几天的日记。最后等到3点多，还没有找到教练，代理只能把我载到另一个地方，找了另外一个教练。 &emsp;&emsp;终于可以去滑翔了，坐了个面包车，向山顶进发。最后到了山顶的一个小山坡，教练开始安装滑翔伞，帮我穿装备，告诉我如何起飞。起飞是要拼命跑的，把伞拉起来，因为傍晚没什么风，飞得不高啊，所以我感觉不到刺激。同时太阳也快下山了，飞了20分钟不到，然后就在费瓦湖边降落，我的降落堪称完美，都夸very good。滑翔完然后就坐车回市区，把录制的视频和拍的照片导出来，刻了光碟，同时我还让他把视频相片拷到我的单反sd卡上。然后有个教练还用jeep把我送回mandap。 &emsp;&emsp;傍晚我和zy找了家中餐厅-和平饭店吃饭，吃完回来在hotel 订了明天回加都的车票，同时把这几天在hotel 相关的费用都结清。 &emsp;&emsp;晚上的时候那几个妹子又请我们出去聚一下，竟然又去詹大师吃火锅，已经吃的很饱了，我没怎么吃，然后就回去收拾东西，睡觉，不知她们还去哪里聚会。 费瓦湖上飞翔&emsp;&emsp;博卡拉最著名的就两个旅游项目，一个是ABC，另一个就是滑翔伞了。ABC走了，既然滑翔伞也这么出名，那也玩一把吧，翱翔天际想想都很刺激。而且价格才7500rs啊，这么良心，上哪找，国内没个1000rmb以上，别想飞。 小伙伴们一定还记得《等风来/up in the wind》这部电影吧，就是在博卡拉这里拍的 11／27 加德满都&emsp;&emsp;今天6点多起床，收拾东西，早餐则是hotel Mandap提供的。我，zy和zy的女同事今天要坐车回加都，那3个在机场遇到的妹纸则继续留在博卡拉多玩几天。早上我们一一告别之后，我们仨就坐的士到车站了。 &emsp;&emsp;我们回加都的tourist bus是holiday adventure，每人800rs。尼泊尔这边竟然是先到的坐后面，后到的坐前面，这么奇葩的规定。所以我们早到的就坐最后的位置，好坑。碰到一对中国的夫妇也坐后面，所以我们5人就坐最后一排，一路聊天。 &emsp;&emsp;今天是周日，本来以为会堵车，竟然非常顺利，木有堵车，我们后来才知道，尼泊尔周日是上班的，尼泊尔周五下午和周六才是放假的。中午我们吃的半路上的餐馆里面的自助餐，每人300rs，很不错。 &emsp;&emsp;回到加都已经接近5点，停车点距离我们之前住宿的Tibet guest house不远，用google maps导航，10多分钟就走到了。首先是取回之前寄存的包，但我们没有继续在这家hotel住，而是住在它旁边性价比更高的sunrise cottage，我和zy住1000rs 的双人间。但另一个妹子还是住之前的Tibet guest house，1000rs的单人间。在sunrise cottage还碰到几个在学习英语的国人，都呆了几个月了，估计是搞代购的。我们又在附近找了间中餐馆-齐鲁聚鑫源餐厅吃晚饭，味道还不错。 &emsp;&emsp;到现在兑的卢比都快用完了，明天兑钱，开始为EBC 做准备。晚上和那几个国人一起聊天，得到了一个重要信息，原来附近加都一号兑钱更实惠，而且也知道了买中国食品的地方，哈哈。 &emsp;&emsp;ABC的行程到此结束，接着就是EBC的行程，请继续关注我的EBC行程！ 喜马拉雅之旅（尼泊尔EBC篇）喜马拉雅之旅（尼泊尔EBC篇）","tags":[{"name":"旅游","slug":"旅游","permalink":"https://edwardzhong.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"尼泊尔","slug":"尼泊尔","permalink":"https://edwardzhong.github.io/tags/%E5%B0%BC%E6%B3%8A%E5%B0%94/"},{"name":"加德满都","slug":"加德满都","permalink":"https://edwardzhong.github.io/tags/%E5%8A%A0%E5%BE%B7%E6%BB%A1%E9%83%BD/"},{"name":"博卡拉","slug":"博卡拉","permalink":"https://edwardzhong.github.io/tags/%E5%8D%9A%E5%8D%A1%E6%8B%89/"},{"name":"abc","slug":"abc","permalink":"https://edwardzhong.github.io/tags/abc/"}]},{"title":"喜马拉雅之旅（西藏篇）","date":"2017-01-12T10:01:00.000Z","path":"2017/01/12/tibet/","text":"&emsp;&emsp;圣洁的雪山，壮观的冰川，是最激动人心的美景。而我对雪山不灭的情缘源于2014年3月的雨崩徒步，那是我第一次接触雪山。壮观的梅里雪山，蓝到极致的天空，飘飞的风马旗给我留下非常深刻的印象。于是有最高最壮观雪山的喜玛拉雅山脉成了我必去的下一个目标。毫无疑问，尼泊尔的EBC（珠峰大本营）是观赏震撼雪山冰川的最佳徒步路线。 &emsp;&emsp;2016年10月份开始打定主意，一定要走一趟最震撼的旅程，完成自己多年的心愿。因为很多事情在你年轻的时候不去做，也许以后你一辈子也不会再去做。 &emsp;&emsp;10月份到12月份是西北最美的季节，同时也是尼泊尔最适合徒步的季节。我一开始的计划是从西安出发，走河西走廊到北疆，再到南疆，然后走新藏线经过阿里，日喀则，到达拉萨，在拉萨办尼泊尔的签证，然后再陆路去尼泊尔，最终徒步EBC。路线和攻略我都准备的很详细了，但因各种不可控的原因，行程分为了两段，9月底10月初走了前半段西安-&gt;河西走廊-&gt;北疆（*寻找最美的秋天，丝绸之路北疆行*），然后赶回来上班。后半段就是本次的旅途，离职后11月份坐广州到拉萨的火车进藏，然后去尼泊尔。 &emsp;&emsp;来西藏本来纯粹是路过的，我最主要目的地是尼泊尔。因为从拉萨经吉隆口岸陆路去尼泊尔100rmb不到，但飞机至少要1000多rmb，本着花小钱办大事的原则，就坐火车来拉萨了。同时体验下青藏火车，还可以提前适应下高原，在拉萨还可以约到去尼泊尔的驴友，一举多得。 &emsp;&emsp;但11月7号来拉萨的第2天就接到先行出发去尼泊尔的驴友带来的噩耗，吉隆口岸突然关闭了，当时心里非常不甘心，计划就这样被突然打乱了。没办法只能多等几天再看看，但一直都没有音讯，那唯一的选择就是坐飞机过去，拉萨贡嘎机场到尼泊尔很贵，临时也买不到便宜的机票。综合考虑了下行程和价格，决定买11月16日到加德满都1900多的机票，我们不能再等下去。 &emsp;&emsp;本来在拉萨计划呆不超过4天的，一下子就呆了10天。以下就是我在西藏的行程，基本就是在拉萨逛寺庙和布达拉宫，中间去了下纳木错。蚂蜂窝链接-喜马拉雅之旅（西藏篇） 行程路线这是我本次旅行的总的行程和路线，而本篇游记和攻略只是西藏部分。穷游行程助手下的详细行程单尼泊尔部分请看：喜马拉雅之旅（尼泊尔ABC篇） 西藏的行程 时间 交通 地点 景点 住宿 2016/11/04 (Fri) 深圳-&gt;广州和谐号 07:45-09:50 广州-&gt;拉萨硬卧 11:45 - 武汉 火车 2016/11/05 (Sat) 格尔木 火车 2016/11/06 (Sun) 17:30 到达拉萨 拉萨 布达拉宫广场 西措青年旅社 2016/11/07 (Mon) 巴士 拉萨 药王山、布达拉宫广场、罗布林卡、色拉寺 西措青年旅社 2016/11/08 (Tue) 巴士 拉萨 八廓街、西藏博物馆 西措青年旅社 2016/11/09 (Wed) 巴士、包车 拉萨-&gt;纳木错 布达拉宫、念青唐古拉山、纳木错 民宿 2016/11/10 (Thu) 巴士 纳木错-&gt;拉萨 休息 西措青年旅社 2016/11/11 (Fri) 巴士 拉萨 拉萨河 西措青年旅社 2016/11/12 (Sat) 巴士 拉萨 哲蚌寺 西措青年旅社 2016/11/13 (Sun) 巴士 拉萨 色拉寺、色拉山 西措青年旅社 2016/11/14 (Mon) 巴士 拉萨 八廓街、光明港琼甜茶馆 西措青年旅社 2016/11/15 (Tue) 巴士 拉萨 拉萨太阳岛 西措青年旅社 2016/11/16 (Wed) 巴士、拉萨-&gt;加德满都飞机 11:35 - 10:10 拉萨-&gt;加德满都 加德满都 民宿 Day 1-3 来西藏的路上&emsp;&emsp;因为深圳没有直达拉萨的火车，所以要从深圳坐动车到广州，再从广州坐火车到拉萨，这趟列车可以说是经过了大半个中国。到了广州后再解决早餐和午餐，因为中午才出发去拉萨。50多个小时，3天两夜的时间，为了熬过这段无聊的时光我准备了零食，充电宝和书籍。和火车上的小伙伴聊天打牌也是打发时间的好方式，觉真的是睡够了。 &emsp;&emsp;一路上风景也没啥好看的，但从西安开始风景就开始不错了，下面这些是经过陇山的风景，大西北的山果然是不同。 &emsp;&emsp;11月5日晚上到达西宁的时候，开始换乘青藏线的内燃机的列车，有供氧设备，内部装修也好很多 青藏高原&emsp;&emsp;我们的列车是晚上到达格尔木，停了半个小时后，然后开始向西藏进发。有点可惜的是过唐古拉山口是晚上睡觉的时候过去的，所以前半段的壮观风景没有看到。 &emsp;&emsp;11月6日的早早就爬起来到餐车吃了个丰盛的早餐。然后就一直呆在窗前，一路欣赏壮观的雪域高原 &emsp;&emsp;到安多的这一段路还是很多河流湖泊的，上面都有很多的浮冰，蓝色的天空布满了飘逸的云。 &emsp;&emsp;中午的时候经过纳木错，水非常清澈，蓝色的湖面，蓝色的天空，真是水天一色。远处的则是白雪皑皑的念青唐古拉山，湖的前面是大草原，非常美。 &emsp;&emsp;看完纳木错，很快就开始欣赏念青唐古拉雪山，因为青藏高原已经海拔4000米，所以很多雪山看上去不是很高。而旁边就是广袤的羌塘大草原，开始时不时看到一群群的牛羊。 过了当雄，很快就要到拉萨了，一路上市镇和村庄也开始多了起来。 布达拉宫广场&emsp;&emsp;傍晚5点半左右到达拉萨，然后坐了个公交到西措青年旅舍，因为这里到拉萨主要的景点都很近，尤其是步行15分钟不到就可以到布达拉宫。到青旅安顿好了之后，马上就去布达拉宫广场，我觉得拉萨最美最壮观的景点就是布达拉宫，在拉萨的日子里，布达拉宫广场及附近我几乎每天都会去转一下。大气的布达拉宫 &emsp;&emsp;布达拉宫的对面就是西藏和平解放纪念碑 Day 4 拉萨布达拉宫日出 &emsp;&emsp;今天一大早就爬起来，去药王山拍布宫的日出，拉萨早晚温差大，很冷。为了拍50元人民币的背景，我也是忍了。布达拉宫洒满金色的阳光那一刻，真美。拍完然后就在药王山附近吃藏餐，一壶酥油茶加一份藏面，感觉还行。 罗布林卡&emsp;&emsp;吃完早餐，然后就去游览罗布林卡，罗布林卡是藏式的园林，是历代“达赖”的夏宫。里面有很多花草树木，有好几处宫殿（颇章）。都说夏季来是最美的，会有很多花花草草，但我更喜欢这个时候的罗布林卡。蓝色的天空，黄绿相间的植被，配上藏式颜色鲜艳的建筑，一幅色彩饱满的画卷，非常的美 满地的金黄的落叶，树上一样也是金黄的叶子，秋天的景色。为了拍出完美的效果，蹲地上拍落叶拍了好久 这一大片的树林，看着很像是胡杨林的样子。 在藏语里面颇章就是宫殿的意思。 白色一般是寺庙，红黄色的一般是宫殿？是这样区分的吗？ 色拉寺&emsp;&emsp;逛完罗布林卡已经是中午了，然后就在罗布林卡附近的四川面馆吃了个面，接着做公交直接到色拉寺。色拉寺是拉萨“三大寺”之一，其中最出名的就是辩经了，每天下午3点都会在辩经场举行。到达色拉寺已经快3点，先在里面逛了一会，然后就去辩经场看辩经，我倒觉得没啥意思，看了十几分钟就出来了。 &emsp;&emsp;喇嘛们正在辩经，辩经场周围全是游客。外国人到西藏要有特殊许可，本来以为外国人在西藏很少，但在这里有很多欧美游客啊。辩经的时候是不许用相机拍照的，但用手机或iPad却没问题，比较奇葩的规定。 宗角禄康公园&emsp;&emsp;从色拉寺坐公交回到布达拉宫附近，然后去宗角禄康公园看布达拉宫的后面的风景，同时公园里面还有湖，可以拍到布宫的倒影。到7点多吃了晚饭才回去青旅，今天逛了好多景点，行程非常紧。因为按原计划，我只在拉萨呆两天，所以要把几个主要景点都逛完 Day 5 拉萨&emsp;&emsp;今天我从口岸返回的驴友得知吉隆口岸关闭的坏消息，不知道会不会一直关闭到明年。我的尼泊尔徒步计划一下被打乱了。本来是明天就去尼泊尔的，现在只能再等几天看看口岸是什么情况。 &emsp;&emsp;同时今天碰到了zy和两个妹子，他们也准备从吉隆口岸去尼泊尔EBC，所以我们互相留了微信，看看口岸什么情况，有机会的话，一起去EBC。他们是兜峰户外公司的，zy是专业的领队，这次是专门过去探路的，同时还去ABC。我仔细询问了她们的准备和计划，EBC路线和我一致，最后我决定和他们一起走，同时把ABC也走了。 大昭寺广场&emsp;&emsp;今天很早就跑去八廓街，准备游玩大昭寺。大昭寺就是拉萨的中心，在藏传佛教中地位非常显赫。先在附近的德克士吃了早餐，拉萨是没麦当劳和肯德基的。藏民们绕着大昭寺转圈，然后在广场上非常虔诚的跪拜，来做早朝的藏民非常多。我对藏传佛教和寺庙不是很感兴趣，加上这么多人，于是放弃了游览大昭寺的打算。 我一开始也是跟着藏民们围着大昭寺转了一圈，然后到附近的八廓街逛了一会。 西藏博物馆&emsp;&emsp;从八廓街回来后，就去西藏博物馆，里面看了大概1个多小时，然后就出来了。 拉萨街头&emsp;&emsp;拉萨不愧是日光之城，天空太蓝，阳光太灿烂了。 布达拉宫夜景&emsp;&emsp;今天下午是在青旅休息上网，感觉有点无聊，晚上顺便去拍布达拉宫的夜景。 Day 6 拉萨、纳木错&emsp;&emsp;因为去尼泊尔的口岸还不清楚是否能通过，所以决定在拉萨多呆几天看是什么情况。那我顺便就和青旅的小伙伴一起去纳木错游玩了。今天上午先约了个小伙伴一起去布达拉宫，下午再出发去纳木错，明天中午的时候回拉萨。 参观布达拉宫&emsp;&emsp;布宫一开始是藏王的宫殿，西藏政教合一后就变成了历代达赖施政的地方。布达拉宫的外景非常壮观，但大部分的宫殿寺庙内景我都不喜欢，总觉得里面采光不好，色调灰暗，都很阴森。里面都是佛像，宝塔，喇嘛之类的，宫殿里面是不让拍照的。现在是淡季，所以不用提前预约，为了更好的了解布达拉宫的文物和历史，我们几个人合伙请了个向导，每人50。 &emsp;&emsp;参观布达拉宫其实就跟爬山一样，一路都是台阶啊！听导游说，有些不适应的游客爬着爬着就高反了。所以之前旺季的时候，爬到中间一个点才开始买票的，如果爬到买票点，爬不动可以下撤，之前一段就是免费的了。 &emsp;&emsp;从这里开始进入宫殿了，进去后就不能再拍照了，这外面还有全世界落差最高的厕所，我们体验了一把后就进宫殿了。 念青唐古拉山口&emsp;&emsp;我们游完布宫已经12点，马上吃了几个包子就坐车出发去纳木错，去纳木错要五六个小时。中间还在念青唐古拉山口拍照。 那根拉山口&emsp;&emsp;那根拉山口，海拔有5190米，而拉萨的海拔才3600米。所以通过这里的时候，我感觉头有点晕，不是很舒服，第一次体验这么高的海拔。山口风很大，也非常冷，下车拍了几张照片，赶紧上车。过了山口后就能看到纳木错了，一路上的风景非常棒。 纳木错日落&emsp;&emsp;到达最终目的地后，已经6点多，只能看落日了，所以一天去纳木错感觉不值，都没怎么看湖就天黑了。但是日落非常美，小伙伴们一直在跳，这么高海拔稍微运动一下就累到闯不过气来。还算拍了很多满意的剪影效果。 小伙伴们玩得很High的剪影 7点多往回走的时候，回头一看，火红的落日的余晖，又是一阵狂拍，风景的剪影一样很美。 纳木错星空&emsp;&emsp;我们住宿地有海拔4700多米，晚上非常冷，但我还要和小伙伴一起去湖边拍星空，晚上10点多拍了下星空，月亮很亮，周围也有光污染，效果并不好。而且晚上很多野狗，吓得心惊胆战的，于是赶紧收拾家伙回去烤火。两三点我们又爬起来到旅馆附近拍星空，还是很差的效果，加上真的太冷了，滚回去继续睡觉。同车过来的还有几个高反了，我还好。还有多走一段路之后，会气喘吁吁的，晚上睡觉很冷，但是有电热毯，还算没冻着。 Day 7 纳木错、拉萨&emsp;&emsp;今天7点钟就起床出发了，早餐就吃带来的零食。坐车去看纳木错日出，看完就回拉萨。 纳木错日出&emsp;&emsp;早上非常冷，因为西藏早晚温差特别大，加上风又大。好不容易熬到太阳出来，拍完日出后，感觉手脚都快冻僵了。回到拉萨已经中午1点多，我们几个人一起点外卖吃。我总感觉这样过去纳木错不值，都没怎么看湖，傍晚已经天黑，错过了拍照时间，能在那多留半天的话会比较划算。下午就是洗澡洗衣服，休息，然后晚上一样在大厅一起看电影。 Day 8 拉萨&emsp;&emsp;今天啥事都没，睡懒觉，大部分时间都在青旅呆着。对陆路通过吉隆口岸也不再抱幻想了，于是决定坐飞机过去，订了16日的机票，1900多，跟四五千的机票比起来，还可以接受。这同时也意味着还要在拉萨再多呆5天的时间。 拉萨河&emsp;&emsp;傍晚的时候就在拉萨市区乱逛，拉萨市区干净整洁，规划的挺不错。不过气候干燥，所以灰尘比较多，这里大部分人都是戴口罩头巾的，白天阳光也很刺眼，所以帽子太阳镜也是必备的。一直逛到拉萨河边，拉萨几乎没有什么工业，所以河水很清澈。 Day 9 拉萨&emsp;&emsp;还要在拉萨呆4天，天天呆青旅太无聊，所以没事还是把拉萨主要的景点都逛完吧。今天我和青旅的4个小伙伴一起去哲蚌寺，坐公交过去时已经11点多了，打算逛完就去吃午饭。哲蚌寺建在半山腰，我们从公交站到最终点走了差不多1个小时，而且因为高海拔，一直往上爬也挺累的。两个妹子到哲蚌寺门口就爬不动了，所以她们根本就没逛寺庙，最后我们两个男的还是爬到哲蚌寺最高点了。爬山登高望远是我的最爱。也可以当成是去EBC徒步的拉练了，提前适应高海拔爬山。 哲蚌寺&emsp;&emsp;拉萨这边的山全都是光秃秃，一眼看过去全是泥土和石块。但是当你走近看，其实也是有稀疏的草的，不过都是枯黄的。哲蚌寺是拉萨的“三大寺”之一，也是拉萨最大的寺庙，一大片的建筑。 &emsp;&emsp;进了大门之后，我们是沿着左边的台阶一路往上爬的，因为我看到了有个顶，就在佛像过后的小山顶，视角一定很棒。 这是画有佛像的大石块，后面还有一段路才到观景台。 终于爬到顶了 &emsp;&emsp;这是我爬到最高点往下拍的照片，这个点就在最高点的佛像上面的观景台。这里视角很棒，拉萨市区的西边几乎都能看到。但体能不好和对高海拔不适应的，慢慢爬吧。看上去不高，所以我一口气就爬到顶，累得要死，还是不能和之前低海拔地区爬山比啊。 然后再往东边穿过小山谷，又到另一边的半山腰，能更清楚的看清寺庙的整体。 从半山腰看寺庙的大殿 这是东边半山腰的画有彩色符文的石块。 东边看寺庙的全景 从高处看够了寺庙，我们才从山上下来，走进迷宫一样的寺庙群里面去，主要是参观了大殿，然后还爬上大殿顶上去了。 &emsp;&emsp;今天就是爬爬爬，中午1点多才出来，高海拔，稍微运动下就闯不过气来。回去青旅已经两点多了，又是去附近的川菜馆吃饭，另一个小伙伴已经累得够呛，也没什么胃口吃饭。但我运动后胃口很好，运动强度也可以接受，我之前为了这次旅程经常跑步拉练体能有很大关系。 Day 10 拉萨&emsp;&emsp;今天也是睡懒觉，对拉萨的寺庙我都提不起兴趣了，下午约定和zy去爬色拉山拉练。色拉山就是色拉寺后面的山，海拔超过4000米，而拉萨的海拔是3600米。入口是要先从色拉寺大门进去的，然后左边的墙边是有一条上山的路的，我们一开始不知道，找了好久。 &emsp;&emsp;下午三点坐公交到色拉寺，4点左右才找到路开始爬。我们两个真是作死，为了抄近道，从最陡的地方往上爬。爬到后面，每走一步都气喘吁吁，我们最后爬上山顶下面一点点的小寺庙，山顶确实太陡，而且天快黑了，于是就下山了，真的好累啊。回去青旅已经快8点，又是在附近的川菜馆点菜吃饭，然后买了几瓶啤酒和下酒的卤菜回到青旅一边看电影，一边吃。 &emsp;&emsp;大半个拉萨市区都能看到哇，远处山顶有白色的小山就是布达拉宫，旁边的小山就是药王山，看到了没。中间的是带有足球场的体育馆，这么高的海拔还踢足球，不累个半死啊！看到了拉萨市区全景，这累也是值的。 下到山脚的时候，天已经黑了 Day 11 拉萨&emsp;&emsp;今天就好好休息，因为昨天爬山拉练了。也不想去看什么景点，我的心已经在尼泊尔了。到下午觉得还是太无聊，于是就跑去大昭寺广场晒太阳，然后去试一下出名的光明茶馆，吃了份藏面，一碗甜茶，甜茶才8毛，味道很淡，觉得一般，然后回青旅休息。 大昭寺广场这个时候大家都是穿着厚衣服出来晒太阳啊，下午人不是很多。 超级月亮&emsp;&emsp;今天晚上有节目，看中国对卡塔尔的十强赛，里皮上任后中国队还是有改观的，但就是不进球啊！今晚还有几十年一遇的超级月亮，虽然晚上很冷，但还是按捺不住，和zy背着脚架和单反出去拍夜景和月亮。 这是布达拉宫东边的街道，空无一人，只有我们两个在拍夜景。 宗角禄康公园的佛塔 布达拉宫前面的塔 超级月亮 Day 12 拉萨&emsp;&emsp;今天是在拉萨的最后一天，主要就是准备物资，药品，老干妈，糖果，果汁冲剂，各种在尼泊尔买不到的东西。下午我还去了下拉萨的太阳岛走了一下，然后再看最后一次的布达拉宫。明天我们就要到贡嘎机场坐飞机去尼泊尔的加德满都了，第一次踏出国门。 &emsp;&emsp;再见拉萨！再见西藏！再见祖国！ 喜马拉雅之旅（尼泊尔ABC篇）","tags":[{"name":"旅游","slug":"旅游","permalink":"https://edwardzhong.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"西藏","slug":"西藏","permalink":"https://edwardzhong.github.io/tags/%E8%A5%BF%E8%97%8F/"},{"name":"拉萨","slug":"拉萨","permalink":"https://edwardzhong.github.io/tags/%E6%8B%89%E8%90%A8/"},{"name":"纳木错","slug":"纳木错","permalink":"https://edwardzhong.github.io/tags/%E7%BA%B3%E6%9C%A8%E9%94%99/"}]},{"title":"寻找最美的秋天，丝绸之路北疆行","date":"2017-01-04T08:29:39.000Z","path":"2017/01/04/xinjiang/","text":"&emsp;&emsp;从千年古都西安出发，经过甘肃的河西走廊，最后到达新疆，也就是丝绸之路。这是一条我梦寐以求的路线，在酝酿了两年之久后，2016年9月24日，背着大包，独自一人，踏上了征程。 &emsp;&emsp;丝绸之路，苍茫西北，你会联想到什么？我首先想到的是，大漠孤烟，落日孤城，遥远的边疆，辽阔的国土；东西往来的商旅，追求功名的冒险家，出征塞外的将士。丝绸之路就是结合了悠久的历史，丰富的人文和壮阔的风景的一条路线。在古都西安体验当年的秦汉雄风，隋唐盛世和西北美食；进入河西走廊欣赏雄伟的祁连山，广袤的大戈壁；去张掖看那令人难忘的七彩丹霞和马蹄寺；然后登上长城的最西端，天下第一雄关-嘉峪关，观看晚霞；在敦煌欣赏沙漠奇观-鸣沙山月牙泉；当然还有艺术瑰宝莫高窟，一定要了解它让人心碎的历史。 &emsp;&emsp;到达西域，然后一路向北经过北疆一个个现代化的城镇，石河子，奎屯，克拉玛依，布尔津，来到神的后花园-喀纳斯，这里有着最美的秋色；最后到吐鲁番欣赏夕阳西下的交河故城。 *[蚂蜂窝链接-寻找最美的秋天，丝绸之路北疆行](http://www.mafengwo.cn/i/6543248.html)* 行程路线穷游行程助手下的详细行程单 时间 交通 地点 景点 住宿 2016/09/24 (Sat) 深圳-&gt;武汉高铁 G1004 08:26-13:21 武汉-&gt;西安高铁 G836 15:46-20:20 深圳-&gt;武汉-&gt;西安 西安故里驴友驿站 2016/09/25 (Sun) 西安-&gt;兰州硬卧K177 22:34-07:30 西安 秦始皇兵马俑、西安钟楼、回民街、西安古城墙、樊记腊汁肉夹馍、陕西历史博物馆 火车 2016/09/26 (Mon) 兰州-&gt;张掖 天津航空GS7647 14:55-15:50 兰州-&gt;张掖 中山桥、马子禄牛肉面 张掖七彩丹霞国际青旅 2016/09/27 (Tue) 巴士、打的 张掖 马蹄寺、张掖丹霞国家地质公园 张掖七彩丹霞国际青旅 2016/09/28 (Wed) 张掖-&gt;嘉峪关 火车 D2741 10:32-&gt;11:52 张掖-&gt;嘉峪关 嘉峪关 客栈 2016/09/29 (Thu) 嘉峪关-&gt;敦煌 火车 06:44-&gt;11:30 嘉峪关-&gt;敦煌 鸣沙山、月牙泉 敦煌沙州驿国际青旅 2016/09/30 (Fri) 敦煌-&gt;柳园 中巴 19:30-&gt;21:30 柳园-&gt;乌鲁木齐火车硬卧 23:56-&gt; 敦煌、柳园 莫高窟 火车 2016/10/01 (Sat) 柳园-&gt;乌鲁木齐火车硬卧 -&gt;7:40 乌鲁木齐 大巴扎、红山公园、新疆博物馆 酒店 2016/10/02 (Sun) 大巴 克拉玛依 克拉玛依魔鬼城 酒店 2016/10/03 (Mon) 大巴 布尔津 布尔津夜市 酒店 2016/10/04 (Tue) 大巴 喀纳斯 喀纳斯湖、月亮湾、卧龙湾、神仙湾 哈萨克民宿 2016/10/05 (Wed) 大巴 禾木 禾木草原、禾木桥 哈萨克民宿 2016/10/06 (Thu) 大巴 布尔津-&gt;富蕴 五彩滩、贾登峪国家森林公园、可可托海 酒店 2016/10/07 (Fri) 大巴 富蕴-&gt;乌鲁木齐 新疆博物馆 那里青年旅社 2016/10/08 (Sat) 乌鲁木齐-&gt;吐鲁番火车硬座 11:00-&gt;13:15 乌鲁木齐-&gt;吐鲁番 坎儿井民俗园、交河故城 达卜国际青旅 2016/10/09 (Sun) 吐鲁番-&gt;乌鲁木齐大巴 10:20-&gt;13:20 吐鲁番-&gt;乌鲁木齐 市区逛吃 白桦林国际青旅 2016/10/10 (Mon) 乌鲁木齐-&gt;深圳飞机 cz3436 09:55-&gt;16:40 乌鲁木齐-&gt;深圳 回家 09/24 深圳到西安&emsp;&emsp;一大早坐地铁到深圳北站，深圳到武汉的高铁8点20出发，5个小时后到达武汉刚好13点20，高铁就是准点，特意在武汉休息一下，吃午餐，这样就不用一直坐火车太累。武汉到西安的高铁是15点四十多发车，所以在武汉其实哪也去不了，只能坐地铁随便到附近一个站点，在路边某个小吃店点了份热干面就当午餐吃，然后回高铁站，稍微等了一会，很快就出发去西安。 &emsp;&emsp;原来武汉到西安的高铁还要经过郑州的，路过河南，感觉中原一带真的是无边无际的大平原，连个小山坡都看不到。我在想，古代突破长城一线的游牧民族，面对这样的地形，真的很容易就长驱直入，一波推到江淮地区。 &emsp;&emsp;晚上8点半到达西安，出发前几天在booking预定了离西安北最近的青旅。但这个青旅在纸坊村也太偏了点，坐地铁到达安远门，但是怎么也找不到去纸坊村的公交，不得已打了个摩托5元。那地方到处都修路神马的，也找不到去青旅的路，好在老板娘出来带路，总算安顿下来了。我住的是混合宿舍，好清淡，只有我一个人，毕竟国庆前，还没到高峰期，本来我还想凑几个人一起明天的行程的。晚上就和老板娘讨教附近的公交怎么走，最方便的是老板娘有个公交卡给我用。这样明天就不用备零钱，方便多了，而且西安的公交真便宜，市区都是一元。准备好行程，冲凉后也11点多了，马上睡觉，明天早上要7点起床呢！ 09/25 西安&emsp;&emsp;来到千年古都西安，最想看的就是兵马俑，所以第一站就去临潼，临潼还可以去骊山，华清池，兵马俑。但我时间紧，只在西安呆一天，这次就只去兵马俑。先公交到火车站，然后坐306直到兵马俑，8元，我过去9点多一点，门票150，觉得挺贵的。三个坑都看了，第一个坑比较壮观。我是蹭别个团的讲解员和导游，因为人很多，所以个人去的话，不推荐雇讲解员。 西安火车站 **秦始皇陵兵马俑** **西安古城墙** &emsp;&emsp;转完三个坑，已经11点多了，赶紧坐车回市区，我还要吃肉夹馍呢。看攻略说樊记腊汁肉夹馍最正宗，左弯右拐的，过去都2点了，叫了个精选的馍再加个黄酒，还不错。但我是吃不大出比普通馍好在哪？感觉和深圳吃的馍差别不大啊 &emsp;&emsp;下一站，陕西历史博物馆，青旅叔叔的强力推荐去，3点之前到，然后拿身份证领免费票，人还真多呀。不过里面好多国宝，从史前到宋元明。当然了最重点的就是大秦帝国，大汉雄风，大唐盛世，这些古迹文物，没有讲解的话，我估计什么也看不出来。还是老办法，蹭讲解导游，看完后大概四点多，肚子有点饿，走的也特累，附近的大雁塔也不想去了。陕西历史博物馆 &emsp;&emsp;接着坐公交到回民街逛逛，说实话不喜欢，人多嘈杂，感觉很乌烟瘴气，只去吃了贾三灌汤包。马上坐车回火车站，但一路堵车啊，到火车站也六点多了，接着还要再坐公交回青旅，随便吃了个粉，回去已经7点多了，在青旅和新来的驴友吹一下水，马上又赶到火车站。晚上10点半的卧铺，到兰州是第二天早上7点，晚上火车晃的好厉害，老感觉要掉下去，晚上就是半模糊半清醒中度过。 09/26 兰州 张掖&emsp;&emsp;一大早就被乘务员叫醒，不是7点多才到的么，6点就已经提前到兰州了。还没睡醒就急急忙忙下车了，只能到火车站里的厕所刷牙洗脸。来了兰州，怎么能不吃牛肉面呢，于是在附近的马子禄牛肉馆吃早餐，加牛肉一共17，我还是不觉得有多好吃。早餐过后，才7点多，而去机场的高铁是中午接近12点。另外说一下，兰州的中川机场是离市区最远的机场了，所以必须要高铁过去，四十多分钟。这段时间坐个公交到黄河边转转，顺便把西安带过的水果解决掉。还有中午也吃的牛肉面，现在看到牛肉面都像吐。吃完马上坐高铁去机场。黄河边、中山桥 &emsp;&emsp;由于到机场时间紧，来不及托运，我的瑞士军刀被没收了，心痛！飞机一个小时不到就到张掖，拼了个的50元的的士直接到七彩丹霞青旅，也是淡季没什么人，一个人住6人间，没有人一起拼车去景点，真是痛苦，怎么办？乘飞机去张掖 **七彩丹霞国际青旅** **这首诗很有文艺气息** 09/27 张掖&emsp;&emsp;开始进入了丝绸之路的河西走廊，其实河西走廊应该从武威开始，但武威没啥风景，所以略过。张掖在汉武帝时建立，古时也称甘州，甘肃的甘就是指这里。这里最著名的人物莫过于霍去病了，很多景点都会提到这位少年英雄。 &emsp;&emsp;张掖是我很喜欢的一个地方，挺小挺干净的小城，旅游资源很丰富，祁连山，七彩丹霞，马蹄寺，山丹军马场，七一冰川，冰沟丹霞等，最出名的就是七彩丹霞了。因为这个景点，几年前张掖开始名声鹊起，但我最喜欢的是祁连山，雪山才是我的最爱。 &emsp;&emsp;还有进入甘肃后，气候开始变得很干燥，温差也大，基本只有面食，分量大，但是面很硬，所以刚来特别不习惯。张掖这边臊面，搓鱼，卷子鸡是特色。我喜欢这里的早餐，臊面和包子，分量特足还很好吃，早餐吃的好饱。 &emsp;&emsp;今天天气真好，大雨过后，阳光灿烂，空气清新。由于昨晚没约到人，只能一个人坐车去马蹄寺，看时间允许的话，再去七彩丹霞。7点不到就爬起来，坐车去汽车南站，但是今天没有去马蹄寺的专线，只能做到马蹄河的车，再打车去马蹄寺。刚好碰到也去马蹄寺的深圳哥richard。于是约定马蹄河一起打车，在车上又碰到北京的夫妇peter和julie，我们今天欢快的行程开始了。在马蹄河，julia和peter讲好价，就拼车出发，平均下来，每人10元不到。路上一开聊，我和北京夫妇都要下午去七彩丹霞，于是师傅提议顺便把我们送回市区，下午再载我们过去七彩丹霞看日落，晚上又送我们回市区，挺划算，关键省了很多麻烦，我们三就接受了这个方案。到马蹄河路上的风景 &emsp;&emsp;到马蹄寺景区，我们来得正是时候，淡季，人很少。门票是36，因为里面的三十三洞窟其实不怎么样，所以没买洞窟的票。司机送我们到祁连山脚下景点处，和我们约好出去的时间。我们就开始拍照欣赏美景，景区也就十几个人，到里面只有我们四个小伙伴了。蓝天白云，黄草红花，还有远处壮观的祁连山，峰顶终年积雪，太美了。马蹄寺 **远处的三十三洞窟** &emsp;&emsp;今天上午天气特别好，当我们逛完，天就开始阴云，山顶的白雪都看不到了，非常幸运。我们一路往回走，一边聊天，同时联系司机载我们到门口，去逛下千佛洞，听说这是全国最大的悬空石窟寺庙，挺不错，但我们都对风景比较感兴趣，一会就出来了，准备回市区吃午饭。千佛洞 **我们的合照** &emsp;&emsp;中午回市区大佛寺附近找张掖特色美食，由于richard 来张掖很多次了，带我们到处找吃的，但这边，到两三点就下班，店铺下班是什么鬼？于是在西关市场吃了个吴记搓鱼，对身为南方人，觉得还没饭好吃。下午我们三个人去七彩丹霞，明天我们三都是去西边，我去嘉峪关，julia和peter去敦煌，而richard下午则要往东走，下一站去武威。吃完饭后，我们三个依依不舍的告别了richard。 &emsp;&emsp;这边早晚温差大，这会三四点，阳光很猛，只能穿一件T恤。我们吃完中饭，到附近大佛寺外面看了几眼，因为要门票，而且时间紧，所以没进去。在附近稍微休息了一会，司机已经提前四点来接我们，因为师傅认为太迟去，可能买不到门票。一个多小时后，到达七彩丹霞，但这时候乌云密布，看不到太阳，真糟糕。75的门票有点贵，第一个观景台最壮观，而这个时候难得出太阳了，景色真是壮观。但很快又乌云密布，我们略过第五观景台，直接去第四观景台，还好也出了下太阳，看了下热气球，赶紧出来。气势磅礴的七彩丹霞 &emsp;&emsp;然后回市区吃晚饭，richard 推荐我们吃卷子鸡，我超不习惯，觉得难吃。这顿又是peter夫妇请，真是过意不去，蹭了两顿饭。吃完大家一一道别，我打车回青旅，回去九点多。 回到青旅发现我住的宿舍有4人了，还有个老外，西安过来的，教英语，有十天假期，问我怎么安排行程，因为他也想看美丽的秋景，英语太挫了，只能一半中文一半英语，在加翻译软件勉强交流。 09/28 嘉峪关&emsp;&emsp;今天早上坐10点20的车去嘉峪关，上车前青旅附近找了个小店吃早餐，一笼包子分量真大，够我吃两顿的，味道也不错。赶到嘉峪关12点多，找了个青旅，把我们拉来拉去换店，好坑，安顿下来都接近3点，我把这几天的衣服袜子都洗了。 &emsp;&emsp;4点多的时候，找附近的公交去嘉峪关，也找了好久，好不容易坐到嘉峪关，进去门票160，好贵。嘉峪关里面没啥好看的，跟其他要塞差不多，有东西两个大门，大门后面都有瓮城，城防很坚固，上到城楼要走马道。如果天气好，远处能看到雪山，加上早晚的彩霞，嘉峪关是非常雄浑的。但今天能见度低，看不到雪山，彩霞也一般。雄伟的嘉峪关城楼 **夕阳映衬下的嘉峪关** 从嘉峪关回来后很累，冲了个澡，感觉身体不舒服，估计着凉了，全身酸痛无力，也没有胃口，太痛苦了。晚上也睡不好，身体难受，但明天凌晨5点多的车到敦煌，还得熬着。 09/29 敦煌&emsp;&emsp;敦煌，是属于酒泉的县级市，古称肃州，甘肃的肃就来自这里。因为莫高窟，这里太出名了，各种旅游相关的非常成熟，当然也意味着消费要比张掖这样的小城贵，门票都是最贵的。 &emsp;&emsp;敦煌除了莫高窟，鸣沙山月牙泉，国内雅丹地貌最壮观的雅丹魔鬼城，阳关，玉门关，汉长城等等，非常值得一游，但我时间紧，也只看了在市区的莫高窟和鸣沙山月牙泉。其中鸣沙山月牙泉门票是120，有效期是两天，这个还不错；而莫高窟门票是200，超贵的，游客也最多，最好提前一天网上预约订票。 &emsp;&emsp;鸣沙山月牙泉其实就挨着敦煌市区，门票是120，有效期是两天，这样除了看今天的日落，明天还可以来看日出。就在沙漠的边缘啊，根本就不是在沙漠中间。外面太阳好猛烈，这边要7点多太阳才下山，在沙漠里面真是酷热，月牙泉的景色还不错，由于身体不适，逛到7点左右就出来了。鸣沙山月牙泉 &emsp;&emsp;回到青旅，同一间房有马来西亚的华人小伙伴和一个写游记的旅游作家，然后就是一阵聊天。旅游作家学识好丰富，他刚从伊朗回来，反走丝绸之路，和我相反。聊了很多他路上的见闻，他也发表了很多对敦煌的看法。 09/30 敦煌&emsp;&emsp;今天一大早，就被起床离开的小伙伴们吵醒了，于是起来吃个早餐，回到青旅看看有没有和我一起去莫高窟的。刚好有个浙江来的小伙，熟悉路线，于是我们就一起走到12路公交站，再坐车到莫高窟数字中心。领了昨天下午网上订的门票，门票是200，真tmd贵。我订的是11点30才开始，而现在才10点。和检票的沟通一下，说自己时间赶，就答应可以和10点的一拨人进去先。首先会放莫高窟历史的影片，然后下一个是360度的影厅放映莫高窟的一些代表性石窟。 &emsp;&emsp;看完这两部电影，就坐景区区间车去洞窟，先在洞窟外面拍外景，毕竟里面是不让拍照的。然后排队领讲解耳机，讲解员就会把一拨人带进去看石窟。讲解员的路线都是随机的，因为可看的400多个洞窟，不可能都进去，只能选择其中几个代驾表性洞窟，大概1个多小时。我感觉对这些文物方面的不是很有兴趣，出来后再去看博物馆里面的一些陈列品，然后就原路返回青旅，赶到青旅1点多，在里面充满电，上网。莫高窟 傍晚5点多我开始出发去敦煌汽车站，要坐汽车去柳园，然后再坐火车硬卧到乌鲁木齐。妈蛋，火车又晚点啊！原定23点多的推迟到1号凌晨0点44分，真是难熬啊！ 关于河西走廊&emsp;&emsp;敦煌，河西是走廊最西端，一路走来，思绪万千。苍茫的戈壁，雄伟的山川，让尘封的历史变得鲜活起来，远征漠北的霍去病，凿通西域的张骞，投笔从戎的班超，西天取经的玄奘，收复新疆的左宗棠。河西走廊上的城市是古时的军事重镇，靠祁连山的雪水供给。长达上千公里补给线，军镇之间相隔数百里，中间是毫无地形依托的大戈壁，面对的是游牧民族来去如风的骑兵。工业化来临前，通过河西走廊发动大规模的军事行动，其难度和付出的代价可想而知。这也是为何中原王朝最强盛的时候才保有这一战略要道，并控制西域。如今，武威，张掖，嘉峪关，敦煌这一个个的军镇已失去军事价值，成为了旅游景点，但仍然是沟通新疆的兰新线上的重要支点。 10/01 乌鲁木齐&emsp;&emsp;柳园到乌鲁木齐，火车上睡就是不舒服，早上7点多就起来了，很快就到乌鲁木齐站。真巧遇到一队上海的也是去喀纳斯的驴友，顺便加入他们俱乐部一起出发，因为喀纳斯的床位难订，中间转车也多。 &emsp;&emsp;出了火车站台，才发现乌市没有4g，移动的网络信号烂的一比，地图没法定位，网上支付，滴滴什么都用不了，没有网络简直寸步难行。很多的士都不理我们，好不容易有个小哥终于把我们载到预定的酒店去了。安顿完，我们就去外面吃东西，10点多快11点应该可以吃中饭了吧。但我们都没用考虑到新疆有两个多的时差，现在还是早餐时间，本地人还在吃早餐哈，好囧。我们就随便找了一家，点了包子和小米粥，太tmd的好吃了。 &emsp;&emsp;乌鲁木齐最出名就是大巴扎了，于是我们就坐公交到二道桥，把二道桥大巴扎和国际大巴扎都逛了，大部分店都是维族的，陪几位妹子逛，她们买了好多，本人几乎没买啥，就买了点吃的。然后打车到市博物馆，就奔着楼兰女尸去的，看了下新疆历史，最后才看干尸，大部分是欧罗巴人种。几个妹子不敢去看，干尸其实没啥可怕的。看完博物馆，觉得时间还长着呢，又在市区乱转，最后去红山公园，没啥好看的，就一个小山而已。还是回酒店吧，把小伙伴都叫齐，然后出去逛吃的，逛了好久，最后还是到上午没有吃成的那家店，因为评价不错。确实很好吃，还有歌舞表演。吃完再准备点明天吃的零食，然后回去洗澡睡觉，明天要7点半出发去克拉玛依魔鬼城大巴扎 **乌鲁木齐博物馆** 10/02 克拉玛依、布尔津&emsp;&emsp;早上匆忙起床，到附近的小店吃早餐，然后出发。今天是去克拉玛依市的乌尔禾景区魔鬼城。路程600多公里，因为一直都是多云天气，过去时还下了会小雨，路有点泥泞，弄的鞋都是泥。关键也没有太阳，风景不好看，只是随便拍了几张照片就出去外面看磕头机。 &emsp;&emsp;看完魔鬼城就出发去布尔津，布尔津县包括喀纳斯，白哈巴，禾木，也是去这几个景点的中转站。下午七点终于到了布尔津，和几个小伙伴一起去布尔津夜市吃烧烤和抓饭，最出名的是烤狗鱼了，要八十一斤，好贵，但味道不错。这一路上可以看辽阔广袤的北疆，风景非常壮观 10/03 喀纳斯&emsp;&emsp;喀纳斯位于中国版图的鸡尾巴上，与俄罗斯，蒙古，哈萨克斯坦交界的地方。喀纳斯是中国少有的位于寒温带的地区，它最美的就是秋季，其中9、10月又是最美的时候，漫山遍野的金黄，它被称为神的后花园，名副其实。喀纳斯景区包括喀纳斯湖，三大湾（神仙湾，月亮湾，卧龙湾），白哈巴村。其中白哈巴是中国西北第一村，过去就是哈萨克斯坦，要办理边防证。 &emsp;&emsp;这里大部分是图瓦人，类似蒙古族，主要分布在中俄蒙三国交界，俄罗斯那边还有个图瓦共和国，就是近代史上被沙俄侵占的唐努乌梁海地区，我们失去的地区一样很美，这是中国永远的痛！ &emsp;&emsp;喀纳斯也是我本次出行的目的地，可以说之前的行程就是北疆的铺垫吧！ &emsp;&emsp;今天七点半启程，出发去喀纳斯景区了，重头戏终于来了，我们一直祈祷出太阳。8点多的时候出太阳了，但还是有很多云。怀着愉快的心情一路拍风景过去。进入喀纳斯景区，阳光依然灿烂，有阳光景色真的太迷人了。但进入喀纳斯村后，天气突变，开始阴云密布。喀纳斯的路上 &emsp;&emsp;中饭吃了个手抓饼，有点腻，但好吃，50一份，太贵了。本来还打算去白哈巴的，但这天气，去了景色也不会太美，也罢。于是就去喀纳斯湖走栈道，3点多的时候，还下了会小雪，天气真糟糕，没有阳光，景色自然好不到哪去。那我就当徒步路线来走吧，直到走到栈道尽头，中间随便拍照，然后原路返回，回来吃了个馕和酸奶。再回住宿的地方洗澡小睡一会，晚上开始下大雪了。喀纳斯湖 10/04 喀纳斯 禾木&emsp;&emsp;一起床外面已经变成了白茫茫的一片，吃完早餐，就开始小雪，来自广东的我们超兴奋。等雪小了点，我们就开始出发，坐景区区间车到神仙湾，然后开始徒步三大湾。走着走着还时不时下起小雪，到月亮湾时，雪终于停了，太阳开始出来了，雪后的喀纳斯太美了，雪山，金黄的树木，绿色的水，蓝天，太难以忘怀了。就这样一路拍，最后徒步到卧龙湾，全程才5公里左右。然后再坐区间车到景区门口，集合出发去下一个景点，禾木。雪中的喀纳斯村 **神仙湾** 由于我们在神仙湾的时候，下着小雪，所以没有到湾边。 **月亮湾** 徒步到月亮湾的时候，雪停了，天开始放晴，最美的就是这一段，简直就是人间仙境 **卧龙湾** 喀纳斯到禾木的路上中午从喀纳斯去禾木的路上，开始下起了大雪，路上的风景也是很美滴。 禾木&emsp;&emsp;我们到禾木住宿点时，已经下午3点多了，但我们还没吃中饭呢，真是饿得要命，早上7点多饿到现在，4点多才吃上中饭，各个都是虎吞狼咽，菜刚上马上就哄抢一空，最后吃得好饱。这样我们晚上可以不怎么吃晚饭了，吃点羊肉串就好。主要的景点是在观景台，可以看到图瓦人村落全景，还可以看到日出日落和雪山，雪山前面是草原，七八月份的时候，一片花海，一定很美。快日落时太阳出来了，最喜欢的是雪山日落了。很快太阳就下山了，飕飕的寒风，冻死人，景色虽美，但太冷受不了。于是回去住宿的地方，吃点东西，洗澡睡觉。 **禾木村** **禾木河** 10/05 布尔津&emsp;&emsp;今天一大早起来，7点多就吃完了早餐，准备去看日出。但阴云密布，浓雾重重，日出是看不成了，好失望。于是我们就去小美丽峰那边徒步，走到一半，天气还是不好，也没什么看的，我就回去观景台，看看村庄全景好了。但雾气快12点才开始消散，等不及了，因为我们中午要出发回布尔津，赶紧吃了个中饭回去。 &emsp;&emsp;5点多刚好到达额尔齐斯河支流上的五彩滩，滩不远处是大戈壁，还有风车，今天下午天气很好，完美的夕阳，火红的五彩滩，太美太壮观了。7点多出发，回到布尔津8点多，在山里呆了几天，重新进城，感觉太爽了，热水，舒服的床。五彩滩 **五彩滩上的风车** 10/06 可可托海&emsp;&emsp;今天吃完早餐7点准时出发，因为从布尔津到达可可托海要7个小时，途中还在公路停了两次拍日出。我们中间还在可可苏里湖停下拍照，因为要门票，所以只在外面拍了一下就算了。1点多的时候到可可托海镇吃午饭，点了份香菇牛肉盖浇饭，还行。 &emsp;&emsp;吃中饭就直奔景区，景区外面有一大片的格桑花，很漂亮。然后坐景区区间车到神钟山，然后往里面走，一直到瀑布至少五六公里，时间太紧，没办法到最后的瀑布了，五点多就要回赶。我走到骆驼峰的时候，突然下起了大雪，满天雪花，爽，下来不过五六分钟就停了，然后又出太阳。往回走坐区间车的时候，还一边大太阳，一边下雪，，北疆的气候果真变化大，所谓十里不同天。其实路上的风景比里面峡谷美，如果时间足够，自驾或徒步骑行过来，一定很爽。傍晚在火烧云的陪伴下，到达富蕴住宿，北疆旅游结束了，明天要回乌鲁木齐了。 可可托海突遇大雪阿勒泰日出布尔津到富蕴的路上，这是我看过的最美的日出 **可可苏里** 可可苏里湖，远处就是阿尔泰山 可可托海 10/07 乌鲁木齐&emsp;&emsp;今天6点半从富蕴出发，昨晚买好了水果和馕准备路上吃。一上车大家都继续睡觉，直到8点多才醒，然后在车上吃买好的早餐。一边欣赏巍峨的天山山脉，一边吃零食，非常惬意。因为新疆的路况非常好，基本都是高速，所以非常顺利，1点不到就到了乌鲁木齐。因为部分人是直接飞机回去的，所以车是直接到机场的，而我们还要留在新疆，则必须打车回市区。打了个的，40多，直接到那里青年旅舍，安顿好之后，出去逛了会，午餐吃了个拌面。下午的时候我又再次去了趟博物馆，已经第二次去了，然后买点水果回青旅，上网，休息。同时顺便买好明天去吐鲁番的火车票。 10/08 吐鲁番&emsp;&emsp;今天睡到9点多，吃早饭，羊肉包子，奶茶，很好吃，吃得好饱。回去青旅退房，然后打车到火车站，出发去吐鲁番。到了吐鲁番火车站，才发觉离市区很远。刚好碰到一起拼车的3个维族妹子，司机是维族的，非常热情，一路聊天，直接到达卜青年旅舍。30元到青旅，接近50公里，还比较划算。我订的是男女混住的10人间，其中大部分是老外。中午吃的是苏莱曼拌面，非常好吃。达卜国际青旅 &emsp;&emsp;在青旅打听完景点路线，我选择去坎儿井和交河故城。因为葡萄沟没有葡萄了，而火焰山不是很有兴趣。坎儿井就是一个小博物馆，门票40，好坑，完全不值得去。交河故城倒是不错，尤其是傍晚的时候，残破的废墟，夕阳西下，特别有感觉。还有交河古城晚上还会点上蜡烛，一定很美。这里曾是车师前国的都城，后来还是大唐安西都护府的驻地。看完日落就出来了，不过司机嫌我在里面呆太久，多收我20，妈蛋，搞得我心情不好。回去市区吃完饭都已经9点多了，回到青旅洗漱睡觉，然后明天准备坐大巴回乌市。 交河故城&emsp;&emsp;交河故城建在河中间的沙洲上，河流成为了天然的护城河，地势非常险要。因为吐鲁番地区干燥，泥土很特殊，整个故城完全是“雕塑”出来的。故城曾经是丝绸之路上最繁华的城市之一。大汉朝曾发动过五次远征，才最终征服车师国，唐代时成为安西都护府的驻地。可以说交河故城极具历史人文意义。推荐傍晚的时候去，还有貌似周六周二的晚上故城还会在大道两边点上蜡烛，那时一定很美。 10/09 乌鲁木齐&emsp;&emsp;我选择坐汽车回乌鲁木齐，因为想多看路上的风景。两个多小时的路程，路过达坂城风区，壮观的风车，还有草原，谷地。回到乌市，再坐公交到白桦林国际青旅已经2点多，吃个饭，买了点水果，这家青旅明显比那里青旅要好，大厅还放电影，下午和驴友们一起再次重温了《海上钢琴师》。碰到个广西的小伙和海南的妹子，晚上就是一边聊天一边吃零食度过。还有一群德国的驴友，说德语，啥都听不懂。中午晚上都吃的是面旗子，很有特色很好吃。达坂城风车 10/10 深圳&emsp;&emsp;今天要回深圳了，滴滴预定了7点的车去机场。因为9点55的飞机，这边安检又特别严，所以还是要早点去。和我们同机的有一群维族的大叔大妈，看他们很兴奋的拍照，来深圳旅游的估计。飞机中间要到贵阳停半小时左右，飞过青藏高原的时候，真的好美。在贵阳上了趟卫生间，很快又要飞了，到深圳已经4点多，那几个维族的，见到深圳的大海，海港，轮船，也是够兴奋，凑在机窗边一阵乱拍的。旅游真的是从自己呆腻了了的地方到别人呆腻了的地方。到机场的时候，等行李等了好久才取出来，估计是新疆的航班，所以安检很严。从新疆回到深圳感觉就是从冬季穿越到了夏季，马上脱了冲锋衣，直接穿T恤得了。回到自己的窝已经6点多了，明天开始苦逼的上班了。飞过青藏高原 关于新疆&emsp;&emsp;新疆有各种最壮丽的自然景观，广袤的戈壁和沙漠，壮观的雪山和冰川，辽阔的大草原，迷人的湖泊，神奇的寒温带森林；新疆还有丰富的历史人文景观，中亚特色的人文风情，古代东西交汇的文化奇观，历朝历代留下的边疆要塞，古城遗址；当然了这也是吃货的天堂，鲜美的牛羊肉，干果，香甜的水果比内地的好吃多了。 &emsp;&emsp;新疆集北国风光之雄浑和南国风光之秀丽，景观多样，历史人文，还有美食，可以说是我最喜欢的一个省区。","tags":[{"name":"旅游","slug":"旅游","permalink":"https://edwardzhong.github.io/tags/%E6%97%85%E6%B8%B8/"},{"name":"西安","slug":"西安","permalink":"https://edwardzhong.github.io/tags/%E8%A5%BF%E5%AE%89/"},{"name":"甘肃","slug":"甘肃","permalink":"https://edwardzhong.github.io/tags/%E7%94%98%E8%82%83/"},{"name":"张掖","slug":"张掖","permalink":"https://edwardzhong.github.io/tags/%E5%BC%A0%E6%8E%96/"},{"name":"嘉峪关","slug":"嘉峪关","permalink":"https://edwardzhong.github.io/tags/%E5%98%89%E5%B3%AA%E5%85%B3/"},{"name":"敦煌","slug":"敦煌","permalink":"https://edwardzhong.github.io/tags/%E6%95%A6%E7%85%8C/"},{"name":"新疆","slug":"新疆","permalink":"https://edwardzhong.github.io/tags/%E6%96%B0%E7%96%86/"},{"name":"乌鲁木齐","slug":"乌鲁木齐","permalink":"https://edwardzhong.github.io/tags/%E4%B9%8C%E9%B2%81%E6%9C%A8%E9%BD%90/"},{"name":"喀纳斯","slug":"喀纳斯","permalink":"https://edwardzhong.github.io/tags/%E5%96%80%E7%BA%B3%E6%96%AF/"},{"name":"可可托海","slug":"可可托海","permalink":"https://edwardzhong.github.io/tags/%E5%8F%AF%E5%8F%AF%E6%89%98%E6%B5%B7/"},{"name":"吐鲁番","slug":"吐鲁番","permalink":"https://edwardzhong.github.io/tags/%E5%90%90%E9%B2%81%E7%95%AA/"}]}]
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff&#39;s world</title>
  <icon>https://edwardzhong.github.io/icon.png</icon>
  <subtitle>Things that I&#39;m interested in</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://edwardzhong.github.io/"/>
  <updated>2020-02-04T05:58:42.972Z</updated>
  <id>https://edwardzhong.github.io/</id>
  
  <author>
    <name>Jeff Zhong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用typescript改造koa开发框架</title>
    <link href="https://edwardzhong.github.io/2020/02/04/koatypescript/"/>
    <id>https://edwardzhong.github.io/2020/02/04/koatypescript/</id>
    <published>2020-02-04T03:37:48.000Z</published>
    <updated>2020-02-04T05:58:42.972Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;强类型的 &lt;strong&gt;TypeScript&lt;/strong&gt; 开发体验和维护项目上相比 &lt;strong&gt;JavaScript&lt;/strong&gt; 有着明显的优势，那么对常用的脚手架进行改造也就势在必行了。&lt;/p&gt;
&lt;p&gt;接下来开始对基于 &lt;strong&gt;koa&lt;/strong&gt; 框架的 &lt;strong&gt;node&lt;/strong&gt; 后端脚手架进行改造：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目开发环境 和 &lt;strong&gt;typescript&lt;/strong&gt; 编译环境的搭建；&lt;/li&gt;
&lt;li&gt;对 &lt;strong&gt;node&lt;/strong&gt;、&lt;strong&gt;koa&lt;/strong&gt;、koa中间件和使用到的库 添加类型化支持；&lt;/li&gt;
&lt;li&gt;基于 &lt;strong&gt;typesript&lt;/strong&gt; 的特性改造项目。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://edwardzhong.github.io/tags/node/"/>
    
      <category term="koa" scheme="https://edwardzhong.github.io/tags/koa/"/>
    
      <category term="typescript" scheme="https://edwardzhong.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>WebGL之物体选择</title>
    <link href="https://edwardzhong.github.io/2019/05/28/webglray/"/>
    <id>https://edwardzhong.github.io/2019/05/28/webglray/</id>
    <published>2019-05-28T07:07:25.000Z</published>
    <updated>2020-01-16T10:14:48.067Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用WebGL将图形绘制到画布后，如何与外部进行交互？这其中最关键的就是如何实现物体的选择。比如鼠标点击后判断是否选中了某个图形或图形的某个部分。&lt;/p&gt;
&lt;p&gt;本节实现的效果: &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglray.html&quot;&gt;WebGL选中物体&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-f6e7de79c53b2935.png&quot; width=&quot;400&quot; alt=&quot;WebGL选中物体&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之HDR与Bloom</title>
    <link href="https://edwardzhong.github.io/2019/05/21/webglhdr/"/>
    <id>https://edwardzhong.github.io/2019/05/21/webglhdr/</id>
    <published>2019-05-21T07:09:15.000Z</published>
    <updated>2020-01-16T10:14:26.359Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[WebGL学习之HDR与Bloom](https://edwardzhong.github.io/2018/01/12/webglhdr/)--&gt;

&lt;h2 id=&quot;什么是HDR&quot;&gt;&lt;a href=&quot;#什么是HDR&quot; class=&quot;headerlink&quot; title=&quot;什么是HDR&quot;&gt;&lt;/a&gt;什么是HDR&lt;/h2&gt;&lt;p&gt;HDR (High Dynamic Range，高动态范围)，在摄影领域，指的是可以提供更多的动态范围和图像细节的一种技术手段。简单讲就是将不同曝光拍摄出的最佳细节的LDR (低动态范围) 图像合成后，就叫HDR，它能同时反映出场景最暗和最亮部分的细节。为什么需要多张图片？因为目前的单反相机的宽容度还是有限的，一张照片不能反映出高动态场景的所有细节。一张图片拍摄就必须要在暗光和高光之间做出取舍，只能亮部暗部两者取其一。但是通过HDR合成多张图片，却能达到我们想要的效果。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-2960edbc2c229388.png&quot; alt=&quot;hdr&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之纹理盒</title>
    <link href="https://edwardzhong.github.io/2019/05/05/webglskybox/"/>
    <id>https://edwardzhong.github.io/2019/05/05/webglskybox/</id>
    <published>2019-05-05T13:34:20.000Z</published>
    <updated>2020-01-16T10:15:09.466Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们之前已经学习过二维纹理 &lt;strong&gt;gl.TEXTURE_2D&lt;/strong&gt;，而且还使用它实现了各种效果。但还有一种立方体纹理 &lt;strong&gt;gl.TEXTURE_CUBE_MAP&lt;/strong&gt;，它包含了6个纹理代表立方体的6个面。不像常规的纹理坐标有2个纬度，立方体纹理使用法向量，换句话说三维方向。本节实现的demo请看 &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglskybox.html&quot;&gt;天空盒&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-21b5d76b44dbd274.gif&quot; width=&quot;400&quot; alt=&quot;sky box&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL半透明物体的绘制</title>
    <link href="https://edwardzhong.github.io/2019/05/02/webglalpha/"/>
    <id>https://edwardzhong.github.io/2019/05/02/webglalpha/</id>
    <published>2019-05-02T05:16:29.000Z</published>
    <updated>2020-01-16T10:14:19.851Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;WebGL 中当透明和半透明物体共存时，相关设置不正确的话，物体表面会出现破碎杂乱的断面，非常影响效果，我们接着就来解决这个问题。&lt;br&gt;完成的展示Demo请看: &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglalpha.html&quot;&gt;半透明物体和透明物体共存&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-07fe85ce0e09500c.gif&quot; alt=&quot;alpha混合&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之法线贴图</title>
    <link href="https://edwardzhong.github.io/2019/04/30/webglnormap/"/>
    <id>https://edwardzhong.github.io/2019/04/30/webglnormap/</id>
    <published>2019-04-30T03:07:27.000Z</published>
    <updated>2020-01-16T10:14:35.347Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-a2003e57ddd79184.png&quot; width=&quot;400&quot; alt=&quot;法线贴图&quot;&gt;

&lt;p&gt;为了增加额外细节，提升真实感，我们使用了漫反射贴图和高光贴图，它们都是向三角形进行附加纹理。但是从光的视角来看是表面法线向量使表面被视为平坦光滑的表面。以光照算法的视角考虑的话，只有一件事决定物体的形状，那就是垂直于它的法线向量。砖块表面只有一个法向量，表面完全根据这个法向量被以一致的方式照亮。如果每个片元都用不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-91a0ac5e7a16904f.png&quot; alt=&quot;表面法线&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之纹理贴图</title>
    <link href="https://edwardzhong.github.io/2019/04/29/webgltexture/"/>
    <id>https://edwardzhong.github.io/2019/04/29/webgltexture/</id>
    <published>2019-04-29T03:24:21.000Z</published>
    <updated>2020-01-16T10:15:25.119Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;为了使图形能获得接近于真实物体的材质效果，一般会使用贴图，贴图类型主要包括两种：漫反射贴图和镜面高光贴图。其中漫反射贴图可以同时实现漫反射光和环境光的效果。&lt;br&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>如何将markdown转换为wxml</title>
    <link href="https://edwardzhong.github.io/2019/04/27/mdtowxml/"/>
    <id>https://edwardzhong.github.io/2019/04/27/mdtowxml/</id>
    <published>2019-04-27T02:36:23.000Z</published>
    <updated>2020-01-16T10:12:58.021Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;话说我要为技术博客写一个小程序版，我的博客解决方案是 &lt;strong&gt;hexo + github-page&lt;/strong&gt;，格式当然是技术控们喜欢的  &lt;strong&gt;markdown&lt;/strong&gt; 了 。但小程序使用的却是独有的模版语言 &lt;strong&gt;WXML&lt;/strong&gt;。我总不能把之前的文章手动转换成小程序的 &lt;strong&gt;wxml&lt;/strong&gt; 格式吧，而网上也没完善的转换库，还是自己写个解析器吧。&lt;/p&gt;
&lt;p&gt;解析器最核心的部分就是字符串模式匹配，既然涉及到字符串匹配，那么就离不开正则表达式。幸好，正则表达式是我的优势之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="wxml" scheme="https://edwardzhong.github.io/tags/wxml/"/>
    
      <category term="markdown" scheme="https://edwardzhong.github.io/tags/markdown/"/>
    
      <category term="正则表达式" scheme="https://edwardzhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>小试小程序云开发</title>
    <link href="https://edwardzhong.github.io/2019/04/26/weappcloud/"/>
    <id>https://edwardzhong.github.io/2019/04/26/weappcloud/</id>
    <published>2019-04-26T02:13:20.000Z</published>
    <updated>2020-01-16T10:14:06.379Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序刚出没多久时，曾经上手写过demo，但开发体验比较差，所以一直没怎么关注。不过自从诸多适配方案出炉，以及云端的开通，觉得还是有必要上手体验一番的，于是为我的技术博客也写了个小程序版。&lt;/p&gt;
&lt;p&gt;原生开发我是不想再试了，那就选一种适配方案，目前比较知名的有基于vue的 &lt;strong&gt;mpvue&lt;/strong&gt;，&lt;strong&gt;umi-app&lt;/strong&gt;，基于react 的 &lt;strong&gt;taro&lt;/strong&gt;，以及TX团队出的全新框架 &lt;strong&gt;wepy&lt;/strong&gt;。个人对 react 的好感 以及 &lt;strong&gt;taro&lt;/strong&gt; 框架的走向成熟，促使我选择了 &lt;strong&gt;taro&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="taro" scheme="https://edwardzhong.github.io/tags/taro/"/>
    
      <category term="小程序" scheme="https://edwardzhong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>koa+mysql+vue+socket.io全栈开发之前端篇</title>
    <link href="https://edwardzhong.github.io/2019/04/13/fullstack3/"/>
    <id>https://edwardzhong.github.io/2019/04/13/fullstack3/</id>
    <published>2019-04-13T05:43:45.000Z</published>
    <updated>2020-01-16T10:11:00.285Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;React&lt;/strong&gt; 与 &lt;strong&gt;Vue&lt;/strong&gt; 之间的对比，是前端的一大热门话题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vue&lt;/strong&gt; 简易上手的脚手架，以及官方提供必备的基础组件，比如 &lt;strong&gt;vuex&lt;/strong&gt;，&lt;strong&gt;vue-router&lt;/strong&gt;，对新手真的比较友好；&lt;strong&gt;react&lt;/strong&gt; 则把这些都交给社区去做，虽然这壮大了 &lt;strong&gt;react&lt;/strong&gt; 的生态链，但新手要弄出一套趁手的方案挺麻烦的，不过好在现在有很多类似 dva 的方案了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vue&lt;/strong&gt; 比较讨喜的一点，就是它的数据双向流动在表单开发时特别方便，而 &lt;strong&gt;react&lt;/strong&gt; 在这方面可就麻烦多了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是 &lt;strong&gt;vue&lt;/strong&gt; 复杂的 api ，简直让人头大，光是文档说明都几十页了。太多的语法，太多的魔法符号，对进化速度越来越快的前端届来说，就是入手这个框架的最大阻碍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而相反 &lt;strong&gt;react&lt;/strong&gt; 的 api 数量简直可以忽略不计了，顶多花几小时就能看完官方文档。你只要理解 &lt;strong&gt;JavaScript&lt;/strong&gt;，就能理解 &lt;strong&gt;react&lt;/strong&gt; 的很多行为。&lt;strong&gt;react&lt;/strong&gt; 的很多用法，它的 api 都是符合直觉的，你对它用法的猜测基本都是八九不离十的，这真是大大降低了心智负担。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除此之外，&lt;strong&gt;react&lt;/strong&gt; 的 &lt;strong&gt;jsx&lt;/strong&gt; 语法表达能力更强，还有 &lt;strong&gt;hoc&lt;/strong&gt; 和 &lt;strong&gt;hooks&lt;/strong&gt; 使代码也更容易组织和复用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然我更喜欢 &lt;strong&gt;React&lt;/strong&gt; ，但工作上的需求，还不是要你用什么你就得用什么 😂，所以这个 demo 就当是探索 &lt;strong&gt;Vue&lt;/strong&gt; 的前奏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="https://edwardzhong.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="https://edwardzhong.github.io/tags/vuex/"/>
    
      <category term="socket.io" scheme="https://edwardzhong.github.io/tags/socket-io/"/>
    
  </entry>
  
  <entry>
    <title>koa+mysql+vue+socket.io全栈开发之数据访问篇</title>
    <link href="https://edwardzhong.github.io/2019/04/12/fullstack2/"/>
    <id>https://edwardzhong.github.io/2019/04/12/fullstack2/</id>
    <published>2019-04-12T07:34:17.000Z</published>
    <updated>2020-01-16T10:10:51.126Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;后端搭起大体的框架后，接着涉及到的就是如何将数据持久化的问题，也就是对数据库进行 &lt;strong&gt;CURD&lt;/strong&gt; 操作。&lt;/p&gt;
&lt;p&gt;关于数据库方案, &lt;strong&gt;mongodb&lt;/strong&gt; 和 &lt;strong&gt;mysql&lt;/strong&gt;  都使用过，但我选用的是 &lt;strong&gt;mysql&lt;/strong&gt;，原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目前为止 &lt;strong&gt;mysql&lt;/strong&gt; 与 &lt;strong&gt;mongodb&lt;/strong&gt; 性能相差不大，尤其是 &lt;strong&gt;mysql&lt;/strong&gt; 8.0 版本，速度非常快，查询数据是 mysql 更快，写数据方面 &lt;strong&gt;mongodb&lt;/strong&gt; 则更胜一筹；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mysql&lt;/strong&gt; 建立 关联数据要更方便些，比如： 一对多，多对多的关系；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mysql&lt;/strong&gt; 作为关系型数据库，数据一致性方面更好，尤其是事务用起来更顺手；&lt;/li&gt;
&lt;li&gt;本人对 sql 操作比较得心应手，毕竟大部分项目用得都是 &lt;strong&gt;mysql&lt;/strong&gt;，而 &lt;strong&gt;mongodb&lt;/strong&gt; 在正式些的项目上用的就少了，而且目前关系型数据库也在进化, &lt;strong&gt;postgrep&lt;/strong&gt; 和 &lt;strong&gt;mysql&lt;/strong&gt; 都已经支持 json了。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://edwardzhong.github.io/tags/node/"/>
    
      <category term="mysql" scheme="https://edwardzhong.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>koa+mysql+vue+socket.io全栈开发之web api篇</title>
    <link href="https://edwardzhong.github.io/2019/04/08/fullstack/"/>
    <id>https://edwardzhong.github.io/2019/04/08/fullstack/</id>
    <published>2019-04-08T07:50:03.000Z</published>
    <updated>2020-01-16T10:10:42.302Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;目标是建立一个 &lt;strong&gt;web QQ&lt;/strong&gt; 的项目，使用的技术栈如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;后端是基于 &lt;strong&gt;koa2&lt;/strong&gt; 的 web api 服务层，提供 curd 操作的 http 接口，登录验证使用的是 &lt;strong&gt;json web token&lt;/strong&gt;，跨域方案使用的是 &lt;strong&gt;cors&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据库使用的是 &lt;strong&gt;mysql&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了实时通信，使用的是基于 websocket 协议的 &lt;strong&gt;socket.io&lt;/strong&gt; 框架；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端则使用的是 &lt;strong&gt;vue + vuex&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://edwardzhong.github.io/tags/node/"/>
    
      <category term="koa" scheme="https://edwardzhong.github.io/tags/koa/"/>
    
      <category term="jwt" scheme="https://edwardzhong.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>关于socket.io的使用</title>
    <link href="https://edwardzhong.github.io/2019/03/29/socketio/"/>
    <id>https://edwardzhong.github.io/2019/03/29/socketio/</id>
    <published>2019-03-28T16:44:31.000Z</published>
    <updated>2020-01-16T10:13:27.652Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这段时间学习了&lt;strong&gt;socket.io&lt;/strong&gt;，用它写了小项目，在此总结下它的基本使用方式和一些要点。&lt;br&gt;&lt;strong&gt;socket.io&lt;/strong&gt;是基于&lt;strong&gt;Node.js&lt;/strong&gt;和&lt;strong&gt;WebSocket&lt;/strong&gt;协议的实时通信开源框架，它包括客户端的JavaScript和服务器端的Node.js。&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h2&gt;&lt;p&gt;这里后端使用的框架是&lt;strong&gt;koa2&lt;/strong&gt;，&lt;strong&gt;socket.io&lt;/strong&gt;将自身绑定到koa的进程中去，其中最重要的事件就是 &lt;strong&gt;connection&lt;/strong&gt; 和 &lt;strong&gt;disconnect&lt;/strong&gt;。它们是框架本身定义的系统事件，也就意味着它是自然就存在的不需要我们自定义，当然还有其它系统事件，但很少会用得到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="socket.io" scheme="https://edwardzhong.github.io/tags/socket-io/"/>
    
  </entry>
  
  <entry>
    <title>基于Webpack 4 和 React hooks 搭建项目</title>
    <link href="https://edwardzhong.github.io/2019/02/04/reacthooks/"/>
    <id>https://edwardzhong.github.io/2019/02/04/reacthooks/</id>
    <published>2019-02-04T05:58:44.000Z</published>
    <updated>2020-01-16T10:13:21.308Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;面对日新月异的前端，我表示快学不动了😂。 &lt;strong&gt;Webpack&lt;/strong&gt; 老早就已经更新到了 V4.x，前段时间 &lt;strong&gt;React&lt;/strong&gt; 又推出了  &lt;strong&gt;hooks&lt;/strong&gt; API。刚好春节在家里休假，时间比较空闲，还是赶紧把 &lt;strong&gt;React&lt;/strong&gt;技术栈这块补上。&lt;/p&gt;
&lt;p&gt;网上有很多介绍 &lt;strong&gt;hooks&lt;/strong&gt; 知识点的文章，但都比较零碎，基本只能写一些小 &lt;strong&gt;Demo&lt;/strong&gt;。还没有比较系统的，全新的基于 &lt;strong&gt;hooks&lt;/strong&gt; 进行搭建实际项目的讲解。所以这里就从开发实际项目的角度，搭建起单页面 &lt;strong&gt;Web App&lt;/strong&gt;项目的基本脚手架，并基于 &lt;strong&gt;hooks&lt;/strong&gt; API 实现一个 &lt;strong&gt;react&lt;/strong&gt; 项目模版。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Hooks&lt;/strong&gt; 最吸引人的地方就是用 &lt;strong&gt;函数式组件&lt;/strong&gt; 代替面向对象的 &lt;strong&gt;类组件&lt;/strong&gt;。此前的 &lt;strong&gt;react&lt;/strong&gt; 如果涉及到状态，解决方案通常只能使用 &lt;strong&gt;类组件&lt;/strong&gt;，业务逻辑一复杂就容易导致组件臃肿，模块的解藕也是个问题。而使用基于 &lt;strong&gt;hooks&lt;/strong&gt; 的 &lt;strong&gt;函数组件&lt;/strong&gt; 后，代码不仅更加简洁，写起来更爽，而且模块复用也方便得多，非常看好它的未来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="react" scheme="https://edwardzhong.github.io/tags/react/"/>
    
      <category term="webpack" scheme="https://edwardzhong.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>动画函数的绘制及自定义动画函数</title>
    <link href="https://edwardzhong.github.io/2019/01/03/animationfun/"/>
    <id>https://edwardzhong.github.io/2019/01/03/animationfun/</id>
    <published>2019-01-02T18:01:23.000Z</published>
    <updated>2020-01-16T10:09:43.455Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;制作动画效果离不开动画运动函数，而我们用得最多的无疑就是 &lt;strong&gt;Tween.js&lt;/strong&gt;。根据不同的数学公式原理，&lt;strong&gt;Tween.js&lt;/strong&gt; 划分出了不同的动画类型，每种动画类型里面都包含以下的缓动类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ease in&lt;/strong&gt; 先慢后快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ease out&lt;/strong&gt; 先块后慢&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ease in out&lt;/strong&gt; 先慢后快再慢&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于缓动函数，我们在 &lt;strong&gt;css3&lt;/strong&gt; 动画里已经用得太多了，不再细讲。&lt;strong&gt;Tween.js&lt;/strong&gt; 源代码请看：&lt;em&gt;&lt;a href=&quot;https://github.com/edwardzhong/html5Canvas/blob/master/js/tween.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tween.js&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="canvas" scheme="https://edwardzhong.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas实现俄罗斯方块</title>
    <link href="https://edwardzhong.github.io/2018/12/12/tetris/"/>
    <id>https://edwardzhong.github.io/2018/12/12/tetris/</id>
    <published>2018-12-12T13:35:33.000Z</published>
    <updated>2020-01-16T10:13:56.516Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;好久没使用canvas了，于是通过写小游戏“俄罗斯方块”再次熟悉下canvas，如果有一定的canvas基础，要实现还是不难的。实际完成的Demo请看：*&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/tetris.html&quot;&gt;canvas俄罗斯方块&lt;/a&gt;*。&lt;/p&gt;
&lt;h2 id=&quot;原理详解&quot;&gt;&lt;a href=&quot;#原理详解&quot; class=&quot;headerlink&quot; title=&quot;原理详解&quot;&gt;&lt;/a&gt;原理详解&lt;/h2&gt;&lt;p&gt;看游戏最终界面，可知需要实现以下关键功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;游戏面板，也就是12 * 20的方格，以及是否填充了方块信息；&lt;/li&gt;
&lt;li&gt;运动方块，方块需要实现移动，变形的功能。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-db822f51691a0904.jpg&quot; alt=&quot;游戏界面&quot;&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="canvas" scheme="https://edwardzhong.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>Haskell学习-monad</title>
    <link href="https://edwardzhong.github.io/2018/08/16/haskelld/"/>
    <id>https://edwardzhong.github.io/2018/08/16/haskelld/</id>
    <published>2018-08-16T01:29:31.000Z</published>
    <updated>2020-01-16T10:12:43.028Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[Haskell学习-monad](https://edwardzhong.github.io/2018/08/16/haskelld/) --&gt;

&lt;h2 id=&quot;什么是Monad&quot;&gt;&lt;a href=&quot;#什么是Monad&quot; class=&quot;headerlink&quot; title=&quot;什么是Monad&quot;&gt;&lt;/a&gt;什么是Monad&lt;/h2&gt;&lt;p&gt;Haskell是一门纯函数式的语言，纯函数的优点是安全可靠。函数输出完全取决于输入，不存在任何隐式依赖，它的存在如同数学公式般完美无缺。可是纯函数因为隔绝了外部环境，连最基本的输入输出都无法完成。而 &lt;strong&gt;Monad&lt;/strong&gt; 就是 Haskell 给出的解决方案。但&lt;strong&gt;Monad&lt;/strong&gt; 并不仅仅是 IO 操作的抽象，它更是多种类似操作之间共性的抽象。所以 Monad 解决的问题并不局限在 IO 上，像 Haskell 中的 &lt;strong&gt;Maybe&lt;/strong&gt; 和 &lt;strong&gt;[]&lt;/strong&gt; 都是 &lt;strong&gt;Monad&lt;/strong&gt;。Haskell 中漂亮的错误处理方式， &lt;strong&gt;do&lt;/strong&gt; 表示法和灵活的列表推导式 (&lt;strong&gt;list comprehension&lt;/strong&gt;) 都算是 &lt;strong&gt;Monad&lt;/strong&gt; 的贡献。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="haskell" scheme="https://edwardzhong.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>Haskell学习-functor</title>
    <link href="https://edwardzhong.github.io/2018/08/15/haskellc/"/>
    <id>https://edwardzhong.github.io/2018/08/15/haskellc/</id>
    <published>2018-08-15T13:27:15.000Z</published>
    <updated>2020-01-16T10:12:35.052Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[Haskell学习-functor](https://edwardzhong.github.io/2018/08/15/haskellc/) --&gt;
&lt;h2 id=&quot;什么是Functor&quot;&gt;&lt;a href=&quot;#什么是Functor&quot; class=&quot;headerlink&quot; title=&quot;什么是Functor&quot;&gt;&lt;/a&gt;什么是Functor&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;functor&lt;/strong&gt; 就是可以执行map操作的对象，functor就像是附加了语义的表达式，可以用盒子进行比喻。&lt;strong&gt;functor&lt;/strong&gt; 的定义可以这样理解：给出a映射到b的函数和装了a的盒子，结果会返回装了b的盒子。&lt;strong&gt;fmap&lt;/strong&gt; 可以看作是一个接受一个function 和一个 &lt;strong&gt;functor&lt;/strong&gt; 的函数，它把function 应用到 &lt;strong&gt;functor&lt;/strong&gt; 的每一个元素（映射）。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- Functor的定义&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Functor&lt;/span&gt; f &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="haskell" scheme="https://edwardzhong.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>Haskell学习-高阶函数</title>
    <link href="https://edwardzhong.github.io/2018/08/08/haskellb/"/>
    <id>https://edwardzhong.github.io/2018/08/08/haskellb/</id>
    <published>2018-08-08T15:55:13.000Z</published>
    <updated>2020-01-16T10:12:28.494Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[Haskell学习-高阶函数](https://edwardzhong.github.io/2018/08/08/haskellb/) --&gt;
&lt;p&gt;高阶函数(higher-order function)就是指可以操作函数的函数，即函数可以作为参数，也可以作为返回结果。有了这两个特性，haskell可以实现许多神奇的效果。&lt;/p&gt;
&lt;h2 id=&quot;柯里化（Currying）&quot;&gt;&lt;a href=&quot;#柯里化（Currying）&quot; class=&quot;headerlink&quot; title=&quot;柯里化（Currying）&quot;&gt;&lt;/a&gt;柯里化（Currying）&lt;/h2&gt;&lt;p&gt;在haskell中所有的算术运算符都是函数(包括大小于等于关系符等)，而它们的快捷方式都可以省略操作数（参数）。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(+) &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;-- (+) 是需要两个操作数的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;-- (+1) 是需要左操作数的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*) &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;-- (3*) 是需要右操作数的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;map&lt;/span&gt; (*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;-- map所有元素 *2 的操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;filter&lt;/span&gt; (&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;-- 过滤 &amp;gt;3的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt; [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="haskell" scheme="https://edwardzhong.github.io/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>Haskell学习-函数式编程初探</title>
    <link href="https://edwardzhong.github.io/2018/08/07/haskella/"/>
    <id>https://edwardzhong.github.io/2018/08/07/haskella/</id>
    <published>2018-08-07T13:49:46.000Z</published>
    <updated>2020-01-16T10:11:08.909Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[Haskell学习-函数式编程初探](https://edwardzhong.github.io/2018/08/07/haskella/) --&gt;

&lt;p&gt;为什么要学习函数式编程？为什么要学习Haskell？&lt;/p&gt;
&lt;p&gt;.net到前端，C#和JavaScript对我来说如果谈不上精通，最起码也算是到了非常熟悉的程度。这两门语言就像是我的盾牌和宝剑,给我保驾护航,开山劈石,伴随着我不断成长。同时C#和JavaScript它们本身也在不断地进化，不断出现越来越多方便的语法糖，但追根到底很多都是从函数式语言汲取的精华。比如高阶函数，lambada表达式，柯里化等。 &lt;/p&gt;
&lt;p&gt;于是从探险的角度，以好奇的心态开始学习函数式语言，探索这个宝库，拾取可供临摹的珍宝。最起码它能让你多一个不同的角度看待编程语言,影响你的思考方式。 学习的对象当然选择函数式语言的集大成者-Haskell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="haskell" scheme="https://edwardzhong.github.io/tags/haskell/"/>
    
  </entry>
  
</feed>

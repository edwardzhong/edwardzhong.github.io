<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff&#39;s world</title>
  <icon>https://jeff_zhong.gitee.io/icon.png</icon>
  <subtitle>Things that I&#39;m interested in</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jeff_zhong.gitee.io/"/>
  <updated>2023-09-08T10:13:18.200Z</updated>
  <id>https://jeff_zhong.gitee.io/</id>
  
  <author>
    <name>Jeff Zhong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习之分类</title>
    <link href="https://jeff_zhong.gitee.io/2023/09/08/category/"/>
    <id>https://jeff_zhong.gitee.io/2023/09/08/category/</id>
    <published>2023-09-08T08:56:31.000Z</published>
    <updated>2023-09-08T10:13:18.200Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;分类任务和回归任务的不同之处在于，分类任务需要做出离散的预测。对于多分类任务的神经网络模型，其输出目标通常会用&lt;strong&gt;one-hot&lt;/strong&gt;编码来表示，在输出层中使用&lt;strong&gt;softmax&lt;/strong&gt;函数，同时使用分类交叉熵损失函数进行训练。在本博客中，我们将使用&lt;strong&gt;TensorFlow&lt;/strong&gt;的底层API实现一个基于全连接层的神经网络来进行&lt;strong&gt;MNIST&lt;/strong&gt;数字图像分类。下面是涉及到的相关概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度学习&lt;/strong&gt;是一种机器学习方法，它通过多层神经网络层次化地提取特征，以解决各种复杂的分类和回归问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;神经网络&lt;/strong&gt;是深度学习的基本组成部分，由多个层次化的神经元组成。输入层接受数据，中间的隐藏层通过权重和激活函数处理数据，最终输出层产生分类结果。在这个示例中，我们将手动实现神经网络的核心组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前向传播&lt;/strong&gt;是神经网络中的信息传递过程，从输入层到输出层，每一层的神经元根据权重和激活函数计算输出。这个过程将输入数据映射到预测输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反向传播&lt;/strong&gt;是训练神经网络的关键步骤，它通过计算预测与真实标签之间的误差，并将误差反向传播到网络中的每一层来更新权重，以最小化误差。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="机器学习" scheme="https://jeff_zhong.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://jeff_zhong.gitee.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之线性回归</title>
    <link href="https://jeff_zhong.gitee.io/2023/07/12/linear/"/>
    <id>https://jeff_zhong.gitee.io/2023/07/12/linear/</id>
    <published>2023-07-12T08:42:07.000Z</published>
    <updated>2023-09-08T08:58:32.697Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;回归是机器学习中最常见的任务之一，回归（regression）问题预测的是一个连续值，而不是离散标签，比如根据气象数据预测明日气温，或者根据房地产数据估算房价（标量回归问题）。&lt;/p&gt;
&lt;p&gt;接下来就以回归问题最经典的波士顿房价为例，了解标量回归问题的基本配置。当然主要是对深度学习的训练与推理建立一个基本的认知，训练结果好坏反而不太重要。&lt;/p&gt;
&lt;p&gt;既然是机器学习，了解python是必备的（上手也很容易），使用的也是易上手的keras框架，接着再了解一下numpy，可以上路了。&lt;/p&gt;
&lt;p&gt;基于tensorflow.js实现的纯前端小样例请看：&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/linear.html&quot;&gt;线性回归&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;准备数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构建模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;训练模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预测结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="机器学习" scheme="https://jeff_zhong.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>人工智能与机器学习和深度学习</title>
    <link href="https://jeff_zhong.gitee.io/2023/07/12/ai/"/>
    <id>https://jeff_zhong.gitee.io/2023/07/12/ai/</id>
    <published>2023-07-12T05:50:07.000Z</published>
    <updated>2023-09-08T08:58:19.968Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这一年来，AI领域层出不穷的技术和应用，真的有点让人疲于奔命。其中AIGC领域的diffusion model 和 NLP领域的 ChatGBT 引领了这一轮风潮。AI取代越来越多脑力工作者的趋势已经不可逆转，在这经济下行内卷严重的当代，竞争将越发的残酷。作为走在风口前沿的技术人，用stable diffusion绘制过逼真的画作，也用ChatGPT生产修改过样板代码，AI带给我的危机感是实实在在，在ChatGPT风头正劲的那段时间，焦虑一度让我夜不能寐。&lt;/p&gt;
&lt;p&gt;在AI狂潮告一段落的当下，是时候冷静下来思考，我们应该怎么看待AI，&lt;a href=&quot;https://www.ruanyifeng.com/blog/2023/05/weekly-issue-255.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对待 AI 的正确态度&lt;/a&gt;是什么，这篇文章观点我大体上赞同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ChatGBT像一个吸收了所有人类知识、但需要别人帮忙才能把这些知识串起来的应届毕业生。看来我今年的工作是安全的。但是，我需要好好学习 ChatGPT，精通它的使用，让我明年也是安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AI 会大大增强程序员的生产力，并创造过去不可能的产品。AI 本质是生产力工具，跟高级语言、云服务、开源代码等是一个性质。写代码的门槛会降低，更多的人会进入 IT 行业，软件市场将变大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们要成为这个过程的一部分，需要让自己积极主动，不断更新技能，接受新工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是的，我们要成为这个AI落地各行各业过程的一部分，也是我这一年来自学机器学习、深度学习的动力和缘由，也陆陆续续在工作中落地了一些简单的ai项目，而这个机器学习和深度学习的系列就是我学习过程的一个记录和总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ai" scheme="https://jeff_zhong.gitee.io/tags/ai/"/>
    
      <category term="人工智能" scheme="https://jeff_zhong.gitee.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习，深度学习" scheme="https://jeff_zhong.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv学习之边缘检测</title>
    <link href="https://jeff_zhong.gitee.io/2022/05/12/opencv2/"/>
    <id>https://jeff_zhong.gitee.io/2022/05/12/opencv2/</id>
    <published>2022-05-12T03:04:04.000Z</published>
    <updated>2023-09-08T08:57:53.498Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/edge.html&quot;&gt;边缘检测&lt;/a&gt; 是&lt;strong&gt;图像处理&lt;/strong&gt; 过程中经常会涉及到的一个环节。而在&lt;strong&gt;计算机视觉&lt;/strong&gt; 和 &lt;strong&gt;机器学习&lt;/strong&gt;领域，&lt;strong&gt;边缘检测&lt;/strong&gt; 用于 &lt;strong&gt;特征提取&lt;/strong&gt; 和 &lt;strong&gt;特征检测&lt;/strong&gt; 效果也是特别明显。而 openCV 中进行边缘检测的 算法 真是五花八门，下面我就选几个最常用算法的函数api进行介绍。&lt;/p&gt;
&lt;p&gt;本文涉及到的效果请看：&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/edge.html&quot;&gt;边缘检测&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="opencv" scheme="https://jeff_zhong.gitee.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv学习之基础</title>
    <link href="https://jeff_zhong.gitee.io/2022/05/05/opencv/"/>
    <id>https://jeff_zhong.gitee.io/2022/05/05/opencv/</id>
    <published>2022-05-05T08:05:49.000Z</published>
    <updated>2023-09-08T08:57:49.237Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前段时间一直在钻研深度学习中的卷积神经网络，其中的预处理环节可以说非常关键，主要就是对图片和视频进行处理。而图像处理就涉及到图形学和底层技术细节，这是一个比较精深和专业的领域，假设我们要从头开始做起，那简直太麻烦和低效了。为解决这个问题，&lt;strong&gt;openCV&lt;/strong&gt;就此应运而生，它屏蔽了很多底层技术细节，抽象出方便的API，而我们只需要灵活组合相关的 api 就能实现强大的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="opencv" scheme="https://jeff_zhong.gitee.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>html5调用摄像头截图</title>
    <link href="https://jeff_zhong.gitee.io/2021/08/17/camera/"/>
    <id>https://jeff_zhong.gitee.io/2021/08/17/camera/</id>
    <published>2021-08-17T02:54:23.000Z</published>
    <updated>2021-12-26T06:47:30.903Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;关于html5调用音视频等多媒体硬件的API已经很成熟，不过一直找不到机会把这些硬件转化为实际的应用场景，不过近年来随着iot和AI的浪潮，我觉得软硬结合的时机已经成熟。那我们就提前熟悉下怎么操作这些多媒体硬件吧，首先图像识别是其中最热门的应用场景，首先实现调用摄像头以及截图。&lt;/p&gt;
&lt;p&gt;demo的效果请看：&lt;em&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/camera.html&quot;&gt;摄像头截图&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="canvas" scheme="https://jeff_zhong.gitee.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>WebGL之绘制三维地球</title>
    <link href="https://jeff_zhong.gitee.io/2021/04/25/webglsphere/"/>
    <id>https://jeff_zhong.gitee.io/2021/04/25/webglsphere/</id>
    <published>2021-04-25T02:46:32.000Z</published>
    <updated>2021-12-26T06:49:57.884Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通过Three.js也许可以很方便的展示出3D模型，但是你知道它是怎么一步一步从构建网格到贴图到最终渲染出3D模型的吗？现在我们直接使用底层的webgl加上一点点的数学知识就可以实现它。&lt;/p&gt;
&lt;p&gt;本节实现的效果: &lt;em&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/webglsphere.html&quot;&gt;WebGL三维地球&lt;/a&gt;&lt;/em&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/earth3d.jpg&quot; width=&quot;400&quot; alt=&quot;WebGL三维地球&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL之延迟着色</title>
    <link href="https://jeff_zhong.gitee.io/2020/09/17/webgldeferred/"/>
    <id>https://jeff_zhong.gitee.io/2020/09/17/webgldeferred/</id>
    <published>2020-09-17T11:30:31.000Z</published>
    <updated>2021-12-26T06:49:24.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;什么是&lt;strong&gt;延迟着色(Deferred Shading)&lt;/strong&gt;？它是相对于正常使用的&lt;strong&gt;正向着色(Forward Shading)&lt;/strong&gt;而言的，正向着色的工作模式：遍历光源，获取光照条件，接着遍历物体，获取物体的几何数据，最后根据光照和物体几何数据进行计算。&lt;/p&gt;
&lt;p&gt;但是&lt;strong&gt;正向着色(Forward Shading)&lt;/strong&gt;在光源非常多的情况下，对性能的消耗非常大。因为程序要对每一个光源，每一个需要渲染的物体，每一个需要渲染的片段进行迭代！还有片段着色器的输出会被之后的输出覆盖，正向渲染会在场景中因多个物体重合在一个像素上浪费大量的片段着色器运行时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延迟着色(Deferred Shading)&lt;/strong&gt;，就是为了解决上述问题而生，尤其是需要渲染几百上千个光源的场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建部署Node项目</title>
    <link href="https://jeff_zhong.gitee.io/2020/07/13/docker/"/>
    <id>https://jeff_zhong.gitee.io/2020/07/13/docker/</id>
    <published>2020-07-13T03:39:53.000Z</published>
    <updated>2021-12-26T06:47:50.574Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做了个&lt;code&gt;node&lt;/code&gt;全栈项目，服务端技术栈是 &lt;code&gt;nginx&lt;/code&gt; + &lt;code&gt;koa&lt;/code&gt; + &lt;code&gt;postgresql&lt;/code&gt;。其中在&lt;code&gt;centos&lt;/code&gt;上搭建环境和部署都挺费周折，部署测试服务器，接着上线的时候又部署生产环境服务器。这中间就有很多既无聊又费精力，吃力不讨好的”体力活”。所以就开始思考怎么自动化这部分搭建部署的工作，也就引出了&lt;code&gt;Docker&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="koa" scheme="https://jeff_zhong.gitee.io/tags/koa/"/>
    
      <category term="docker" scheme="https://jeff_zhong.gitee.io/tags/docker/"/>
    
      <category term="nginx" scheme="https://jeff_zhong.gitee.io/tags/nginx/"/>
    
      <category term="postgres" scheme="https://jeff_zhong.gitee.io/tags/postgres/"/>
    
  </entry>
  
  <entry>
    <title>Flutter轮播图</title>
    <link href="https://jeff_zhong.gitee.io/2020/07/01/flutter2/"/>
    <id>https://jeff_zhong.gitee.io/2020/07/01/flutter2/</id>
    <published>2020-07-01T08:34:40.000Z</published>
    <updated>2021-12-26T06:48:07.625Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前端开发当中最有意思的就是实现动画特效，&lt;code&gt;Flutter&lt;/code&gt;提供的各种动画组件可以方便实现各种动画效果。&lt;code&gt;Flutter&lt;/code&gt;中的动画组件主要分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隐式动画控件：只需设置组件开始值，结束值，执行时间，比如&lt;code&gt;AnimatedOpacity&lt;/code&gt;，&lt;code&gt;AnimatedSize&lt;/code&gt;等组件。&lt;/li&gt;
&lt;li&gt;显式动画控件：需要设置&lt;code&gt;AnimationController&lt;/code&gt;，手动控制动画的执行。显式动画可以完成隐式动画的效果，甚至更加地可控和灵活，不过需要管理该动画的&lt;code&gt;AnimationController&lt;/code&gt;生命周期，&lt;code&gt;AnimationController&lt;/code&gt;并不是一个控件，所以需要将其放在&lt;code&gt;StatefulWidget&lt;/code&gt;中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="flutter" scheme="https://jeff_zhong.gitee.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter开发初探</title>
    <link href="https://jeff_zhong.gitee.io/2020/06/26/flutter1/"/>
    <id>https://jeff_zhong.gitee.io/2020/06/26/flutter1/</id>
    <published>2020-06-26T03:51:06.000Z</published>
    <updated>2021-12-26T06:48:04.428Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;目前跨端开发比较热门的就是 &lt;code&gt;React Native&lt;/code&gt; 和 &lt;code&gt;Flutter&lt;/code&gt; 了，到底该选哪门技术似乎也快成了大前端圈的一个热门话题。对于web前端来说，基于web生态的 &lt;code&gt;React Native&lt;/code&gt; 应该是一个更加顺畅而自然的选择；但 &lt;code&gt;Flutter&lt;/code&gt; 让人动心的地方就是高性能和 跨端UI一致性。而&lt;code&gt;React Native&lt;/code&gt; 发展不太明朗和 &lt;code&gt;Flutter&lt;/code&gt; 越发成熟的走势对比促使我从观望的心态转为加入 &lt;code&gt;Flutter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要就是记录一下学习&lt;code&gt;Flutter&lt;/code&gt;的一些感想和看法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包管理&lt;/li&gt;
&lt;li&gt;布局和样式&lt;/li&gt;
&lt;li&gt;json&lt;/li&gt;
&lt;li&gt;状态管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="flutter" scheme="https://jeff_zhong.gitee.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>SVG高级应用及动画</title>
    <link href="https://jeff_zhong.gitee.io/2020/06/04/svg1/"/>
    <id>https://jeff_zhong.gitee.io/2020/06/04/svg1/</id>
    <published>2020-06-04T01:42:56.000Z</published>
    <updated>2024-01-05T09:04:08.571Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;canvas 和 webGL 这两项图形技术结合 css3 可以说能完成绝大部分的动画和需求。但 canvas 和 webGL 毕竟是偏向底层的绘制引擎，某些场景使用起来还是过于繁琐的，不分场合一律使用锤子解决的行为不值得提倡。svg 在解决排版，图标，相关动画还是非常高效的，而且 svg 还是矢量图形，高清还原各种屏幕尺寸的设计简直就是神器。&lt;/p&gt;
&lt;p&gt;svg 基础知识不再讲解，结合svg特点和应用场景，主要介绍如下几方面的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;svg sprite&lt;/li&gt;
&lt;li&gt;css background-image 插入svg&lt;/li&gt;
&lt;li&gt;文字路径&lt;/li&gt;
&lt;li&gt;路径动画&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="svg" scheme="https://jeff_zhong.gitee.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>使用typescript改造koa开发框架</title>
    <link href="https://jeff_zhong.gitee.io/2020/02/04/koatypescript/"/>
    <id>https://jeff_zhong.gitee.io/2020/02/04/koatypescript/</id>
    <published>2020-02-04T03:37:48.000Z</published>
    <updated>2021-12-26T06:48:37.425Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://jeff_zhong.gitee.io/blog/2020/02/04/koatypescript/&quot;&gt;使用typescript改造koa开发框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;强类型的 &lt;strong&gt;TypeScript&lt;/strong&gt; 开发体验和维护项目上相比 &lt;strong&gt;JavaScript&lt;/strong&gt; 有着明显的优势，那么对常用的脚手架进行改造也就势在必行了。&lt;/p&gt;
&lt;p&gt;接下来开始对基于 &lt;strong&gt;koa&lt;/strong&gt; 框架的 &lt;strong&gt;node&lt;/strong&gt; 后端脚手架进行改造：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目开发环境 和 &lt;strong&gt;typescript&lt;/strong&gt; 编译环境的搭建；&lt;/li&gt;
&lt;li&gt;对 &lt;strong&gt;node&lt;/strong&gt;、&lt;strong&gt;koa&lt;/strong&gt;、koa中间件和使用到的库 添加类型化支持；&lt;/li&gt;
&lt;li&gt;基于 &lt;strong&gt;typesript&lt;/strong&gt; 的特性改造项目。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://jeff_zhong.gitee.io/tags/node/"/>
    
      <category term="koa" scheme="https://jeff_zhong.gitee.io/tags/koa/"/>
    
      <category term="typescript" scheme="https://jeff_zhong.gitee.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>WebGL之物体选择</title>
    <link href="https://jeff_zhong.gitee.io/2019/05/28/webglray/"/>
    <id>https://jeff_zhong.gitee.io/2019/05/28/webglray/</id>
    <published>2019-05-28T07:07:25.000Z</published>
    <updated>2021-12-26T06:49:36.011Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用WebGL将图形绘制到画布后，如何与外部进行交互？这其中最关键的就是如何实现物体的选择。比如鼠标点击后判断是否选中了某个图形或图形的某个部分。&lt;/p&gt;
&lt;p&gt;本节实现的效果: &lt;em&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/webglray.html&quot;&gt;WebGL选中物体&lt;/a&gt;&lt;/em&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/polygonselect.png&quot; width=&quot;400&quot; alt=&quot;WebGL选中物体&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之HDR与Bloom</title>
    <link href="https://jeff_zhong.gitee.io/2019/05/21/webglhdr/"/>
    <id>https://jeff_zhong.gitee.io/2019/05/21/webglhdr/</id>
    <published>2019-05-21T07:09:15.000Z</published>
    <updated>2021-12-26T06:49:27.000Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[WebGL学习之HDR与Bloom](https://jeff_zhong.gitee.io/blog/2018/01/12/webglhdr/)--&gt;

&lt;h2 id=&quot;什么是HDR&quot;&gt;&lt;a href=&quot;#什么是HDR&quot; class=&quot;headerlink&quot; title=&quot;什么是HDR&quot;&gt;&lt;/a&gt;什么是HDR&lt;/h2&gt;&lt;p&gt;HDR (High Dynamic Range，高动态范围)，在摄影领域，指的是可以提供更多的动态范围和图像细节的一种技术手段。简单讲就是将不同曝光拍摄出的最佳细节的LDR (低动态范围) 图像合成后，就叫HDR，它能同时反映出场景最暗和最亮部分的细节。为什么需要多张图片？因为目前的单反相机的宽容度还是有限的，一张照片不能反映出高动态场景的所有细节。一张图片拍摄就必须要在暗光和高光之间做出取舍，只能亮部暗部两者取其一。但是通过HDR合成多张图片，却能达到我们想要的效果。&lt;br&gt;&lt;img src=&quot;/blog/images/hdr.png&quot; alt=&quot;hdr&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之纹理盒</title>
    <link href="https://jeff_zhong.gitee.io/2019/05/05/webglskybox/"/>
    <id>https://jeff_zhong.gitee.io/2019/05/05/webglskybox/</id>
    <published>2019-05-05T13:34:20.000Z</published>
    <updated>2021-12-26T06:49:54.788Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们之前已经学习过二维纹理 &lt;strong&gt;gl.TEXTURE_2D&lt;/strong&gt;，而且还使用它实现了各种效果。但还有一种立方体纹理 &lt;strong&gt;gl.TEXTURE_CUBE_MAP&lt;/strong&gt;，它包含了6个纹理代表立方体的6个面。不像常规的纹理坐标有2个纬度，立方体纹理使用法向量，换句话说三维方向。本节实现的demo请看 &lt;strong&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/webglskybox.html&quot;&gt;天空盒&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/skybox.gif&quot; width=&quot;400&quot; alt=&quot;sky box&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL半透明物体的绘制</title>
    <link href="https://jeff_zhong.gitee.io/2019/05/02/webglalpha/"/>
    <id>https://jeff_zhong.gitee.io/2019/05/02/webglalpha/</id>
    <published>2019-05-02T05:16:29.000Z</published>
    <updated>2021-12-26T06:49:22.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;WebGL 中当透明和半透明物体共存时，相关设置不正确的话，物体表面会出现破碎杂乱的断面，非常影响效果，我们接着就来解决这个问题。&lt;br&gt;完成的展示Demo请看: &lt;strong&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/webglalpha.html&quot;&gt;半透明物体和透明物体共存&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/blog/images/alpha.gif&quot; alt=&quot;alpha混合&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之法线贴图</title>
    <link href="https://jeff_zhong.gitee.io/2019/04/30/webglnormap/"/>
    <id>https://jeff_zhong.gitee.io/2019/04/30/webglnormap/</id>
    <published>2019-04-30T03:07:27.000Z</published>
    <updated>2021-12-26T06:49:30.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/images/texture.png&quot; width=&quot;400&quot; alt=&quot;法线贴图&quot;&gt;

&lt;p&gt;为了增加额外细节，提升真实感，我们使用了漫反射贴图和高光贴图，它们都是向三角形进行附加纹理。但是从光的视角来看是表面法线向量使表面被视为平坦光滑的表面。以光照算法的视角考虑的话，只有一件事决定物体的形状，那就是垂直于它的法线向量。砖块表面只有一个法向量，表面完全根据这个法向量被以一致的方式照亮。如果每个片元都用不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：&lt;br&gt;&lt;img src=&quot;/blog/images/norplane.png&quot; alt=&quot;表面法线&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之纹理贴图</title>
    <link href="https://jeff_zhong.gitee.io/2019/04/29/webgltexture/"/>
    <id>https://jeff_zhong.gitee.io/2019/04/29/webgltexture/</id>
    <published>2019-04-29T03:24:21.000Z</published>
    <updated>2021-12-26T06:50:04.378Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;为了使图形能获得接近于真实物体的材质效果，一般会使用贴图，贴图类型主要包括两种：漫反射贴图和镜面高光贴图。其中漫反射贴图可以同时实现漫反射光和环境光的效果。&lt;br&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://jeff_zhong.gitee.io/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://jeff_zhong.gitee.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="webGL" scheme="https://jeff_zhong.gitee.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>如何将markdown转换为wxml</title>
    <link href="https://jeff_zhong.gitee.io/2019/04/27/mdtowxml/"/>
    <id>https://jeff_zhong.gitee.io/2019/04/27/mdtowxml/</id>
    <published>2019-04-27T02:36:23.000Z</published>
    <updated>2021-12-26T06:48:42.996Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;话说我要为技术博客写一个小程序版，我的博客解决方案是 &lt;strong&gt;hexo + github-page&lt;/strong&gt;，格式当然是技术控们喜欢的  &lt;strong&gt;markdown&lt;/strong&gt; 了 。但小程序使用的却是独有的模版语言 &lt;strong&gt;WXML&lt;/strong&gt;。我总不能把之前的文章手动转换成小程序的 &lt;strong&gt;wxml&lt;/strong&gt; 格式吧，而网上也没完善的转换库，还是自己写个解析器吧。&lt;/p&gt;
&lt;p&gt;解析器最核心的部分就是字符串模式匹配，既然涉及到字符串匹配，那么就离不开正则表达式。幸好，正则表达式是我的优势之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://jeff_zhong.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://jeff_zhong.gitee.io/tags/js/"/>
    
      <category term="wxml" scheme="https://jeff_zhong.gitee.io/tags/wxml/"/>
    
      <category term="markdown" scheme="https://jeff_zhong.gitee.io/tags/markdown/"/>
    
      <category term="正则表达式" scheme="https://jeff_zhong.gitee.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>

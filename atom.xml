<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff&#39;s world</title>
  <icon>https://edwardzhong.github.io/icon.png</icon>
  <subtitle>Things that I&#39;m interested in</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://edwardzhong.github.io/"/>
  <updated>2020-07-13T06:59:48.432Z</updated>
  <id>https://edwardzhong.github.io/</id>
  
  <author>
    <name>Jeff Zhong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker搭建部署Node项目</title>
    <link href="https://edwardzhong.github.io/2020/07/13/docker/"/>
    <id>https://edwardzhong.github.io/2020/07/13/docker/</id>
    <published>2020-07-13T03:39:53.000Z</published>
    <updated>2020-07-13T06:59:48.432Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前段时间做了个&lt;code&gt;node&lt;/code&gt;全栈项目，服务端技术栈是 &lt;code&gt;nginx&lt;/code&gt; + &lt;code&gt;koa&lt;/code&gt; + &lt;code&gt;postgresql&lt;/code&gt;。其中在&lt;code&gt;centos&lt;/code&gt;上搭建环境和部署都挺费周折，部署测试服务器，接着上线的时候又部署生产环境服务器。这中间就有很多既无聊又费精力，吃力不讨好的”体力活”。所以就开始思考怎么自动化这部分搭建部署的工作，也就引出了&lt;code&gt;Docker&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="https://edwardzhong.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Flutter轮播图</title>
    <link href="https://edwardzhong.github.io/2020/07/01/flutter2/"/>
    <id>https://edwardzhong.github.io/2020/07/01/flutter2/</id>
    <published>2020-07-01T08:34:40.000Z</published>
    <updated>2020-07-01T13:39:53.098Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前端开发当中最有意思的就是实现动画特效，&lt;code&gt;Flutter&lt;/code&gt;提供的各种动画组件可以方便实现各种动画效果。&lt;code&gt;Flutter&lt;/code&gt;中的动画组件主要分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隐式动画控件：只需设置组件开始值，结束值，执行时间，比如&lt;code&gt;AnimatedOpacity&lt;/code&gt;，&lt;code&gt;AnimatedSize&lt;/code&gt;等组件。&lt;/li&gt;
&lt;li&gt;显式动画控件：需要设置&lt;code&gt;AnimationController&lt;/code&gt;，手动控制动画的执行。显式动画可以完成隐式动画的效果，甚至更加地可控和灵活，不过需要管理该动画的&lt;code&gt;AnimationController&lt;/code&gt;生命周期，&lt;code&gt;AnimationController&lt;/code&gt;并不是一个控件，所以需要将其放在&lt;code&gt;StatefulWidget&lt;/code&gt;中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="flutter" scheme="https://edwardzhong.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter开发初探</title>
    <link href="https://edwardzhong.github.io/2020/06/26/flutter1/"/>
    <id>https://edwardzhong.github.io/2020/06/26/flutter1/</id>
    <published>2020-06-26T03:51:06.000Z</published>
    <updated>2020-06-26T04:05:29.082Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;目前跨端开发比较热门的就是 &lt;code&gt;React Native&lt;/code&gt; 和 &lt;code&gt;Flutter&lt;/code&gt; 了，到底该选哪门技术似乎也快成了大前端圈的一个热门话题。对于web前端来说，基于web生态的 &lt;code&gt;React Native&lt;/code&gt; 应该是一个更加顺畅而自然的选择；但 &lt;code&gt;Flutter&lt;/code&gt; 让人动心的地方就是高性能和 跨端UI一致性。而&lt;code&gt;React Native&lt;/code&gt; 发展不太明朗和 &lt;code&gt;Flutter&lt;/code&gt; 越发成熟的走势对比促使我从观望的心态转为加入 &lt;code&gt;Flutter&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里主要就是记录一下学习&lt;code&gt;Flutter&lt;/code&gt;的一些感想和看法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包管理&lt;/li&gt;
&lt;li&gt;布局和样式&lt;/li&gt;
&lt;li&gt;json&lt;/li&gt;
&lt;li&gt;状态管理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="flutter" scheme="https://edwardzhong.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>SVG高级应用及动画</title>
    <link href="https://edwardzhong.github.io/2020/06/04/svg1/"/>
    <id>https://edwardzhong.github.io/2020/06/04/svg1/</id>
    <published>2020-06-04T01:42:56.000Z</published>
    <updated>2020-07-01T13:50:05.416Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;canvas 和 webGL 这两项图形技术结合 css3 可以说能完成绝大部分的动画和需求。但 canvas 和 webGL 毕竟是偏向底层的绘制引擎，某些场景使用起来还是过于繁琐的，不分场合一律使用锤子解决的行为不值得提倡。svg 在解决排版，图标，相关动画还是非常高效的，而且 svg 还是矢量图形，高清还原各种屏幕尺寸的设计简直就是神器。&lt;/p&gt;
&lt;p&gt;svg 基础知识不再讲解，结合svg特点和应用场景，主要介绍如下几方面的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;svg sprite&lt;/li&gt;
&lt;li&gt;css background-image 插入svg&lt;/li&gt;
&lt;li&gt;文字路径&lt;/li&gt;
&lt;li&gt;路径动画&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="svg" scheme="https://edwardzhong.github.io/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>使用typescript改造koa开发框架</title>
    <link href="https://edwardzhong.github.io/2020/02/04/koatypescript/"/>
    <id>https://edwardzhong.github.io/2020/02/04/koatypescript/</id>
    <published>2020-02-04T03:37:48.000Z</published>
    <updated>2020-02-04T06:27:55.710Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;https://edwardzhong.github.io/2020/02/04/koatypescript/&quot;&gt;使用typescript改造koa开发框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;强类型的 &lt;strong&gt;TypeScript&lt;/strong&gt; 开发体验和维护项目上相比 &lt;strong&gt;JavaScript&lt;/strong&gt; 有着明显的优势，那么对常用的脚手架进行改造也就势在必行了。&lt;/p&gt;
&lt;p&gt;接下来开始对基于 &lt;strong&gt;koa&lt;/strong&gt; 框架的 &lt;strong&gt;node&lt;/strong&gt; 后端脚手架进行改造：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目开发环境 和 &lt;strong&gt;typescript&lt;/strong&gt; 编译环境的搭建；&lt;/li&gt;
&lt;li&gt;对 &lt;strong&gt;node&lt;/strong&gt;、&lt;strong&gt;koa&lt;/strong&gt;、koa中间件和使用到的库 添加类型化支持；&lt;/li&gt;
&lt;li&gt;基于 &lt;strong&gt;typesript&lt;/strong&gt; 的特性改造项目。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://edwardzhong.github.io/tags/node/"/>
    
      <category term="koa" scheme="https://edwardzhong.github.io/tags/koa/"/>
    
      <category term="typescript" scheme="https://edwardzhong.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>WebGL之物体选择</title>
    <link href="https://edwardzhong.github.io/2019/05/28/webglray/"/>
    <id>https://edwardzhong.github.io/2019/05/28/webglray/</id>
    <published>2019-05-28T07:07:25.000Z</published>
    <updated>2020-01-16T10:14:48.067Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用WebGL将图形绘制到画布后，如何与外部进行交互？这其中最关键的就是如何实现物体的选择。比如鼠标点击后判断是否选中了某个图形或图形的某个部分。&lt;/p&gt;
&lt;p&gt;本节实现的效果: &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglray.html&quot;&gt;WebGL选中物体&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-f6e7de79c53b2935.png&quot; width=&quot;400&quot; alt=&quot;WebGL选中物体&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之HDR与Bloom</title>
    <link href="https://edwardzhong.github.io/2019/05/21/webglhdr/"/>
    <id>https://edwardzhong.github.io/2019/05/21/webglhdr/</id>
    <published>2019-05-21T07:09:15.000Z</published>
    <updated>2020-01-16T10:14:26.359Z</updated>
    
    <summary type="html">
    
      &lt;!-- 原文地址：[WebGL学习之HDR与Bloom](https://edwardzhong.github.io/2018/01/12/webglhdr/)--&gt;

&lt;h2 id=&quot;什么是HDR&quot;&gt;&lt;a href=&quot;#什么是HDR&quot; class=&quot;headerlink&quot; title=&quot;什么是HDR&quot;&gt;&lt;/a&gt;什么是HDR&lt;/h2&gt;&lt;p&gt;HDR (High Dynamic Range，高动态范围)，在摄影领域，指的是可以提供更多的动态范围和图像细节的一种技术手段。简单讲就是将不同曝光拍摄出的最佳细节的LDR (低动态范围) 图像合成后，就叫HDR，它能同时反映出场景最暗和最亮部分的细节。为什么需要多张图片？因为目前的单反相机的宽容度还是有限的，一张照片不能反映出高动态场景的所有细节。一张图片拍摄就必须要在暗光和高光之间做出取舍，只能亮部暗部两者取其一。但是通过HDR合成多张图片，却能达到我们想要的效果。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-2960edbc2c229388.png&quot; alt=&quot;hdr&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之纹理盒</title>
    <link href="https://edwardzhong.github.io/2019/05/05/webglskybox/"/>
    <id>https://edwardzhong.github.io/2019/05/05/webglskybox/</id>
    <published>2019-05-05T13:34:20.000Z</published>
    <updated>2020-01-16T10:15:09.466Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们之前已经学习过二维纹理 &lt;strong&gt;gl.TEXTURE_2D&lt;/strong&gt;，而且还使用它实现了各种效果。但还有一种立方体纹理 &lt;strong&gt;gl.TEXTURE_CUBE_MAP&lt;/strong&gt;，它包含了6个纹理代表立方体的6个面。不像常规的纹理坐标有2个纬度，立方体纹理使用法向量，换句话说三维方向。本节实现的demo请看 &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglskybox.html&quot;&gt;天空盒&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-21b5d76b44dbd274.gif&quot; width=&quot;400&quot; alt=&quot;sky box&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL半透明物体的绘制</title>
    <link href="https://edwardzhong.github.io/2019/05/02/webglalpha/"/>
    <id>https://edwardzhong.github.io/2019/05/02/webglalpha/</id>
    <published>2019-05-02T05:16:29.000Z</published>
    <updated>2020-01-16T10:14:19.851Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;WebGL 中当透明和半透明物体共存时，相关设置不正确的话，物体表面会出现破碎杂乱的断面，非常影响效果，我们接着就来解决这个问题。&lt;br&gt;完成的展示Demo请看: &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglalpha.html&quot;&gt;半透明物体和透明物体共存&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-07fe85ce0e09500c.gif&quot; alt=&quot;alpha混合&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之法线贴图</title>
    <link href="https://edwardzhong.github.io/2019/04/30/webglnormap/"/>
    <id>https://edwardzhong.github.io/2019/04/30/webglnormap/</id>
    <published>2019-04-30T03:07:27.000Z</published>
    <updated>2020-01-16T10:14:35.347Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-a2003e57ddd79184.png&quot; width=&quot;400&quot; alt=&quot;法线贴图&quot;&gt;

&lt;p&gt;为了增加额外细节，提升真实感，我们使用了漫反射贴图和高光贴图，它们都是向三角形进行附加纹理。但是从光的视角来看是表面法线向量使表面被视为平坦光滑的表面。以光照算法的视角考虑的话，只有一件事决定物体的形状，那就是垂直于它的法线向量。砖块表面只有一个法向量，表面完全根据这个法向量被以一致的方式照亮。如果每个片元都用不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-91a0ac5e7a16904f.png&quot; alt=&quot;表面法线&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>WebGL学习之纹理贴图</title>
    <link href="https://edwardzhong.github.io/2019/04/29/webgltexture/"/>
    <id>https://edwardzhong.github.io/2019/04/29/webgltexture/</id>
    <published>2019-04-29T03:24:21.000Z</published>
    <updated>2020-01-16T10:15:25.119Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;为了使图形能获得接近于真实物体的材质效果，一般会使用贴图，贴图类型主要包括两种：漫反射贴图和镜面高光贴图。其中漫反射贴图可以同时实现漫反射光和环境光的效果。&lt;br&gt;实际效果请看demo：&lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglTexture.html&quot;&gt;纹理贴图&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="webGL" scheme="https://edwardzhong.github.io/tags/webGL/"/>
    
  </entry>
  
  <entry>
    <title>如何将markdown转换为wxml</title>
    <link href="https://edwardzhong.github.io/2019/04/27/mdtowxml/"/>
    <id>https://edwardzhong.github.io/2019/04/27/mdtowxml/</id>
    <published>2019-04-27T02:36:23.000Z</published>
    <updated>2020-01-16T10:12:58.021Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;话说我要为技术博客写一个小程序版，我的博客解决方案是 &lt;strong&gt;hexo + github-page&lt;/strong&gt;，格式当然是技术控们喜欢的  &lt;strong&gt;markdown&lt;/strong&gt; 了 。但小程序使用的却是独有的模版语言 &lt;strong&gt;WXML&lt;/strong&gt;。我总不能把之前的文章手动转换成小程序的 &lt;strong&gt;wxml&lt;/strong&gt; 格式吧，而网上也没完善的转换库，还是自己写个解析器吧。&lt;/p&gt;
&lt;p&gt;解析器最核心的部分就是字符串模式匹配，既然涉及到字符串匹配，那么就离不开正则表达式。幸好，正则表达式是我的优势之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="wxml" scheme="https://edwardzhong.github.io/tags/wxml/"/>
    
      <category term="markdown" scheme="https://edwardzhong.github.io/tags/markdown/"/>
    
      <category term="正则表达式" scheme="https://edwardzhong.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>小试小程序云开发</title>
    <link href="https://edwardzhong.github.io/2019/04/26/weappcloud/"/>
    <id>https://edwardzhong.github.io/2019/04/26/weappcloud/</id>
    <published>2019-04-26T02:13:20.000Z</published>
    <updated>2020-01-16T10:14:06.379Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序刚出没多久时，曾经上手写过demo，但开发体验比较差，所以一直没怎么关注。不过自从诸多适配方案出炉，以及云端的开通，觉得还是有必要上手体验一番的，于是为我的技术博客也写了个小程序版。&lt;/p&gt;
&lt;p&gt;原生开发我是不想再试了，那就选一种适配方案，目前比较知名的有基于vue的 &lt;strong&gt;mpvue&lt;/strong&gt;，&lt;strong&gt;umi-app&lt;/strong&gt;，基于react 的 &lt;strong&gt;taro&lt;/strong&gt;，以及TX团队出的全新框架 &lt;strong&gt;wepy&lt;/strong&gt;。个人对 react 的好感 以及 &lt;strong&gt;taro&lt;/strong&gt; 框架的走向成熟，促使我选择了 &lt;strong&gt;taro&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="taro" scheme="https://edwardzhong.github.io/tags/taro/"/>
    
      <category term="小程序" scheme="https://edwardzhong.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>koa+mysql+vue+socket.io全栈开发之前端篇</title>
    <link href="https://edwardzhong.github.io/2019/04/13/fullstack3/"/>
    <id>https://edwardzhong.github.io/2019/04/13/fullstack3/</id>
    <published>2019-04-13T05:43:45.000Z</published>
    <updated>2020-01-16T10:11:00.285Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;React&lt;/strong&gt; 与 &lt;strong&gt;Vue&lt;/strong&gt; 之间的对比，是前端的一大热门话题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vue&lt;/strong&gt; 简易上手的脚手架，以及官方提供必备的基础组件，比如 &lt;strong&gt;vuex&lt;/strong&gt;，&lt;strong&gt;vue-router&lt;/strong&gt;，对新手真的比较友好；&lt;strong&gt;react&lt;/strong&gt; 则把这些都交给社区去做，虽然这壮大了 &lt;strong&gt;react&lt;/strong&gt; 的生态链，但新手要弄出一套趁手的方案挺麻烦的，不过好在现在有很多类似 dva 的方案了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vue&lt;/strong&gt; 比较讨喜的一点，就是它的数据双向流动在表单开发时特别方便，而 &lt;strong&gt;react&lt;/strong&gt; 在这方面可就麻烦多了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;但是 &lt;strong&gt;vue&lt;/strong&gt; 复杂的 api ，简直让人头大，光是文档说明都几十页了。太多的语法，太多的魔法符号，对进化速度越来越快的前端届来说，就是入手这个框架的最大阻碍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而相反 &lt;strong&gt;react&lt;/strong&gt; 的 api 数量简直可以忽略不计了，顶多花几小时就能看完官方文档。你只要理解 &lt;strong&gt;JavaScript&lt;/strong&gt;，就能理解 &lt;strong&gt;react&lt;/strong&gt; 的很多行为。&lt;strong&gt;react&lt;/strong&gt; 的很多用法，它的 api 都是符合直觉的，你对它用法的猜测基本都是八九不离十的，这真是大大降低了心智负担。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除此之外，&lt;strong&gt;react&lt;/strong&gt; 的 &lt;strong&gt;jsx&lt;/strong&gt; 语法表达能力更强，还有 &lt;strong&gt;hoc&lt;/strong&gt; 和 &lt;strong&gt;hooks&lt;/strong&gt; 使代码也更容易组织和复用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然我更喜欢 &lt;strong&gt;React&lt;/strong&gt; ，但工作上的需求，还不是要你用什么你就得用什么 😂，所以这个 demo 就当是探索 &lt;strong&gt;Vue&lt;/strong&gt; 的前奏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="https://edwardzhong.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="https://edwardzhong.github.io/tags/vuex/"/>
    
      <category term="socket.io" scheme="https://edwardzhong.github.io/tags/socket-io/"/>
    
  </entry>
  
  <entry>
    <title>koa+mysql+vue+socket.io全栈开发之数据访问篇</title>
    <link href="https://edwardzhong.github.io/2019/04/12/fullstack2/"/>
    <id>https://edwardzhong.github.io/2019/04/12/fullstack2/</id>
    <published>2019-04-12T07:34:17.000Z</published>
    <updated>2020-01-16T10:10:51.126Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;后端搭起大体的框架后，接着涉及到的就是如何将数据持久化的问题，也就是对数据库进行 &lt;strong&gt;CURD&lt;/strong&gt; 操作。&lt;/p&gt;
&lt;p&gt;关于数据库方案, &lt;strong&gt;mongodb&lt;/strong&gt; 和 &lt;strong&gt;mysql&lt;/strong&gt;  都使用过，但我选用的是 &lt;strong&gt;mysql&lt;/strong&gt;，原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目前为止 &lt;strong&gt;mysql&lt;/strong&gt; 与 &lt;strong&gt;mongodb&lt;/strong&gt; 性能相差不大，尤其是 &lt;strong&gt;mysql&lt;/strong&gt; 8.0 版本，速度非常快，查询数据是 mysql 更快，写数据方面 &lt;strong&gt;mongodb&lt;/strong&gt; 则更胜一筹；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mysql&lt;/strong&gt; 建立 关联数据要更方便些，比如： 一对多，多对多的关系；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mysql&lt;/strong&gt; 作为关系型数据库，数据一致性方面更好，尤其是事务用起来更顺手；&lt;/li&gt;
&lt;li&gt;本人对 sql 操作比较得心应手，毕竟大部分项目用得都是 &lt;strong&gt;mysql&lt;/strong&gt;，而 &lt;strong&gt;mongodb&lt;/strong&gt; 在正式些的项目上用的就少了，而且目前关系型数据库也在进化, &lt;strong&gt;postgrep&lt;/strong&gt; 和 &lt;strong&gt;mysql&lt;/strong&gt; 都已经支持 json了。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://edwardzhong.github.io/tags/node/"/>
    
      <category term="mysql" scheme="https://edwardzhong.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>koa+mysql+vue+socket.io全栈开发之web api篇</title>
    <link href="https://edwardzhong.github.io/2019/04/08/fullstack/"/>
    <id>https://edwardzhong.github.io/2019/04/08/fullstack/</id>
    <published>2019-04-08T07:50:03.000Z</published>
    <updated>2020-01-16T10:10:42.302Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;目标是建立一个 &lt;strong&gt;web QQ&lt;/strong&gt; 的项目，使用的技术栈如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;后端是基于 &lt;strong&gt;koa2&lt;/strong&gt; 的 web api 服务层，提供 curd 操作的 http 接口，登录验证使用的是 &lt;strong&gt;json web token&lt;/strong&gt;，跨域方案使用的是 &lt;strong&gt;cors&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据库使用的是 &lt;strong&gt;mysql&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了实时通信，使用的是基于 websocket 协议的 &lt;strong&gt;socket.io&lt;/strong&gt; 框架；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端则使用的是 &lt;strong&gt;vue + vuex&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://edwardzhong.github.io/tags/node/"/>
    
      <category term="koa" scheme="https://edwardzhong.github.io/tags/koa/"/>
    
      <category term="jwt" scheme="https://edwardzhong.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>关于socket.io的使用</title>
    <link href="https://edwardzhong.github.io/2019/03/29/socketio/"/>
    <id>https://edwardzhong.github.io/2019/03/29/socketio/</id>
    <published>2019-03-28T16:44:31.000Z</published>
    <updated>2020-01-16T10:13:27.652Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这段时间学习了&lt;strong&gt;socket.io&lt;/strong&gt;，用它写了小项目，在此总结下它的基本使用方式和一些要点。&lt;br&gt;&lt;strong&gt;socket.io&lt;/strong&gt;是基于&lt;strong&gt;Node.js&lt;/strong&gt;和&lt;strong&gt;WebSocket&lt;/strong&gt;协议的实时通信开源框架，它包括客户端的JavaScript和服务器端的Node.js。&lt;/p&gt;
&lt;h2 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h2&gt;&lt;p&gt;这里后端使用的框架是&lt;strong&gt;koa2&lt;/strong&gt;，&lt;strong&gt;socket.io&lt;/strong&gt;将自身绑定到koa的进程中去，其中最重要的事件就是 &lt;strong&gt;connection&lt;/strong&gt; 和 &lt;strong&gt;disconnect&lt;/strong&gt;。它们是框架本身定义的系统事件，也就意味着它是自然就存在的不需要我们自定义，当然还有其它系统事件，但很少会用得到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="socket.io" scheme="https://edwardzhong.github.io/tags/socket-io/"/>
    
  </entry>
  
  <entry>
    <title>基于Webpack 4 和 React hooks 搭建项目</title>
    <link href="https://edwardzhong.github.io/2019/02/04/reacthooks/"/>
    <id>https://edwardzhong.github.io/2019/02/04/reacthooks/</id>
    <published>2019-02-04T05:58:44.000Z</published>
    <updated>2020-01-16T10:13:21.308Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;面对日新月异的前端，我表示快学不动了😂。 &lt;strong&gt;Webpack&lt;/strong&gt; 老早就已经更新到了 V4.x，前段时间 &lt;strong&gt;React&lt;/strong&gt; 又推出了  &lt;strong&gt;hooks&lt;/strong&gt; API。刚好春节在家里休假，时间比较空闲，还是赶紧把 &lt;strong&gt;React&lt;/strong&gt;技术栈这块补上。&lt;/p&gt;
&lt;p&gt;网上有很多介绍 &lt;strong&gt;hooks&lt;/strong&gt; 知识点的文章，但都比较零碎，基本只能写一些小 &lt;strong&gt;Demo&lt;/strong&gt;。还没有比较系统的，全新的基于 &lt;strong&gt;hooks&lt;/strong&gt; 进行搭建实际项目的讲解。所以这里就从开发实际项目的角度，搭建起单页面 &lt;strong&gt;Web App&lt;/strong&gt;项目的基本脚手架，并基于 &lt;strong&gt;hooks&lt;/strong&gt; API 实现一个 &lt;strong&gt;react&lt;/strong&gt; 项目模版。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Hooks&lt;/strong&gt; 最吸引人的地方就是用 &lt;strong&gt;函数式组件&lt;/strong&gt; 代替面向对象的 &lt;strong&gt;类组件&lt;/strong&gt;。此前的 &lt;strong&gt;react&lt;/strong&gt; 如果涉及到状态，解决方案通常只能使用 &lt;strong&gt;类组件&lt;/strong&gt;，业务逻辑一复杂就容易导致组件臃肿，模块的解藕也是个问题。而使用基于 &lt;strong&gt;hooks&lt;/strong&gt; 的 &lt;strong&gt;函数组件&lt;/strong&gt; 后，代码不仅更加简洁，写起来更爽，而且模块复用也方便得多，非常看好它的未来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="react" scheme="https://edwardzhong.github.io/tags/react/"/>
    
      <category term="webpack" scheme="https://edwardzhong.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>动画函数的绘制及自定义动画函数</title>
    <link href="https://edwardzhong.github.io/2019/01/03/animationfun/"/>
    <id>https://edwardzhong.github.io/2019/01/03/animationfun/</id>
    <published>2019-01-02T18:01:23.000Z</published>
    <updated>2020-01-16T10:09:43.455Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;制作动画效果离不开动画运动函数，而我们用得最多的无疑就是 &lt;strong&gt;Tween.js&lt;/strong&gt;。根据不同的数学公式原理，&lt;strong&gt;Tween.js&lt;/strong&gt; 划分出了不同的动画类型，每种动画类型里面都包含以下的缓动类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ease in&lt;/strong&gt; 先慢后快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ease out&lt;/strong&gt; 先块后慢&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ease in out&lt;/strong&gt; 先慢后快再慢&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于缓动函数，我们在 &lt;strong&gt;css3&lt;/strong&gt; 动画里已经用得太多了，不再细讲。&lt;strong&gt;Tween.js&lt;/strong&gt; 源代码请看：&lt;em&gt;&lt;a href=&quot;https://github.com/edwardzhong/html5Canvas/blob/master/js/tween.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tween.js&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="canvas" scheme="https://edwardzhong.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>canvas实现俄罗斯方块</title>
    <link href="https://edwardzhong.github.io/2018/12/12/tetris/"/>
    <id>https://edwardzhong.github.io/2018/12/12/tetris/</id>
    <published>2018-12-12T13:35:33.000Z</published>
    <updated>2020-01-16T10:13:56.516Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;好久没使用canvas了，于是通过写小游戏“俄罗斯方块”再次熟悉下canvas，如果有一定的canvas基础，要实现还是不难的。实际完成的Demo请看：*&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/tetris.html&quot;&gt;canvas俄罗斯方块&lt;/a&gt;*。&lt;/p&gt;
&lt;h2 id=&quot;原理详解&quot;&gt;&lt;a href=&quot;#原理详解&quot; class=&quot;headerlink&quot; title=&quot;原理详解&quot;&gt;&lt;/a&gt;原理详解&lt;/h2&gt;&lt;p&gt;看游戏最终界面，可知需要实现以下关键功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;游戏面板，也就是12 * 20的方格，以及是否填充了方块信息；&lt;/li&gt;
&lt;li&gt;运动方块，方块需要实现移动，变形的功能。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-db822f51691a0904.jpg&quot; alt=&quot;游戏界面&quot;&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://edwardzhong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://edwardzhong.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://edwardzhong.github.io/tags/js/"/>
    
      <category term="canvas" scheme="https://edwardzhong.github.io/tags/canvas/"/>
    
  </entry>
  
</feed>
